{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst backoff_1 = require(\"./backoff\");\n\nconst logger_1 = require(\"./logger\");\n\nconst path_1 = require(\"./path\");\n\nconst reference_1 = require(\"./reference\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst document_reader_1 = require(\"./document-reader\");\n/*!\r\n * Error message for transactional reads that were executed after performing\r\n * writes.\r\n */\n\n\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\n/**\r\n * A reference to a transaction.\r\n *\r\n * The Transaction object passed to a transaction's updateFunction provides\r\n * the methods to read and write data within the transaction context. See\r\n * [runTransaction()]{@link Firestore#runTransaction}.\r\n *\r\n * @class Transaction\r\n */\n\nclass Transaction {\n  /**\r\n   * @hideconstructor\r\n   *\r\n   * @param firestore The Firestore Database client.\r\n   * @param requestTag A unique client-assigned identifier for the scope of\r\n   * this transaction.\r\n   */\n  constructor(firestore, requestTag) {\n    this._firestore = firestore;\n    this._writeBatch = firestore.batch();\n    this._requestTag = requestTag;\n    this._backoff = new backoff_1.ExponentialBackoff();\n  }\n  /**\r\n   * Retrieve a document or a query result from the database. Holds a\r\n   * pessimistic lock on all returned documents.\r\n   *\r\n   * @param {DocumentReference|Query} refOrQuery The document or query to\r\n   * return.\r\n   * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\r\n   * QuerySnapshot for the returned documents.\r\n   *\r\n   * @example\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   return transaction.get(documentRef).then(doc => {\r\n   *     if (doc.exists) {\r\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n   *     } else {\r\n   *       transaction.create(documentRef, { count: 1 });\r\n   *     }\r\n   *   });\r\n   * });\r\n   */\n\n\n  get(refOrQuery) {\n    if (!this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n\n    if (refOrQuery instanceof reference_1.DocumentReference) {\n      const documentReader = new document_reader_1.DocumentReader(this._firestore, [refOrQuery]);\n      documentReader.transactionId = this._transactionId;\n      return documentReader.get(this._requestTag).then(([res]) => res);\n    }\n\n    if (refOrQuery instanceof reference_1.Query) {\n      return refOrQuery._get(this._transactionId);\n    }\n\n    throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference or a Query.');\n  }\n  /**\r\n   * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\r\n   * all returned documents.\r\n   *\r\n   * The first argument is required and must be of type `DocumentReference`\r\n   * followed by any additional `DocumentReference` documents. If used, the\r\n   * optional `ReadOptions` must be the last argument.\r\n   *\r\n   * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\r\n   * `DocumentReferences` to receive, followed by an optional field mask.\r\n   * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\r\n   * contains an array with the resulting document snapshots.\r\n   *\r\n   * @example\r\n   * let firstDoc = firestore.doc('col/doc1');\r\n   * let secondDoc = firestore.doc('col/doc2');\r\n   * let resultDoc = firestore.doc('col/doc3');\r\n   *\r\n   * firestore.runTransaction(transaction => {\r\n   *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\r\n   *     transaction.set(resultDoc, {\r\n   *       sum: docs[0].get('count') + docs[1].get('count')\r\n   *     });\r\n   *   });\r\n   * });\r\n   */\n\n\n  getAll(...documentRefsOrReadOptions) {\n    if (!this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n\n    validate_1.validateMinNumberOfArguments('Transaction.getAll', documentRefsOrReadOptions, 1);\n    const {\n      documents,\n      fieldMask\n    } = parseGetAllArguments(documentRefsOrReadOptions);\n    const documentReader = new document_reader_1.DocumentReader(this._firestore, documents);\n    documentReader.fieldMask = fieldMask || undefined;\n    documentReader.transactionId = this._transactionId;\n    return documentReader.get(this._requestTag);\n  }\n  /**\r\n   * Create the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. The operation will\r\n   * fail the transaction if a document exists at the specified location.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * created.\r\n   * @param {DocumentData} data The object data to serialize as the document.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   return transaction.get(documentRef).then(doc => {\r\n   *     if (!doc.exists) {\r\n   *       transaction.create(documentRef, { foo: 'bar' });\r\n   *     }\r\n   *   });\r\n   * });\r\n   */\n\n\n  create(documentRef, data) {\n    this._writeBatch.create(documentRef, data);\n\n    return this;\n  }\n  /**\r\n   * Writes to the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document\r\n   * does not exist yet, it will be created. If you pass\r\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into the\r\n   * existing document.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * set.\r\n   * @param {T|Partial<T>} data The object to serialize as the document.\r\n   * @param {SetOptions=} options An object to configure the set behavior.\r\n   * @param {boolean=} options.merge - If true, set() merges the values\r\n   * specified in its data argument. Fields omitted from this set() call\r\n   * remain untouched.\r\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\r\n   * set() only replaces the specified field paths. Any field path that is not\r\n   * specified is ignored and remains untouched.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   transaction.set(documentRef, { foo: 'bar' });\r\n   *   return Promise.resolve();\r\n   * });\r\n   */\n\n\n  set(documentRef, data, options) {\n    this._writeBatch.set(documentRef, data, options);\n\n    return this;\n  }\n  /**\r\n   * Updates fields in the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. The update will\r\n   * fail if applied to a document that does not exist.\r\n   *\r\n   * The update() method accepts either an object with field paths encoded as\r\n   * keys and field values encoded as values, or a variable number of arguments\r\n   * that alternate between field paths and field values. Nested fields can be\r\n   * updated by providing dot-separated field path strings or by providing\r\n   * FieldPath objects.\r\n   *\r\n   * A Precondition restricting this update can be specified as the last\r\n   * argument.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * updated.\r\n   * @param {UpdateData|string|FieldPath} dataOrField An object\r\n   * containing the fields and values with which to update the document\r\n   * or the path of the first field to update.\r\n   * @param {\r\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\r\n   * An alternating list of field paths and values to update or a Precondition\r\n   * to to enforce on this update.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   return transaction.get(documentRef).then(doc => {\r\n   *     if (doc.exists) {\r\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n   *     } else {\r\n   *       transaction.create(documentRef, { count: 1 });\r\n   *     }\r\n   *   });\r\n   * });\r\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    // eslint-disable-next-line prefer-rest-params\n    validate_1.validateMinNumberOfArguments('Transaction.update', arguments, 2);\n\n    this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n\n    return this;\n  }\n  /**\r\n   * Deletes the document referred to by the provided [DocumentReference]\r\n   * {@link DocumentReference}.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * deleted.\r\n   * @param {Precondition=} precondition A precondition to enforce for this\r\n   * delete.\r\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n   * document was last updated at lastUpdateTime. Fails the transaction if the\r\n   * document doesn't exist or was last updated at a different time.\r\n   * @param {boolean=} precondition.exists If set, enforces that the target\r\n   * document must or must not exist.\r\n   * @returns {Transaction} This Transaction instance. Used for\r\n   * chaining method calls.\r\n   *\r\n   * @example\r\n   * firestore.runTransaction(transaction => {\r\n   *   let documentRef = firestore.doc('col/doc');\r\n   *   transaction.delete(documentRef);\r\n   *   return Promise.resolve();\r\n   * });\r\n   */\n\n\n  delete(documentRef, precondition) {\n    this._writeBatch.delete(documentRef, precondition);\n\n    return this;\n  }\n  /**\r\n   * Starts a transaction and obtains the transaction id from the server.\r\n   *\r\n   * @private\r\n   */\n\n\n  begin(readOnly, readTime) {\n    var _a;\n\n    const request = {\n      database: this._firestore.formattedName\n    };\n\n    if (readOnly) {\n      request.options = {\n        readOnly: {\n          readTime: (_a = readTime === null || readTime === void 0 ? void 0 : readTime.toProto()) === null || _a === void 0 ? void 0 : _a.timestampValue\n        }\n      };\n    } else if (this._transactionId) {\n      request.options = {\n        readWrite: {\n          retryTransaction: this._transactionId\n        }\n      };\n    }\n\n    return this._firestore.request('beginTransaction', request, this._requestTag).then(resp => {\n      this._transactionId = resp.transaction;\n    });\n  }\n  /**\r\n   * Commits all queued-up changes in this transaction and releases all locks.\r\n   *\r\n   * @private\r\n   */\n\n\n  commit() {\n    return this._writeBatch._commit({\n      transactionId: this._transactionId,\n      requestTag: this._requestTag\n    }).then(() => {});\n  }\n  /**\r\n   * Releases all locks and rolls back this transaction.\r\n   *\r\n   * @private\r\n   */\n\n\n  rollback() {\n    const request = {\n      database: this._firestore.formattedName,\n      transaction: this._transactionId\n    };\n    return this._firestore.request('rollback', request, this._requestTag);\n  }\n  /**\r\n   * Executes `updateFunction()` and commits the transaction with retry.\r\n   *\r\n   * @private\r\n   * @param updateFunction The user function to execute within the transaction\r\n   * context.\r\n   * @param requestTag A unique client-assigned identifier for the scope of\r\n   * this transaction.\r\n   * @param options The user-defined options for this transaction.\r\n   */\n\n\n  async runTransaction(updateFunction, options) {\n    let result;\n    let lastError = undefined;\n\n    for (let attempt = 0; attempt < options.maxAttempts; ++attempt) {\n      try {\n        if (lastError) {\n          logger_1.logger('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\n          await this.rollback();\n        }\n\n        this._writeBatch._reset();\n\n        await this.maybeBackoff(lastError);\n        await this.begin(options.readOnly, options.readTime);\n        const promise = updateFunction(this);\n\n        if (!(promise instanceof Promise)) {\n          throw new Error('You must return a Promise in your transaction()-callback.');\n        }\n\n        result = await promise;\n        await this.commit();\n        return result;\n      } catch (err) {\n        logger_1.logger('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\n        lastError = err;\n\n        if (!this._transactionId || !isRetryableTransactionError(err)) {\n          break;\n        }\n      }\n    }\n\n    logger_1.logger('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\n    await this.rollback();\n    return Promise.reject(lastError);\n  }\n  /**\r\n   * Delays further operations based on the provided error.\r\n   *\r\n   * @private\r\n   * @return A Promise that resolves after the delay expired.\r\n   */\n\n\n  async maybeBackoff(error) {\n    if ((error === null || error === void 0 ? void 0 : error.code) === 8\n    /* RESOURCE_EXHAUSTED */\n    ) {\n        this._backoff.resetToMax();\n      }\n\n    await this._backoff.backoffAndWait();\n  }\n\n}\n\nexports.Transaction = Transaction;\n/**\r\n * Parses the arguments for the `getAll()` call supported by both the Firestore\r\n * and Transaction class.\r\n *\r\n * @private\r\n * @param documentRefsOrReadOptions An array of document references followed by\r\n * an optional ReadOptions object.\r\n */\n\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n  let documents;\n  let readOptions = undefined;\n\n  if (Array.isArray(documentRefsOrReadOptions[0])) {\n    throw new Error('getAll() no longer accepts an array as its first argument. ' + 'Please unpack your array and call getAll() with individual arguments.');\n  }\n\n  if (documentRefsOrReadOptions.length > 0 && util_1.isPlainObject(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n    readOptions = documentRefsOrReadOptions.pop();\n    documents = documentRefsOrReadOptions;\n  } else {\n    documents = documentRefsOrReadOptions;\n  }\n\n  for (let i = 0; i < documents.length; ++i) {\n    reference_1.validateDocumentReference(i, documents[i]);\n  }\n\n  validateReadOptions('options', readOptions, {\n    optional: true\n  });\n  const fieldMask = readOptions && readOptions.fieldMask ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath)) : null;\n  return {\n    fieldMask,\n    documents\n  };\n}\n\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\r\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\r\n * is an array of strings or field paths.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the ReadOptions can be omitted.\r\n */\n\nfunction validateReadOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} Input is not an object.'`);\n    }\n\n    const options = value;\n\n    if (options.fieldMask !== undefined) {\n      if (!Array.isArray(options.fieldMask)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not an array.`);\n      }\n\n      for (let i = 0; i < options.fieldMask.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, options.fieldMask[i]);\n        } catch (err) {\n          throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n        }\n      }\n    }\n  }\n}\n\nfunction isRetryableTransactionError(error) {\n  if (error.code !== undefined) {\n    // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\n    switch (error.code) {\n      case 10\n      /* ABORTED */\n      :\n      case 1\n      /* CANCELLED */\n      :\n      case 2\n      /* UNKNOWN */\n      :\n      case 4\n      /* DEADLINE_EXCEEDED */\n      :\n      case 13\n      /* INTERNAL */\n      :\n      case 14\n      /* UNAVAILABLE */\n      :\n      case 16\n      /* UNAUTHENTICATED */\n      :\n      case 8\n      /* RESOURCE_EXHAUSTED */\n      :\n        return true;\n\n      case 3\n      /* INVALID_ARGUMENT */\n      :\n        // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\n        // IDs that have expired. While INVALID_ARGUMENT is generally not\n        // retryable, we retry this specific case.\n        return !!error.message.match(/transaction has expired/);\n\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/@google-cloud/firestore/build/src/transaction.js"],"names":["Object","defineProperty","exports","value","backoff_1","require","logger_1","path_1","reference_1","util_1","validate_1","document_reader_1","READ_AFTER_WRITE_ERROR_MSG","Transaction","constructor","firestore","requestTag","_firestore","_writeBatch","batch","_requestTag","_backoff","ExponentialBackoff","get","refOrQuery","isEmpty","Error","DocumentReference","documentReader","DocumentReader","transactionId","_transactionId","then","res","Query","_get","getAll","documentRefsOrReadOptions","validateMinNumberOfArguments","documents","fieldMask","parseGetAllArguments","undefined","create","documentRef","data","set","options","update","dataOrField","preconditionOrValues","arguments","delete","precondition","begin","readOnly","readTime","_a","request","database","formattedName","toProto","timestampValue","readWrite","retryTransaction","resp","transaction","commit","_commit","rollback","runTransaction","updateFunction","result","lastError","attempt","maxAttempts","logger","_reset","maybeBackoff","promise","Promise","err","isRetryableTransactionError","reject","error","code","resetToMax","backoffAndWait","readOptions","Array","isArray","length","isPlainObject","pop","i","validateDocumentReference","validateReadOptions","optional","map","fieldPath","FieldPath","fromArgument","arg","validateOptional","isObject","invalidArgumentMessage","validateFieldPath","message","match"],"mappings":"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ACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,GAAG,CAACF,WAAD,EAAcC,IAAd,EAAoBE,OAApB,EAA6B;AAC5B,SAAK7B,WAAL,CAAiB4B,GAAjB,CAAqBF,WAArB,EAAkCC,IAAlC,EAAwCE,OAAxC;;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,MAAM,CAACJ,WAAD,EAAcK,WAAd,EAA2B,GAAGC,oBAA9B,EAAoD;AACtD;AACAxC,IAAAA,UAAU,CAAC4B,4BAAX,CAAwC,oBAAxC,EAA8Da,SAA9D,EAAyE,CAAzE;;AACA,SAAKjC,WAAL,CAAiB8B,MAAjB,CAAwBJ,WAAxB,EAAqCK,WAArC,EAAkD,GAAGC,oBAArD;;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,MAAM,CAACR,WAAD,EAAcS,YAAd,EAA4B;AAC9B,SAAKnC,WAAL,CAAiBkC,MAAjB,CAAwBR,WAAxB,EAAqCS,YAArC;;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,KAAK,CAACC,QAAD,EAAWC,QAAX,EAAqB;AACtB,QAAIC,EAAJ;;AACA,UAAMC,OAAO,GAAG;AACZC,MAAAA,QAAQ,EAAE,KAAK1C,UAAL,CAAgB2C;AADd,KAAhB;;AAGA,QAAIL,QAAJ,EAAc;AACVG,MAAAA,OAAO,CAACX,OAAR,GAAkB;AACdQ,QAAAA,QAAQ,EAAE;AACNC,U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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst backoff_1 = require(\"./backoff\");\r\nconst logger_1 = require(\"./logger\");\r\nconst path_1 = require(\"./path\");\r\nconst reference_1 = require(\"./reference\");\r\nconst util_1 = require(\"./util\");\r\nconst validate_1 = require(\"./validate\");\r\nconst document_reader_1 = require(\"./document-reader\");\r\n/*!\r\n * Error message for transactional reads that were executed after performing\r\n * writes.\r\n */\r\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The Transaction object passed to a transaction's updateFunction provides\r\n * the methods to read and write data within the transaction context. See\r\n * [runTransaction()]{@link Firestore#runTransaction}.\r\n *\r\n * @class Transaction\r\n */\r\nclass Transaction {\r\n    /**\r\n     * @hideconstructor\r\n     *\r\n     * @param firestore The Firestore Database client.\r\n     * @param requestTag A unique client-assigned identifier for the scope of\r\n     * this transaction.\r\n     */\r\n    constructor(firestore, requestTag) {\r\n        this._firestore = firestore;\r\n        this._writeBatch = firestore.batch();\r\n        this._requestTag = requestTag;\r\n        this._backoff = new backoff_1.ExponentialBackoff();\r\n    }\r\n    /**\r\n     * Retrieve a document or a query result from the database. Holds a\r\n     * pessimistic lock on all returned documents.\r\n     *\r\n     * @param {DocumentReference|Query} refOrQuery The document or query to\r\n     * return.\r\n     * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\r\n     * QuerySnapshot for the returned documents.\r\n     *\r\n     * @example\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   return transaction.get(documentRef).then(doc => {\r\n     *     if (doc.exists) {\r\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n     *     } else {\r\n     *       transaction.create(documentRef, { count: 1 });\r\n     *     }\r\n     *   });\r\n     * });\r\n     */\r\n    get(refOrQuery) {\r\n        if (!this._writeBatch.isEmpty) {\r\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\r\n        }\r\n        if (refOrQuery instanceof reference_1.DocumentReference) {\r\n            const documentReader = new document_reader_1.DocumentReader(this._firestore, [refOrQuery]);\r\n            documentReader.transactionId = this._transactionId;\r\n            return documentReader.get(this._requestTag).then(([res]) => res);\r\n        }\r\n        if (refOrQuery instanceof reference_1.Query) {\r\n            return refOrQuery._get(this._transactionId);\r\n        }\r\n        throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference or a Query.');\r\n    }\r\n    /**\r\n     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\r\n     * all returned documents.\r\n     *\r\n     * The first argument is required and must be of type `DocumentReference`\r\n     * followed by any additional `DocumentReference` documents. If used, the\r\n     * optional `ReadOptions` must be the last argument.\r\n     *\r\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\r\n     * `DocumentReferences` to receive, followed by an optional field mask.\r\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\r\n     * contains an array with the resulting document snapshots.\r\n     *\r\n     * @example\r\n     * let firstDoc = firestore.doc('col/doc1');\r\n     * let secondDoc = firestore.doc('col/doc2');\r\n     * let resultDoc = firestore.doc('col/doc3');\r\n     *\r\n     * firestore.runTransaction(transaction => {\r\n     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\r\n     *     transaction.set(resultDoc, {\r\n     *       sum: docs[0].get('count') + docs[1].get('count')\r\n     *     });\r\n     *   });\r\n     * });\r\n     */\r\n    getAll(...documentRefsOrReadOptions) {\r\n        if (!this._writeBatch.isEmpty) {\r\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\r\n        }\r\n        validate_1.validateMinNumberOfArguments('Transaction.getAll', documentRefsOrReadOptions, 1);\r\n        const { documents, fieldMask } = parseGetAllArguments(documentRefsOrReadOptions);\r\n        const documentReader = new document_reader_1.DocumentReader(this._firestore, documents);\r\n        documentReader.fieldMask = fieldMask || undefined;\r\n        documentReader.transactionId = this._transactionId;\r\n        return documentReader.get(this._requestTag);\r\n    }\r\n    /**\r\n     * Create the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. The operation will\r\n     * fail the transaction if a document exists at the specified location.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * created.\r\n     * @param {DocumentData} data The object data to serialize as the document.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   return transaction.get(documentRef).then(doc => {\r\n     *     if (!doc.exists) {\r\n     *       transaction.create(documentRef, { foo: 'bar' });\r\n     *     }\r\n     *   });\r\n     * });\r\n     */\r\n    create(documentRef, data) {\r\n        this._writeBatch.create(documentRef, data);\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes to the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document\r\n     * does not exist yet, it will be created. If you pass\r\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into the\r\n     * existing document.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * set.\r\n     * @param {T|Partial<T>} data The object to serialize as the document.\r\n     * @param {SetOptions=} options An object to configure the set behavior.\r\n     * @param {boolean=} options.merge - If true, set() merges the values\r\n     * specified in its data argument. Fields omitted from this set() call\r\n     * remain untouched.\r\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\r\n     * set() only replaces the specified field paths. Any field path that is not\r\n     * specified is ignored and remains untouched.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   transaction.set(documentRef, { foo: 'bar' });\r\n     *   return Promise.resolve();\r\n     * });\r\n     */\r\n    set(documentRef, data, options) {\r\n        this._writeBatch.set(documentRef, data, options);\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates fields in the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. The update will\r\n     * fail if applied to a document that does not exist.\r\n     *\r\n     * The update() method accepts either an object with field paths encoded as\r\n     * keys and field values encoded as values, or a variable number of arguments\r\n     * that alternate between field paths and field values. Nested fields can be\r\n     * updated by providing dot-separated field path strings or by providing\r\n     * FieldPath objects.\r\n     *\r\n     * A Precondition restricting this update can be specified as the last\r\n     * argument.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * updated.\r\n     * @param {UpdateData|string|FieldPath} dataOrField An object\r\n     * containing the fields and values with which to update the document\r\n     * or the path of the first field to update.\r\n     * @param {\r\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\r\n     * An alternating list of field paths and values to update or a Precondition\r\n     * to to enforce on this update.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   return transaction.get(documentRef).then(doc => {\r\n     *     if (doc.exists) {\r\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\r\n     *     } else {\r\n     *       transaction.create(documentRef, { count: 1 });\r\n     *     }\r\n     *   });\r\n     * });\r\n     */\r\n    update(documentRef, dataOrField, ...preconditionOrValues) {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        validate_1.validateMinNumberOfArguments('Transaction.update', arguments, 2);\r\n        this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided [DocumentReference]\r\n     * {@link DocumentReference}.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * deleted.\r\n     * @param {Precondition=} precondition A precondition to enforce for this\r\n     * delete.\r\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n     * document was last updated at lastUpdateTime. Fails the transaction if the\r\n     * document doesn't exist or was last updated at a different time.\r\n     * @param {boolean=} precondition.exists If set, enforces that the target\r\n     * document must or must not exist.\r\n     * @returns {Transaction} This Transaction instance. Used for\r\n     * chaining method calls.\r\n     *\r\n     * @example\r\n     * firestore.runTransaction(transaction => {\r\n     *   let documentRef = firestore.doc('col/doc');\r\n     *   transaction.delete(documentRef);\r\n     *   return Promise.resolve();\r\n     * });\r\n     */\r\n    delete(documentRef, precondition) {\r\n        this._writeBatch.delete(documentRef, precondition);\r\n        return this;\r\n    }\r\n    /**\r\n     * Starts a transaction and obtains the transaction id from the server.\r\n     *\r\n     * @private\r\n     */\r\n    begin(readOnly, readTime) {\r\n        var _a;\r\n        const request = {\r\n            database: this._firestore.formattedName,\r\n        };\r\n        if (readOnly) {\r\n            request.options = {\r\n                readOnly: {\r\n                    readTime: (_a = readTime === null || readTime === void 0 ? void 0 : readTime.toProto()) === null || _a === void 0 ? void 0 : _a.timestampValue,\r\n                },\r\n            };\r\n        }\r\n        else if (this._transactionId) {\r\n            request.options = {\r\n                readWrite: {\r\n                    retryTransaction: this._transactionId,\r\n                },\r\n            };\r\n        }\r\n        return this._firestore\r\n            .request('beginTransaction', request, this._requestTag)\r\n            .then(resp => {\r\n            this._transactionId = resp.transaction;\r\n        });\r\n    }\r\n    /**\r\n     * Commits all queued-up changes in this transaction and releases all locks.\r\n     *\r\n     * @private\r\n     */\r\n    commit() {\r\n        return this._writeBatch\r\n            ._commit({\r\n            transactionId: this._transactionId,\r\n            requestTag: this._requestTag,\r\n        })\r\n            .then(() => { });\r\n    }\r\n    /**\r\n     * Releases all locks and rolls back this transaction.\r\n     *\r\n     * @private\r\n     */\r\n    rollback() {\r\n        const request = {\r\n            database: this._firestore.formattedName,\r\n            transaction: this._transactionId,\r\n        };\r\n        return this._firestore.request('rollback', request, this._requestTag);\r\n    }\r\n    /**\r\n     * Executes `updateFunction()` and commits the transaction with retry.\r\n     *\r\n     * @private\r\n     * @param updateFunction The user function to execute within the transaction\r\n     * context.\r\n     * @param requestTag A unique client-assigned identifier for the scope of\r\n     * this transaction.\r\n     * @param options The user-defined options for this transaction.\r\n     */\r\n    async runTransaction(updateFunction, options) {\r\n        let result;\r\n        let lastError = undefined;\r\n        for (let attempt = 0; attempt < options.maxAttempts; ++attempt) {\r\n            try {\r\n                if (lastError) {\r\n                    logger_1.logger('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\r\n                    await this.rollback();\r\n                }\r\n                this._writeBatch._reset();\r\n                await this.maybeBackoff(lastError);\r\n                await this.begin(options.readOnly, options.readTime);\r\n                const promise = updateFunction(this);\r\n                if (!(promise instanceof Promise)) {\r\n                    throw new Error('You must return a Promise in your transaction()-callback.');\r\n                }\r\n                result = await promise;\r\n                await this.commit();\r\n                return result;\r\n            }\r\n            catch (err) {\r\n                logger_1.logger('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\r\n                lastError = err;\r\n                if (!this._transactionId || !isRetryableTransactionError(err)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        logger_1.logger('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\r\n        await this.rollback();\r\n        return Promise.reject(lastError);\r\n    }\r\n    /**\r\n     * Delays further operations based on the provided error.\r\n     *\r\n     * @private\r\n     * @return A Promise that resolves after the delay expired.\r\n     */\r\n    async maybeBackoff(error) {\r\n        if ((error === null || error === void 0 ? void 0 : error.code) === 8 /* RESOURCE_EXHAUSTED */) {\r\n            this._backoff.resetToMax();\r\n        }\r\n        await this._backoff.backoffAndWait();\r\n    }\r\n}\r\nexports.Transaction = Transaction;\r\n/**\r\n * Parses the arguments for the `getAll()` call supported by both the Firestore\r\n * and Transaction class.\r\n *\r\n * @private\r\n * @param documentRefsOrReadOptions An array of document references followed by\r\n * an optional ReadOptions object.\r\n */\r\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\r\n    let documents;\r\n    let readOptions = undefined;\r\n    if (Array.isArray(documentRefsOrReadOptions[0])) {\r\n        throw new Error('getAll() no longer accepts an array as its first argument. ' +\r\n            'Please unpack your array and call getAll() with individual arguments.');\r\n    }\r\n    if (documentRefsOrReadOptions.length > 0 &&\r\n        util_1.isPlainObject(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\r\n        readOptions = documentRefsOrReadOptions.pop();\r\n        documents = documentRefsOrReadOptions;\r\n    }\r\n    else {\r\n        documents = documentRefsOrReadOptions;\r\n    }\r\n    for (let i = 0; i < documents.length; ++i) {\r\n        reference_1.validateDocumentReference(i, documents[i]);\r\n    }\r\n    validateReadOptions('options', readOptions, { optional: true });\r\n    const fieldMask = readOptions && readOptions.fieldMask\r\n        ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath))\r\n        : null;\r\n    return { fieldMask, documents };\r\n}\r\nexports.parseGetAllArguments = parseGetAllArguments;\r\n/**\r\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\r\n * is an array of strings or field paths.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the ReadOptions can be omitted.\r\n */\r\nfunction validateReadOptions(arg, value, options) {\r\n    if (!validate_1.validateOptional(value, options)) {\r\n        if (!util_1.isObject(value)) {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} Input is not an object.'`);\r\n        }\r\n        const options = value;\r\n        if (options.fieldMask !== undefined) {\r\n            if (!Array.isArray(options.fieldMask)) {\r\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not an array.`);\r\n            }\r\n            for (let i = 0; i < options.fieldMask.length; ++i) {\r\n                try {\r\n                    path_1.validateFieldPath(i, options.fieldMask[i]);\r\n                }\r\n                catch (err) {\r\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction isRetryableTransactionError(error) {\r\n    if (error.code !== undefined) {\r\n        // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\r\n        switch (error.code) {\r\n            case 10 /* ABORTED */:\r\n            case 1 /* CANCELLED */:\r\n            case 2 /* UNKNOWN */:\r\n            case 4 /* DEADLINE_EXCEEDED */:\r\n            case 13 /* INTERNAL */:\r\n            case 14 /* UNAVAILABLE */:\r\n            case 16 /* UNAUTHENTICATED */:\r\n            case 8 /* RESOURCE_EXHAUSTED */:\r\n                return true;\r\n            case 3 /* INVALID_ARGUMENT */:\r\n                // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\r\n                // IDs that have expired. While INVALID_ARGUMENT is generally not\r\n                // retryable, we retry this specific case.\r\n                return !!error.message.match(/transaction has expired/);\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"script"}