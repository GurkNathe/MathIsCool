{"ast":null,"code":"/*! firebase-admin v9.10.0 */\n\"use strict\";\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useEmulator = exports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;\n\nvar validator = require(\"../utils/validator\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar identifier_1 = require(\"./identifier\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar user_import_builder_1 = require(\"./user-import-builder\");\n\nvar utils = require(\"../utils/index\");\n\nvar action_code_settings_builder_1 = require(\"./action-code-settings-builder\");\n\nvar auth_config_1 = require(\"./auth-config\");\n\nvar tenant_1 = require(\"./tenant\");\n/** Firebase Auth request header. */\n\n\nvar FIREBASE_AUTH_HEADER = {\n  'X-Client-Version': \"Node/Admin/\" + utils.getSdkVersion()\n};\n/** Firebase Auth request timeout duration in milliseconds. */\n\nvar FIREBASE_AUTH_TIMEOUT = 25000;\n/** List of reserved claims which cannot be provided when creating a custom token. */\n\nexports.RESERVED_CLAIMS = ['acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase'];\n/** List of supported email action request types. */\n\nexports.EMAIL_ACTION_REQUEST_TYPES = ['PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN'];\n/** Maximum allowed number of characters in the custom claims payload. */\n\nvar MAX_CLAIMS_PAYLOAD_SIZE = 1000;\n/** Maximum allowed number of users to batch download at one time. */\n\nvar MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\n/** Maximum allowed number of users to batch upload at one time. */\n\nvar MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\n/** Maximum allowed number of users to batch get at one time. */\n\nvar MAX_GET_ACCOUNTS_BATCH_SIZE = 100;\n/** Maximum allowed number of users to batch delete at one time. */\n\nvar MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1000;\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\n\nvar MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\n\nvar MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\n/** Maximum allowed number of provider configurations to batch download at one time. */\n\nvar MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\n/** The Firebase Auth backend base URL format. */\n\nvar FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** Firebase Auth base URlLformat when using the auth emultor. */\n\nvar FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = 'http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** The Firebase Auth backend multi-tenancy base URL format. */\n\nvar FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Firebase Auth base URL format when using the auth emultor with multi-tenancy. */\n\nvar FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Maximum allowed number of tenants to download at one time. */\n\nvar MAX_LIST_TENANT_PAGE_SIZE = 1000;\n/**\r\n * Enum for the user write operation type.\r\n */\n\nvar WriteOperationType;\n\n(function (WriteOperationType) {\n  WriteOperationType[\"Create\"] = \"create\";\n  WriteOperationType[\"Update\"] = \"update\";\n  WriteOperationType[\"Upload\"] = \"upload\";\n})(WriteOperationType || (WriteOperationType = {}));\n/** Defines a base utility to help with resource URL construction. */\n\n\nvar AuthResourceUrlBuilder =\n/** @class */\nfunction () {\n  /**\r\n   * The resource URL builder constructor.\r\n   *\r\n   * @param {string} projectId The resource project ID.\r\n   * @param {string} version The endpoint API version.\r\n   * @constructor\r\n   */\n  function AuthResourceUrlBuilder(app, version) {\n    if (version === void 0) {\n      version = 'v1';\n    }\n\n    this.app = app;\n    this.version = version;\n\n    if (useEmulator()) {\n      this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {\n        host: emulatorHost()\n      });\n    } else {\n      this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\n    }\n  }\n  /**\r\n   * Returns the resource URL corresponding to the provided parameters.\r\n   *\r\n   * @param {string=} api The backend API name.\r\n   * @param {object=} params The optional additional parameters to substitute in the\r\n   *     URL path.\r\n   * @return {Promise<string>} The corresponding resource URL.\r\n   */\n\n\n  AuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n    var _this = this;\n\n    return this.getProjectId().then(function (projectId) {\n      var baseParams = {\n        version: _this.version,\n        projectId: projectId,\n        api: api || ''\n      };\n      var baseUrl = utils.formatString(_this.urlFormat, baseParams); // Substitute additional api related parameters.\n\n      return utils.formatString(baseUrl, params || {});\n    });\n  };\n\n  AuthResourceUrlBuilder.prototype.getProjectId = function () {\n    var _this = this;\n\n    if (this.projectId) {\n      return Promise.resolve(this.projectId);\n    }\n\n    return utils.findProjectId(this.app).then(function (projectId) {\n      if (!validator.isNonEmptyString(projectId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Failed to determine project ID for Auth. Initialize the ' + 'SDK with service account credentials or set project ID as an app option. ' + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n      }\n\n      _this.projectId = projectId;\n      return projectId;\n    });\n  };\n\n  return AuthResourceUrlBuilder;\n}();\n/** Tenant aware resource builder utility. */\n\n\nvar TenantAwareAuthResourceUrlBuilder =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuthResourceUrlBuilder, _super);\n  /**\r\n   * The tenant aware resource URL builder constructor.\r\n   *\r\n   * @param {string} projectId The resource project ID.\r\n   * @param {string} version The endpoint API version.\r\n   * @param {string} tenantId The tenant ID.\r\n   * @constructor\r\n   */\n\n\n  function TenantAwareAuthResourceUrlBuilder(app, version, tenantId) {\n    var _this = _super.call(this, app, version) || this;\n\n    _this.app = app;\n    _this.version = version;\n    _this.tenantId = tenantId;\n\n    if (useEmulator()) {\n      _this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {\n        host: emulatorHost()\n      });\n    } else {\n      _this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\n    }\n\n    return _this;\n  }\n  /**\r\n   * Returns the resource URL corresponding to the provided parameters.\r\n   *\r\n   * @param {string=} api The backend API name.\r\n   * @param {object=} params The optional additional parameters to substitute in the\r\n   *     URL path.\r\n   * @return {Promise<string>} The corresponding resource URL.\r\n   */\n\n\n  TenantAwareAuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n    var _this = this;\n\n    return _super.prototype.getUrl.call(this, api, params).then(function (url) {\n      return utils.formatString(url, {\n        tenantId: _this.tenantId\n      });\n    });\n  };\n\n  return TenantAwareAuthResourceUrlBuilder;\n}(AuthResourceUrlBuilder);\n/**\r\n * Auth-specific HTTP client which uses the special \"owner\" token\r\n * when communicating with the Auth Emulator.\r\n */\n\n\nvar AuthHttpClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthHttpClient, _super);\n\n  function AuthHttpClient() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AuthHttpClient.prototype.getToken = function () {\n    if (useEmulator()) {\n      return Promise.resolve('owner');\n    }\n\n    return _super.prototype.getToken.call(this);\n  };\n\n  return AuthHttpClient;\n}(api_request_1.AuthorizedHttpClient);\n/**\r\n * Validates an AuthFactorInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request The AuthFactorInfo request object.\r\n */\n\n\nfunction validateAuthFactorInfo(request) {\n  var validKeys = {\n    mfaEnrollmentId: true,\n    displayName: true,\n    phoneInfo: true,\n    enrolledAt: true\n  }; // Remove unsupported keys from the original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  } // No enrollment ID is available for signupNewUser. Use another identifier.\n\n\n  var authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request); // Enrollment uid may or may not be specified for update operations.\n\n  if (typeof request.mfaEnrollmentId !== 'undefined' && !validator.isNonEmptyString(request.mfaEnrollmentId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor \"uid\" must be a valid non-empty string.');\n  }\n\n  if (typeof request.displayName !== 'undefined' && !validator.isString(request.displayName)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The second factor \\\"displayName\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid string.\");\n  } // enrolledAt must be a valid UTC date string.\n\n\n  if (typeof request.enrolledAt !== 'undefined' && !validator.isISODateString(request.enrolledAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid \" + 'UTC date string.');\n  } // Validate required fields depending on second factor type.\n\n\n  if (typeof request.phoneInfo !== 'undefined') {\n    // phoneNumber should be a string and a valid phone number.\n    if (!validator.isPhoneNumber(request.phoneInfo)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, \"The second factor \\\"phoneNumber\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a non-empty \" + 'E.164 standard compliant identifier string.');\n    }\n  } else {\n    // Invalid second factor. For example, a phone second factor may have been provided without\n    // a phone number. A TOTP based second factor may require a secret key, etc.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, 'MFAInfo object provided is invalid.');\n  }\n}\n/**\r\n * Validates a providerUserInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param {any} request The providerUserInfo request object.\r\n */\n\n\nfunction validateProviderUserInfo(request) {\n  var validKeys = {\n    rawId: true,\n    providerId: true,\n    email: true,\n    displayName: true,\n    photoUrl: true\n  }; // Remove invalid keys from original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n\n  if (!validator.isNonEmptyString(request.providerId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n  }\n\n  if (typeof request.displayName !== 'undefined' && typeof request.displayName !== 'string') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The provider \\\"displayName\\\" for \\\"\" + request.providerId + \"\\\" must be a valid string.\");\n  }\n\n  if (!validator.isNonEmptyString(request.rawId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, \"The provider \\\"uid\\\" for \\\"\" + request.providerId + \"\\\" must be a valid non-empty string.\");\n  } // email should be a string and a valid email.\n\n\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, \"The provider \\\"email\\\" for \\\"\" + request.providerId + \"\\\" must be a valid email string.\");\n  } // photoUrl should be a URL.\n\n\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, \"The provider \\\"photoURL\\\" for \\\"\" + request.providerId + \"\\\" must be a valid URL string.\");\n  }\n}\n/**\r\n * Validates a create/edit request object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request The create/edit request object.\r\n * @param writeOperationType The write operation type.\r\n */\n\n\nfunction validateCreateEditRequest(request, writeOperationType) {\n  var uploadAccountRequest = writeOperationType === WriteOperationType.Upload; // Hash set of whitelisted parameters.\n\n  var validKeys = {\n    displayName: true,\n    localId: true,\n    email: true,\n    password: true,\n    rawPassword: true,\n    emailVerified: true,\n    photoUrl: true,\n    disabled: true,\n    disableUser: true,\n    deleteAttribute: true,\n    deleteProvider: true,\n    sanityCheck: true,\n    phoneNumber: true,\n    customAttributes: true,\n    validSince: true,\n    // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)\n    linkProviderUserInfo: !uploadAccountRequest,\n    // Pass tenantId only for uploadAccount requests.\n    tenantId: uploadAccountRequest,\n    passwordHash: uploadAccountRequest,\n    salt: uploadAccountRequest,\n    createdAt: uploadAccountRequest,\n    lastLoginAt: uploadAccountRequest,\n    providerUserInfo: uploadAccountRequest,\n    mfaInfo: uploadAccountRequest,\n    // Only for non-uploadAccount requests.\n    mfa: !uploadAccountRequest\n  }; // Remove invalid keys from original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n\n  if (typeof request.tenantId !== 'undefined' && !validator.isNonEmptyString(request.tenantId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n  } // For any invalid parameter, use the external key name in the error description.\n  // displayName should be a string.\n\n\n  if (typeof request.displayName !== 'undefined' && !validator.isString(request.displayName)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\n  }\n\n  if ((typeof request.localId !== 'undefined' || uploadAccountRequest) && !validator.isUid(request.localId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n  } // email should be a string and a valid email.\n\n\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  } // phoneNumber should be a string and a valid phone number.\n\n\n  if (typeof request.phoneNumber !== 'undefined' && !validator.isPhoneNumber(request.phoneNumber)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n  } // password should be a string and a minimum of 6 chars.\n\n\n  if (typeof request.password !== 'undefined' && !validator.isPassword(request.password)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  } // rawPassword should be a string and a minimum of 6 chars.\n\n\n  if (typeof request.rawPassword !== 'undefined' && !validator.isPassword(request.rawPassword)) {\n    // This is called rawPassword on the backend but the developer specifies this as\n    // password externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  } // emailVerified should be a boolean.\n\n\n  if (typeof request.emailVerified !== 'undefined' && typeof request.emailVerified !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\n  } // photoUrl should be a URL.\n\n\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\n  } // disabled should be a boolean.\n\n\n  if (typeof request.disabled !== 'undefined' && typeof request.disabled !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  } // validSince should be a number.\n\n\n  if (typeof request.validSince !== 'undefined' && !validator.isNumber(request.validSince)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\n  } // createdAt should be a number.\n\n\n  if (typeof request.createdAt !== 'undefined' && !validator.isNumber(request.createdAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\n  } // lastSignInAt should be a number.\n\n\n  if (typeof request.lastLoginAt !== 'undefined' && !validator.isNumber(request.lastLoginAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\n  } // disableUser should be a boolean.\n\n\n  if (typeof request.disableUser !== 'undefined' && typeof request.disableUser !== 'boolean') {\n    // This is called disableUser on the backend but the developer specifies this as\n    // disabled externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  } // customAttributes should be stringified JSON with no blacklisted claims.\n  // The payload should not exceed 1KB.\n\n\n  if (typeof request.customAttributes !== 'undefined') {\n    var developerClaims_1;\n\n    try {\n      developerClaims_1 = JSON.parse(request.customAttributes);\n    } catch (error) {\n      // JSON parsing error. This should never happen as we stringify the claims internally.\n      // However, we still need to check since setAccountInfo via edit requests could pass\n      // this field.\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\n    }\n\n    var invalidClaims_1 = []; // Check for any invalid claims.\n\n    exports.RESERVED_CLAIMS.forEach(function (blacklistedClaim) {\n      if (Object.prototype.hasOwnProperty.call(developerClaims_1, blacklistedClaim)) {\n        invalidClaims_1.push(blacklistedClaim);\n      }\n    }); // Throw an error if an invalid claim is detected.\n\n    if (invalidClaims_1.length > 0) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims_1.length > 1 ? \"Developer claims \\\"\" + invalidClaims_1.join('\", \"') + \"\\\" are reserved and cannot be specified.\" : \"Developer claim \\\"\" + invalidClaims_1[0] + \"\\\" is reserved and cannot be specified.\");\n    } // Check claims payload does not exceed maxmimum size.\n\n\n    if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, \"Developer claims payload should not exceed \" + MAX_CLAIMS_PAYLOAD_SIZE + \" characters.\");\n    }\n  } // passwordHash has to be a base64 encoded string.\n\n\n  if (typeof request.passwordHash !== 'undefined' && !validator.isString(request.passwordHash)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n  } // salt has to be a base64 encoded string.\n\n\n  if (typeof request.salt !== 'undefined' && !validator.isString(request.salt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n  } // providerUserInfo has to be an array of valid UserInfo requests.\n\n\n  if (typeof request.providerUserInfo !== 'undefined' && !validator.isArray(request.providerUserInfo)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\n  } else if (validator.isArray(request.providerUserInfo)) {\n    request.providerUserInfo.forEach(function (providerUserInfoEntry) {\n      validateProviderUserInfo(providerUserInfoEntry);\n    });\n  } // linkProviderUserInfo must be a (single) UserProvider value.\n\n\n  if (typeof request.linkProviderUserInfo !== 'undefined') {\n    validateProviderUserInfo(request.linkProviderUserInfo);\n  } // mfaInfo is used for importUsers.\n  // mfa.enrollments is used for setAccountInfo.\n  // enrollments has to be an array of valid AuthFactorInfo requests.\n\n\n  var enrollments = null;\n\n  if (request.mfaInfo) {\n    enrollments = request.mfaInfo;\n  } else if (request.mfa && request.mfa.enrollments) {\n    enrollments = request.mfa.enrollments;\n  }\n\n  if (enrollments) {\n    if (!validator.isArray(enrollments)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);\n    }\n\n    enrollments.forEach(function (authFactorInfoEntry) {\n      validateAuthFactorInfo(authFactorInfoEntry);\n    });\n  }\n}\n/** Instantiates the createSessionCookie endpoint settings. */\n\n\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate the ID token is a non-empty string.\n  if (!validator.isNonEmptyString(request.idToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\n  } // Validate the custom session cookie duration.\n\n\n  if (!validator.isNumber(request.validDuration) || request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS || request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the session cookie.\n  if (!validator.isNonEmptyString(response.sessionCookie)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\n  }\n});\n/** Instantiates the uploadAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\n/** Instantiates the downloadAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.nextPageToken !== 'undefined' && !validator.isNonEmptyString(request.nextPageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.maxResults) || request.maxResults <= 0 || request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + (MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the getAccountInfo endpoint settings. */\n\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  if (!response.users || !response.users.length) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/**\r\n * Instantiates the getAccountInfo endpoint settings for use when fetching info\r\n * for multiple accounts.\r\n */\n\nexports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n});\n/** Instantiates the deleteAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n});\nexports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings('/accounts:batchDelete', 'POST').setRequestValidator(function (request) {\n  if (!request.localIds) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifiers');\n  }\n\n  if (typeof request.force === 'undefined' || request.force !== true) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing force=true field');\n  }\n}).setResponseValidator(function (response) {\n  var errors = response.errors || [];\n  errors.forEach(function (batchDeleteErrorInfo) {\n    if (typeof batchDeleteErrorInfo.index === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field');\n    }\n\n    if (!batchDeleteErrorInfo.localId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field');\n    } // Allow the (error) message to be missing/undef.\n\n  });\n});\n/** Instantiates the setAccountInfo endpoint settings for updating existing accounts. */\n\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // localId is a required parameter.\n  if (typeof request.localId === 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  } // Throw error when tenantId is passed in POST body.\n\n\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\n  }\n\n  validateCreateEditRequest(request, WriteOperationType.Update);\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/**\r\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\r\n * uid being specified. The backend will create a new one if not provided and return it.\r\n */\n\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // signupNewUser does not support customAttributes.\n  if (typeof request.customAttributes !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"customAttributes\" cannot be set when creating a new user.');\n  } // signupNewUser does not support validSince.\n\n\n  if (typeof request.validSince !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"validSince\" cannot be set when creating a new user.');\n  } // Throw error when tenantId is passed in POST body.\n\n\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\n  }\n\n  validateCreateEditRequest(request, WriteOperationType.Create);\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\n  }\n});\nvar FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  }\n\n  if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + request.requestType + \"\\\" is not a supported email action request type.\");\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the oobLink is not returned, then the request failed.\n  if (!response.oobLink) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\n  }\n});\n/** Instantiates the retrieve OIDC configuration endpoint settings. */\n\nvar GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\n  }\n});\n/** Instantiates the delete OIDC configuration endpoint settings. */\n\nvar DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\n/** Instantiates the create OIDC configuration endpoint settings. */\n\nvar CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\n  }\n});\n/** Instantiates the update OIDC configuration endpoint settings. */\n\nvar UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\n  }\n});\n/** Instantiates the list OIDC configuration endpoint settings. */\n\nvar LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the retrieve SAML configuration endpoint settings. */\n\nvar GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\n  }\n});\n/** Instantiates the delete SAML configuration endpoint settings. */\n\nvar DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\n/** Instantiates the create SAML configuration endpoint settings. */\n\nvar CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\n  }\n});\n/** Instantiates the update SAML configuration endpoint settings. */\n\nvar UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\n  }\n});\n/** Instantiates the list SAML configuration endpoint settings. */\n\nvar LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' + (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n  }\n});\n/**\r\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\r\n */\n\nvar AbstractAuthRequestHandler =\n/** @class */\nfunction () {\n  /**\r\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\r\n   * @constructor\r\n   */\n  function AbstractAuthRequestHandler(app) {\n    this.app = app;\n\n    if (typeof app !== 'object' || app === null || !('options' in app)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\n    }\n\n    this.httpClient = new AuthHttpClient(app);\n  }\n  /**\r\n   * @param {any} response The response to check for errors.\r\n   * @return {string|null} The error code if present; null otherwise.\r\n   */\n\n\n  AbstractAuthRequestHandler.getErrorCode = function (response) {\n    return validator.isNonNullObject(response) && response.error && response.error.message || null;\n  };\n\n  AbstractAuthRequestHandler.addUidToRequest = function (id, request) {\n    if (!validator.isUid(id.uid)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n    }\n\n    request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];\n    return request;\n  };\n\n  AbstractAuthRequestHandler.addEmailToRequest = function (id, request) {\n    if (!validator.isEmail(id.email)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n    }\n\n    request.email ? request.email.push(id.email) : request.email = [id.email];\n    return request;\n  };\n\n  AbstractAuthRequestHandler.addPhoneToRequest = function (id, request) {\n    if (!validator.isPhoneNumber(id.phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n    }\n\n    request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];\n    return request;\n  };\n\n  AbstractAuthRequestHandler.addProviderToRequest = function (id, request) {\n    if (!validator.isNonEmptyString(id.providerId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n\n    if (!validator.isNonEmptyString(id.providerUid)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);\n    }\n\n    var federatedUserId = {\n      providerId: id.providerId,\n      rawId: id.providerUid\n    };\n    request.federatedUserId ? request.federatedUserId.push(federatedUserId) : request.federatedUserId = [federatedUserId];\n    return request;\n  };\n  /**\r\n   * Creates a new Firebase session cookie with the specified duration that can be used for\r\n   * session management (set as a server side session cookie with custom cookie policy).\r\n   * The session cookie JWT will have the same payload claims as the provided ID token.\r\n   *\r\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\r\n   * @param {number} expiresIn The session cookie duration in milliseconds.\r\n   *\r\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createSessionCookie = function (idToken, expiresIn) {\n    var request = {\n      idToken: idToken,\n      // Convert to seconds.\n      validDuration: expiresIn / 1000\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request).then(function (response) {\n      return response.sessionCookie;\n    });\n  };\n  /**\r\n   * Looks up a user by uid.\r\n   *\r\n   * @param {string} uid The uid of the user to lookup.\r\n   * @return {Promise<object>} A promise that resolves with the user information.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByUid = function (uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: [uid]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\r\n   * Looks up a user by email.\r\n   *\r\n   * @param {string} email The email of the user to lookup.\r\n   * @return {Promise<object>} A promise that resolves with the user information.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByEmail = function (email) {\n    if (!validator.isEmail(email)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\n    }\n\n    var request = {\n      email: [email]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\r\n   * Looks up a user by phone number.\r\n   *\r\n   * @param {string} phoneNumber The phone number of the user to lookup.\r\n   * @return {Promise<object>} A promise that resolves with the user information.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByPhoneNumber = function (phoneNumber) {\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\n    }\n\n    var request = {\n      phoneNumber: [phoneNumber]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByFederatedUid = function (providerId, rawId) {\n    if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n\n    var request = {\n      federatedUserId: [{\n        providerId: providerId,\n        rawId: rawId\n      }]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\r\n   * Looks up multiple users by their identifiers (uid, email, etc).\r\n   *\r\n   * @param {UserIdentifier[]} identifiers The identifiers indicating the users\r\n   *     to be looked up. Must have <= 100 entries.\r\n   * @param {Promise<object>} A promise that resolves with the set of successfully\r\n   *     looked up users. Possibly empty if no users were looked up.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByIdentifiers = function (identifiers) {\n    if (identifiers.length === 0) {\n      return Promise.resolve({\n        users: []\n      });\n    } else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`identifiers` parameter must have <= ' + MAX_GET_ACCOUNTS_BATCH_SIZE + ' entries.');\n    }\n\n    var request = {};\n\n    for (var _i = 0, identifiers_1 = identifiers; _i < identifiers_1.length; _i++) {\n      var id = identifiers_1[_i];\n\n      if (identifier_1.isUidIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addUidToRequest(id, request);\n      } else if (identifier_1.isEmailIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addEmailToRequest(id, request);\n      } else if (identifier_1.isPhoneIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addPhoneToRequest(id, request);\n      } else if (identifier_1.isProviderIdentifier(id)) {\n        request = AbstractAuthRequestHandler.addProviderToRequest(id, request);\n      } else {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Unrecognized identifier: ' + id);\n      }\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);\n  };\n  /**\r\n   * Exports the users (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param {string=} pageToken The next page token. If not specified, returns users starting\r\n   *     without any offset. Users are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n   *     users and the next page token if available. For the last page, an empty list of users\r\n   *     and no page token are returned.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.downloadAccount = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE;\n    } // Construct request.\n\n\n    var request = {\n      maxResults: maxResults,\n      nextPageToken: pageToken\n    }; // Remove next page token if not provided.\n\n    if (typeof request.nextPageToken === 'undefined') {\n      delete request.nextPageToken;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request).then(function (response) {\n      // No more users available.\n      if (!response.users) {\n        response.users = [];\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Imports the list of users provided to Firebase Auth. This is useful when\r\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n   * At most, 1000 users are allowed to be imported one at a time.\r\n   * When importing a list of password users, UserImportOptions are required to be specified.\r\n   *\r\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\r\n   * @param {UserImportOptions=} options The user import options, required when the users provided\r\n   *     include password credentials.\r\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\r\n   *     with the result of the import. This includes the number of successful imports, the number\r\n   *     of failed uploads and their corresponding errors.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n    // This will throw if any error is detected in the hash options.\n    // For errors in the list of users, this will not throw and will report the errors and the\n    // corresponding user index in the user import generated response below.\n    // No need to validate raw request or raw response as this is done in UserImportBuilder.\n    var userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, function (userRequest) {\n      // Pass true to validate the uploadAccount specific fields.\n      validateCreateEditRequest(userRequest, WriteOperationType.Upload);\n    });\n    var request = userImportBuilder.buildRequest(); // Fail quickly if more users than allowed are to be imported.\n\n    if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, \"A maximum of \" + MAX_UPLOAD_ACCOUNT_BATCH_SIZE + \" users can be imported at once.\");\n    } // If no remaining user in request after client side processing, there is no need\n    // to send the request to the server.\n\n\n    if (!request.users || request.users.length === 0) {\n      return Promise.resolve(userImportBuilder.buildResponse([]));\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request).then(function (response) {\n      // No error object is returned if no error encountered.\n      var failedUploads = response.error || []; // Rewrite response as UserImportResult and re-insert client previously detected errors.\n\n      return userImportBuilder.buildResponse(failedUploads);\n    });\n  };\n  /**\r\n   * Deletes an account identified by a uid.\r\n   *\r\n   * @param {string} uid The uid of the user to delete.\r\n   * @return {Promise<object>} A promise that resolves when the user is deleted.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteAccount = function (uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: uid\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\n  };\n\n  AbstractAuthRequestHandler.prototype.deleteAccounts = function (uids, force) {\n    if (uids.length === 0) {\n      return Promise.resolve({});\n    } else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`uids` parameter must have <= ' + MAX_DELETE_ACCOUNTS_BATCH_SIZE + ' entries.');\n    }\n\n    var request = {\n      localIds: [],\n      force: force\n    };\n    uids.forEach(function (uid) {\n      if (!validator.isUid(uid)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n      }\n\n      request.localIds.push(uid);\n    });\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);\n  };\n  /**\r\n   * Sets additional developer claims on an existing user identified by provided UID.\r\n   *\r\n   * @param {string} uid The user to edit.\r\n   * @param {object} customUserClaims The developer claims to set.\r\n   * @return {Promise<string>} A promise that resolves when the operation completes\r\n   *     with the user id that was edited.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isObject(customUserClaims)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\n    } // Delete operation. Replace null with an empty object.\n\n\n    if (customUserClaims === null) {\n      customUserClaims = {};\n    } // Construct custom user attribute editting request.\n\n\n    var request = {\n      localId: uid,\n      customAttributes: JSON.stringify(customUserClaims)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\r\n   * Edits an existing user.\r\n   *\r\n   * @param {string} uid The user to edit.\r\n   * @param {object} properties The properties to set on the user.\r\n   * @return {Promise<string>} A promise that resolves when the operation completes\r\n   *     with the user id that was edited.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateExistingAccount = function (uid, properties) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    } else if (validator.isNonNullObject(properties.providerToLink)) {\n      // TODO(rsgowman): These checks overlap somewhat with\n      // validateProviderUserInfo. It may be possible to refactor a bit.\n      if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.providerId of properties argument must be a non-empty string.');\n      }\n\n      if (!validator.isNonEmptyString(properties.providerToLink.uid)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.uid of properties argument must be a non-empty string.');\n      }\n    } else if (typeof properties.providersToUnlink !== 'undefined') {\n      if (!validator.isArray(properties.providersToUnlink)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\n      }\n\n      properties.providersToUnlink.forEach(function (providerId) {\n        if (!validator.isNonEmptyString(providerId)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\n        }\n      });\n    } // Build the setAccountInfo request.\n\n\n    var request = deep_copy_1.deepCopy(properties);\n    request.localId = uid; // For deleting displayName or photoURL, these values must be passed as null.\n    // They will be removed from the backend request and an additional parameter\n    // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\n    // with an array of the parameter names to delete will be passed.\n    // Parameters that are deletable and their deleteAttribute names.\n    // Use client facing names, photoURL instead of photoUrl.\n\n    var deletableParams = {\n      displayName: 'DISPLAY_NAME',\n      photoURL: 'PHOTO_URL'\n    }; // Properties to delete if available.\n\n    request.deleteAttribute = [];\n\n    for (var key in deletableParams) {\n      if (request[key] === null) {\n        // Add property identifier to list of attributes to delete.\n        request.deleteAttribute.push(deletableParams[key]); // Remove property from request.\n\n        delete request[key];\n      }\n    }\n\n    if (request.deleteAttribute.length === 0) {\n      delete request.deleteAttribute;\n    } // For deleting phoneNumber, this value must be passed as null.\n    // It will be removed from the backend request and an additional parameter\n    // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\n    // will be passed.\n\n\n    if (request.phoneNumber === null) {\n      request.deleteProvider ? request.deleteProvider.push('phone') : request.deleteProvider = ['phone'];\n      delete request.phoneNumber;\n    }\n\n    if (typeof request.providerToLink !== 'undefined') {\n      request.linkProviderUserInfo = deep_copy_1.deepCopy(request.providerToLink);\n      delete request.providerToLink;\n      request.linkProviderUserInfo.rawId = request.linkProviderUserInfo.uid;\n      delete request.linkProviderUserInfo.uid;\n    }\n\n    if (typeof request.providersToUnlink !== 'undefined') {\n      if (!validator.isArray(request.deleteProvider)) {\n        request.deleteProvider = [];\n      }\n\n      request.deleteProvider = request.deleteProvider.concat(request.providersToUnlink);\n      delete request.providersToUnlink;\n    } // Rewrite photoURL to photoUrl.\n\n\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    } // Rewrite disabled to disableUser.\n\n\n    if (typeof request.disabled !== 'undefined') {\n      request.disableUser = request.disabled;\n      delete request.disabled;\n    } // Construct mfa related user data.\n\n\n    if (validator.isNonNullObject(request.multiFactor)) {\n      if (request.multiFactor.enrolledFactors === null) {\n        // Remove all second factors.\n        request.mfa = {};\n      } else if (validator.isArray(request.multiFactor.enrolledFactors)) {\n        request.mfa = {\n          enrollments: []\n        };\n\n        try {\n          request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n            request.mfa.enrollments.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n\n        if (request.mfa.enrollments.length === 0) {\n          delete request.mfa.enrollments;\n        }\n      }\n\n      delete request.multiFactor;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\r\n   * Revokes all refresh tokens for the specified user identified by the uid provided.\r\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued\r\n   * before revocation will also be revoked on the Auth backend. Any request with an\r\n   * ID token generated before revocation will be rejected with a token expired error.\r\n   * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\r\n   * the same second as the revocation will still be valid. If there is a chance that a token\r\n   * was minted in the last second, delay for 1 second before revoking.\r\n   *\r\n   * @param {string} uid The user whose tokens are to be revoked.\r\n   * @return {Promise<string>} A promise that resolves when the operation completes\r\n   *     successfully with the user id of the corresponding user.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.revokeRefreshTokens = function (uid) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: uid,\n      // validSince is in UTC seconds.\n      validSince: Math.floor(new Date().getTime() / 1000)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\r\n   * Create a new user with the properties supplied.\r\n   *\r\n   * @param {object} properties The properties to set on the user.\r\n   * @return {Promise<string>} A promise that resolves when the operation completes\r\n   *     with the user id that was created.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createNewAccount = function (properties) {\n    if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    }\n\n    var request = deep_copy_1.deepCopy(properties); // Rewrite photoURL to photoUrl.\n\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    } // Rewrite uid to localId if it exists.\n\n\n    if (typeof request.uid !== 'undefined') {\n      request.localId = request.uid;\n      delete request.uid;\n    } // Construct mfa related user data.\n\n\n    if (validator.isNonNullObject(request.multiFactor)) {\n      if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {\n        var mfaInfo_1 = [];\n\n        try {\n          request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n            // Enrollment time and uid are not allowed for signupNewUser endpoint.\n            // They will automatically be provisioned server side.\n            if ('enrollmentTime' in multiFactorInfo) {\n              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"enrollmentTime\" is not supported when adding second factors via \"createUser()\"');\n            } else if ('uid' in multiFactorInfo) {\n              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"uid\" is not supported when adding second factors via \"createUser()\"');\n            }\n\n            mfaInfo_1.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n\n        request.mfaInfo = mfaInfo_1;\n      }\n\n      delete request.multiFactor;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request).then(function (response) {\n      // Return the user id.\n      return response.localId;\n    });\n  };\n  /**\r\n   * Generates the out of band email action link for the email specified using the action code settings provided.\r\n   * Returns a promise that resolves with the generated link.\r\n   *\r\n   * @param {string} requestType The request type. This could be either used for password reset,\r\n   *     email verification, email link sign-in.\r\n   * @param {string} email The email of the user the link is being sent to.\r\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\r\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n   *     deep link, etc. Required when requestType == 'EMAIL_SIGNIN'\r\n   * @return {Promise<string>} A promise that resolves with the email action link.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getEmailActionLink = function (requestType, email, actionCodeSettings) {\n    var request = {\n      requestType: requestType,\n      email: email,\n      returnOobLink: true\n    }; // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\n    // be completed.\n\n    if (typeof actionCodeSettings === 'undefined' && requestType === 'EMAIL_SIGNIN') {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'\"));\n    }\n\n    if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\n      try {\n        var builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\n        request = deep_copy_1.deepExtend(request, builder.buildRequest());\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request).then(function (response) {\n      // Return the link.\n      return response.oobLink;\n    });\n  };\n  /**\r\n   * Looks up an OIDC provider configuration by provider ID.\r\n   *\r\n   * @param {string} providerId The provider identifier of the configuration to lookup.\r\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the provider configuration information.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getOAuthIdpConfig = function (providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, {\n      providerId: providerId\n    });\n  };\n  /**\r\n   * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param {string=} pageToken The next page token. If not specified, returns OIDC configurations\r\n   *     without any offset. Configurations are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n   *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\r\n   *     configuration and no page token are returned.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.listOAuthIdpConfigs = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults\n    }; // Add next page token if provided.\n\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request).then(function (response) {\n      if (!response.oauthIdpConfigs) {\n        response.oauthIdpConfigs = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Deletes an OIDC configuration identified by a providerId.\r\n   *\r\n   * @param {string} providerId The identifier of the OIDC configuration to delete.\r\n   * @return {Promise<void>} A promise that resolves when the OIDC provider is deleted.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteOAuthIdpConfig = function (providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, {\n      providerId: providerId\n    }).then(function () {// Return nothing.\n    });\n  };\n  /**\r\n   * Creates a new OIDC provider configuration with the properties provided.\r\n   *\r\n   * @param {AuthProviderConfig} options The properties to set on the new OIDC provider configuration to be created.\r\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the newly created OIDC\r\n   *     configuration.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createOAuthIdpConfig = function (options) {\n    // Construct backend request.\n    var request;\n\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, {\n      providerId: providerId\n    }).then(function (response) {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Updates an existing OIDC provider configuration with the properties provided.\r\n   *\r\n   * @param {string} providerId The provider identifier of the OIDC configuration to update.\r\n   * @param {OIDCUpdateAuthProviderRequest} options The properties to update on the existing configuration.\r\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the modified provider\r\n   *     configuration.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateOAuthIdpConfig = function (providerId, options) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    } // Construct backend request.\n\n\n    var request;\n\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, {\n      providerId: providerId,\n      updateMask: updateMask.join(',')\n    }).then(function (response) {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Looks up an SAML provider configuration by provider ID.\r\n   *\r\n   * @param {string} providerId The provider identifier of the configuration to lookup.\r\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the provider configuration information.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getInboundSamlConfig = function (providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, {\n      providerId: providerId\n    });\n  };\n  /**\r\n   * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param {string=} pageToken The next page token. If not specified, returns SAML configurations starting\r\n   *     without any offset. Configurations are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n   *     SAML configurations and the next page token if available. For the last page, an empty list of provider\r\n   *     configuration and no page token are returned.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.listInboundSamlConfigs = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults\n    }; // Add next page token if provided.\n\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request).then(function (response) {\n      if (!response.inboundSamlConfigs) {\n        response.inboundSamlConfigs = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Deletes a SAML configuration identified by a providerId.\r\n   *\r\n   * @param {string} providerId The identifier of the SAML configuration to delete.\r\n   * @return {Promise<void>} A promise that resolves when the SAML provider is deleted.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteInboundSamlConfig = function (providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, {\n      providerId: providerId\n    }).then(function () {// Return nothing.\n    });\n  };\n  /**\r\n   * Creates a new SAML provider configuration with the properties provided.\r\n   *\r\n   * @param {AuthProviderConfig} options The properties to set on the new SAML provider configuration to be created.\r\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the newly created SAML\r\n   *     configuration.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createInboundSamlConfig = function (options) {\n    // Construct backend request.\n    var request;\n\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, {\n      providerId: providerId\n    }).then(function (response) {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Updates an existing SAML provider configuration with the properties provided.\r\n   *\r\n   * @param {string} providerId The provider identifier of the SAML configuration to update.\r\n   * @param {SAMLUpdateAuthProviderRequest} options The properties to update on the existing configuration.\r\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the modified provider\r\n   *     configuration.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateInboundSamlConfig = function (providerId, options) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    } // Construct backend request.\n\n\n    var request;\n\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, {\n      providerId: providerId,\n      updateMask: updateMask.join(',')\n    }).then(function (response) {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Invokes the request handler based on the API settings object passed.\r\n   *\r\n   * @param {AuthResourceUrlBuilder} urlBuilder The URL builder for Auth endpoints.\r\n   * @param {ApiSettings} apiSettings The API endpoint settings to apply to request and response.\r\n   * @param {object} requestData The request data.\r\n   * @param {object=} additionalResourceParams Additional resource related params if needed.\r\n   * @return {Promise<object>} A promise that resolves with the response.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.invokeRequestHandler = function (urlBuilder, apiSettings, requestData, additionalResourceParams) {\n    var _this = this;\n\n    return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams).then(function (url) {\n      // Validate request.\n      var requestValidator = apiSettings.getRequestValidator();\n      requestValidator(requestData); // Process request.\n\n      var req = {\n        method: apiSettings.getHttpMethod(),\n        url: url,\n        headers: FIREBASE_AUTH_HEADER,\n        data: requestData,\n        timeout: FIREBASE_AUTH_TIMEOUT\n      };\n      return _this.httpClient.send(req);\n    }).then(function (response) {\n      // Validate response.\n      var responseValidator = apiSettings.getResponseValidator();\n      responseValidator(response.data); // Return entire response.\n\n      return response.data;\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        var error = err.response.data;\n        var errorCode = AbstractAuthRequestHandler.getErrorCode(error);\n\n        if (!errorCode) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' + 'internal error occurred while attempting to extract the ' + 'errorcode from the error.');\n        }\n\n        throw error_1.FirebaseAuthError.fromServerError(errorCode,\n        /* message */\n        undefined, error);\n      }\n\n      throw err;\n    });\n  };\n  /**\r\n   * @return {AuthResourceUrlBuilder} The current Auth user management resource URL builder.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAuthUrlBuilder = function () {\n    if (!this.authUrlBuilder) {\n      this.authUrlBuilder = this.newAuthUrlBuilder();\n    }\n\n    return this.authUrlBuilder;\n  };\n  /**\r\n   * @return {AuthResourceUrlBuilder} The current project config resource URL builder.\r\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getProjectConfigUrlBuilder = function () {\n    if (!this.projectConfigUrlBuilder) {\n      this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\n    }\n\n    return this.projectConfigUrlBuilder;\n  };\n\n  return AbstractAuthRequestHandler;\n}();\n\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\n/** Instantiates the getTenant endpoint settings. */\n\nvar GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\n  }\n});\n/** Instantiates the deleteTenant endpoint settings. */\n\nvar DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\n/** Instantiates the updateTenant endpoint settings. */\n\nvar UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\n  }\n});\n/** Instantiates the listTenants endpoint settings. */\n\nvar LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive non-zero number that does not exceed ' + (\"the allowed \" + MAX_LIST_TENANT_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the createTenant endpoint settings. */\n\nvar CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\n  }\n});\n/**\r\n * Utility for sending requests to Auth server that are Auth instance related. This includes user and\r\n * tenant management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\r\n * additional tenant management related APIs.\r\n */\n\nvar AuthRequestHandler =\n/** @class */\nfunction (_super) {\n  __extends(AuthRequestHandler, _super);\n  /**\r\n   * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\r\n   *\r\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\r\n   * @constructor.\r\n   */\n\n\n  function AuthRequestHandler(app) {\n    var _this = _super.call(this, app) || this;\n\n    _this.tenantMgmtResourceBuilder = new AuthResourceUrlBuilder(app, 'v2');\n    return _this;\n  }\n  /**\r\n   * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\r\n   */\n\n\n  AuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n    return new AuthResourceUrlBuilder(this.app, 'v1');\n  };\n  /**\r\n   * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\r\n   */\n\n\n  AuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n    return new AuthResourceUrlBuilder(this.app, 'v2');\n  };\n  /**\r\n   * Looks up a tenant by tenant ID.\r\n   *\r\n   * @param {string} tenantId The tenant identifier of the tenant to lookup.\r\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the tenant information.\r\n   */\n\n\n  AuthRequestHandler.prototype.getTenant = function (tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, GET_TENANT, {}, {\n      tenantId: tenantId\n    }).then(function (response) {\n      return response;\n    });\n  };\n  /**\r\n   * Exports the tenants (single batch only) with a size of maxResults and starting from\r\n   * the offset as specified by pageToken.\r\n   *\r\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param {string=} pageToken The next page token. If not specified, returns tenants starting\r\n   *     without any offset. Tenants are returned in the order they were created from oldest to\r\n   *     newest, relative to the page token offset.\r\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n   *     tenants and the next page token if available. For the last page, an empty list of tenants\r\n   *     and no page token are returned.\r\n   */\n\n\n  AuthRequestHandler.prototype.listTenants = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_TENANT_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults,\n      pageToken: pageToken\n    }; // Remove next page token if not provided.\n\n    if (typeof request.pageToken === 'undefined') {\n      delete request.pageToken;\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, LIST_TENANTS, request).then(function (response) {\n      if (!response.tenants) {\n        response.tenants = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\r\n   * Deletes a tenant identified by a tenantId.\r\n   *\r\n   * @param {string} tenantId The identifier of the tenant to delete.\r\n   * @return {Promise<void>} A promise that resolves when the tenant is deleted.\r\n   */\n\n\n  AuthRequestHandler.prototype.deleteTenant = function (tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, DELETE_TENANT, {}, {\n      tenantId: tenantId\n    }).then(function () {// Return nothing.\n    });\n  };\n  /**\r\n   * Creates a new tenant with the properties provided.\r\n   *\r\n   * @param {TenantOptions} tenantOptions The properties to set on the new tenant to be created.\r\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the newly created tenant object.\r\n   */\n\n\n  AuthRequestHandler.prototype.createTenant = function (tenantOptions) {\n    try {\n      // Construct backend request.\n      var request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\n      return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, CREATE_TENANT, request).then(function (response) {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  /**\r\n   * Updates an existing tenant with the properties provided.\r\n   *\r\n   * @param {string} tenantId The tenant identifier of the tenant to update.\r\n   * @param {TenantOptions} tenantOptions The properties to update on the existing tenant.\r\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the modified tenant object.\r\n   */\n\n\n  AuthRequestHandler.prototype.updateTenant = function (tenantId, tenantOptions) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    try {\n      // Construct backend request.\n      var request = tenant_1.Tenant.buildServerRequest(tenantOptions, false); // Do not traverse deep into testPhoneNumbers. The entire content should be replaced\n      // and not just specific phone numbers.\n\n      var updateMask = utils.generateUpdateMask(request, ['testPhoneNumbers']);\n      return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, UPDATE_TENANT, request, {\n        tenantId: tenantId,\n        updateMask: updateMask.join(',')\n      }).then(function (response) {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return AuthRequestHandler;\n}(AbstractAuthRequestHandler);\n\nexports.AuthRequestHandler = AuthRequestHandler;\n/**\r\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\r\n * management related APIs for specified tenants.\r\n * This extends the BaseFirebaseAuthRequestHandler class.\r\n */\n\nvar TenantAwareAuthRequestHandler =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuthRequestHandler, _super);\n  /**\r\n   * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\r\n   * FirebaseApp and a tenant ID.\r\n   *\r\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\r\n   * @param {string} tenantId The request handler's tenant ID.\r\n   * @constructor\r\n   */\n\n\n  function TenantAwareAuthRequestHandler(app, tenantId) {\n    var _this = _super.call(this, app) || this;\n\n    _this.tenantId = tenantId;\n    return _this;\n  }\n  /**\r\n   * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\r\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n    return new TenantAwareAuthResourceUrlBuilder(this.app, 'v1', this.tenantId);\n  };\n  /**\r\n   * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\r\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n    return new TenantAwareAuthResourceUrlBuilder(this.app, 'v2', this.tenantId);\n  };\n  /**\r\n   * Imports the list of users provided to Firebase Auth. This is useful when\r\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n   * At most, 1000 users are allowed to be imported one at a time.\r\n   * When importing a list of password users, UserImportOptions are required to be specified.\r\n   *\r\n   * Overrides the superclass methods by adding an additional check to match tenant IDs of\r\n   * imported user records if present.\r\n   *\r\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\r\n   * @param {UserImportOptions=} options The user import options, required when the users provided\r\n   *     include password credentials.\r\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\r\n   *     with the result of the import. This includes the number of successful imports, the number\r\n   *     of failed uploads and their corresponding errors.\r\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n    var _this = this; // Add additional check to match tenant ID of imported user records.\n\n\n    users.forEach(function (user, index) {\n      if (validator.isNonEmptyString(user.tenantId) && user.tenantId !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, \"UserRecord of index \\\"\" + index + \"\\\" has mismatching tenant ID \\\"\" + user.tenantId + \"\\\"\");\n      }\n    });\n    return _super.prototype.uploadAccount.call(this, users, options);\n  };\n\n  return TenantAwareAuthRequestHandler;\n}(AbstractAuthRequestHandler);\n\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;\n\nfunction emulatorHost() {\n  return process.env.FIREBASE_AUTH_EMULATOR_HOST;\n}\n/**\r\n * When true the SDK should communicate with the Auth Emulator for all API\r\n * calls and also produce unsigned tokens.\r\n */\n\n\nfunction useEmulator() {\n  return !!emulatorHost();\n}\n\nexports.useEmulator = useEmulator;","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/firebase-admin/lib/auth/auth-api-request.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","useEmulator","TenantAwareAuthRequestHandler","AuthRequestHandler","AbstractAuthRequestHandler","FIREBASE_AUTH_SIGN_UP_NEW_USER","FIREBASE_AUTH_SET_ACCOUNT_INFO","FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS","FIREBASE_AUTH_DELETE_ACCOUNT","FIREBASE_AUTH_GET_ACCOUNTS_INFO","FIREBASE_AUTH_GET_ACCOUNT_INFO","FIREBASE_AUTH_DOWNLOAD_ACCOUNT","FIREBASE_AUTH_UPLOAD_ACCOUNT","FIREBASE_AUTH_CREATE_SESSION_COOKIE","EMAIL_ACTION_REQUEST_TYPES","RESERVED_CLAIMS","validator","require","deep_copy_1","identifier_1","error_1","api_request_1","user_import_builder_1","utils","action_code_settings_builder_1","auth_config_1","tenant_1","FIREBASE_AUTH_HEADER","getSdkVersion","FIREBASE_AUTH_TIMEOUT","MAX_CLAIMS_PAYLOAD_SIZE","MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE","MAX_UPLOAD_ACCOUNT_BATCH_SIZE","MAX_GET_ACCOUNTS_BATCH_SIZE","MAX_DELETE_ACCOUNTS_BATCH_SIZE","MIN_SESSION_COOKIE_DURATION_SECS","MAX_SESSION_COOKIE_DURATION_SECS","MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE","FIREBASE_AUTH_BASE_URL_FORMAT","FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT","FIREBASE_AUTH_TENANT_URL_FORMAT","replace","FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT","MAX_LIST_TENANT_PAGE_SIZE","WriteOperationType","AuthResourceUrlBuilder","app","version","urlFormat","formatString","host","emulatorHost","getUrl","api","params","_this","getProjectId","then","projectId","baseParams","baseUrl","Promise","resolve","findProjectId","isNonEmptyString","FirebaseAuthError","AuthClientErrorCode","INVALID_CREDENTIAL","TenantAwareAuthResourceUrlBuilder","_super","tenantId","call","url","AuthHttpClient","apply","arguments","getToken","AuthorizedHttpClient","validateAuthFactorInfo","request","validKeys","mfaEnrollmentId","displayName","phoneInfo","enrolledAt","key","authFactorInfoIdentifier","JSON","stringify","INVALID_UID","isString","INVALID_DISPLAY_NAME","isISODateString","INVALID_ENROLLMENT_TIME","isPhoneNumber","INVALID_PHONE_NUMBER","INVALID_ENROLLED_FACTORS","validateProviderUserInfo","rawId","providerId","email","photoUrl","INVALID_PROVIDER_ID","isEmail","INVALID_EMAIL","isURL","INVALID_PHOTO_URL","validateCreateEditRequest","writeOperationType","uploadAccountRequest","Upload","localId","password","rawPassword","emailVerified","disabled","disableUser","deleteAttribute","deleteProvider","sanityCheck","phoneNumber","customAttributes","validSince","linkProviderUserInfo","passwordHash","salt","createdAt","lastLoginAt","providerUserInfo","mfaInfo","mfa","INVALID_TENANT_ID","isUid","isPassword","INVALID_PASSWORD","INVALID_EMAIL_VERIFIED","INVALID_DISABLED_FIELD","isNumber","INVALID_TOKENS_VALID_AFTER_TIME","INVALID_CREATION_TIME","INVALID_LAST_SIGN_IN_TIME","developerClaims_1","parse","error","INVALID_CLAIMS","message","invalidClaims_1","forEach","blacklistedClaim","push","length","FORBIDDEN_CLAIM","join","CLAIMS_TOO_LARGE","INVALID_PASSWORD_HASH","INVALID_PASSWORD_SALT","isArray","INVALID_PROVIDER_DATA","providerUserInfoEntry","enrollments","authFactorInfoEntry","ApiSettings","setRequestValidator","idToken","INVALID_ID_TOKEN","validDuration","INVALID_SESSION_COOKIE_DURATION","setResponseValidator","response","sessionCookie","INTERNAL_ERROR","nextPageToken","INVALID_PAGE_TOKEN","maxResults","INVALID_ARGUMENT","federatedUserId","users","USER_NOT_FOUND","localIds","force","errors","batchDeleteErrorInfo","index","Update","Create","FIREBASE_AUTH_GET_OOB_CODE","indexOf","requestType","oobLink","GET_OAUTH_IDP_CONFIG","name","DELETE_OAUTH_IDP_CONFIG","CREATE_OAUTH_IDP_CONFIG","UPDATE_OAUTH_IDP_CONFIG","LIST_OAUTH_IDP_CONFIGS","pageToken","pageSize","GET_INBOUND_SAML_CONFIG","DELETE_INBOUND_SAML_CONFIG","CREATE_INBOUND_SAML_CONFIG","UPDATE_INBOUND_SAML_CONFIG","LIST_INBOUND_SAML_CONFIGS","httpClient","getErrorCode","isNonNullObject","addUidToRequest","id","uid","addEmailToRequest","addPhoneToRequest","addProviderToRequest","providerUid","INVALID_PROVIDER_UID","createSessionCookie","expiresIn","invokeRequestHandler","getAuthUrlBuilder","getAccountInfoByUid","reject","getAccountInfoByEmail","getAccountInfoByPhoneNumber","getAccountInfoByFederatedUid","getAccountInfoByIdentifiers","identifiers","MAXIMUM_USER_COUNT_EXCEEDED","_i","identifiers_1","isUidIdentifier","isEmailIdentifier","isPhoneIdentifier","isProviderIdentifier","downloadAccount","uploadAccount","options","userImportBuilder","UserImportBuilder","userRequest","buildRequest","buildResponse","failedUploads","deleteAccount","deleteAccounts","uids","setCustomUserClaims","customUserClaims","isObject","updateExistingAccount","properties","providerToLink","providersToUnlink","deepCopy","deletableParams","photoURL","concat","multiFactor","enrolledFactors","multiFactorInfo","convertMultiFactorInfoToServerFormat","e","revokeRefreshTokens","Math","floor","Date","getTime","createNewAccount","isNonEmptyArray","mfaInfo_1","getEmailActionLink","actionCodeSettings","returnOobLink","builder","ActionCodeSettingsBuilder","deepExtend","getOAuthIdpConfig","OIDCConfig","isProviderId","getProjectConfigUrlBuilder","listOAuthIdpConfigs","oauthIdpConfigs","deleteOAuthIdpConfig","createOAuthIdpConfig","buildServerRequest","getProviderIdFromResourceName","updateOAuthIdpConfig","updateMask","generateUpdateMask","getInboundSamlConfig","SAMLConfig","listInboundSamlConfigs","inboundSamlConfigs","deleteInboundSamlConfig","createInboundSamlConfig","updateInboundSamlConfig","urlBuilder","apiSettings","requestData","additionalResourceParams","getEndpoint","requestValidator","getRequestValidator","req","method","getHttpMethod","headers","data","timeout","send","responseValidator","getResponseValidator","catch","err","HttpError","errorCode","fromServerError","undefined","authUrlBuilder","newAuthUrlBuilder","projectConfigUrlBuilder","newProjectConfigUrlBuilder","GET_TENANT","DELETE_TENANT","UPDATE_TENANT","Tenant","getTenantIdFromResourceName","LIST_TENANTS","CREATE_TENANT","tenantMgmtResourceBuilder","getTenant","listTenants","tenants","deleteTenant","createTenant","tenantOptions","updateTenant","user","MISMATCHING_TENANT_ID","process","env","FIREBASE_AUTH_EMULATOR_HOST"],"mappings":"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","sourcesContent":["/*! firebase-admin v9.10.0 */\r\n\"use strict\";\r\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.useEmulator = exports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;\r\nvar validator = require(\"../utils/validator\");\r\nvar deep_copy_1 = require(\"../utils/deep-copy\");\r\nvar identifier_1 = require(\"./identifier\");\r\nvar error_1 = require(\"../utils/error\");\r\nvar api_request_1 = require(\"../utils/api-request\");\r\nvar user_import_builder_1 = require(\"./user-import-builder\");\r\nvar utils = require(\"../utils/index\");\r\nvar action_code_settings_builder_1 = require(\"./action-code-settings-builder\");\r\nvar auth_config_1 = require(\"./auth-config\");\r\nvar tenant_1 = require(\"./tenant\");\r\n/** Firebase Auth request header. */\r\nvar FIREBASE_AUTH_HEADER = {\r\n    'X-Client-Version': \"Node/Admin/\" + utils.getSdkVersion(),\r\n};\r\n/** Firebase Auth request timeout duration in milliseconds. */\r\nvar FIREBASE_AUTH_TIMEOUT = 25000;\r\n/** List of reserved claims which cannot be provided when creating a custom token. */\r\nexports.RESERVED_CLAIMS = [\r\n    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat',\r\n    'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase',\r\n];\r\n/** List of supported email action request types. */\r\nexports.EMAIL_ACTION_REQUEST_TYPES = [\r\n    'PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN',\r\n];\r\n/** Maximum allowed number of characters in the custom claims payload. */\r\nvar MAX_CLAIMS_PAYLOAD_SIZE = 1000;\r\n/** Maximum allowed number of users to batch download at one time. */\r\nvar MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\r\n/** Maximum allowed number of users to batch upload at one time. */\r\nvar MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\r\n/** Maximum allowed number of users to batch get at one time. */\r\nvar MAX_GET_ACCOUNTS_BATCH_SIZE = 100;\r\n/** Maximum allowed number of users to batch delete at one time. */\r\nvar MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1000;\r\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\r\nvar MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\r\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\r\nvar MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\r\n/** Maximum allowed number of provider configurations to batch download at one time. */\r\nvar MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\r\n/** The Firebase Auth backend base URL format. */\r\nvar FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\r\n/** Firebase Auth base URlLformat when using the auth emultor. */\r\nvar FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = 'http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\r\n/** The Firebase Auth backend multi-tenancy base URL format. */\r\nvar FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\r\n/** Firebase Auth base URL format when using the auth emultor with multi-tenancy. */\r\nvar FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\r\n/** Maximum allowed number of tenants to download at one time. */\r\nvar MAX_LIST_TENANT_PAGE_SIZE = 1000;\r\n/**\r\n * Enum for the user write operation type.\r\n */\r\nvar WriteOperationType;\r\n(function (WriteOperationType) {\r\n    WriteOperationType[\"Create\"] = \"create\";\r\n    WriteOperationType[\"Update\"] = \"update\";\r\n    WriteOperationType[\"Upload\"] = \"upload\";\r\n})(WriteOperationType || (WriteOperationType = {}));\r\n/** Defines a base utility to help with resource URL construction. */\r\nvar AuthResourceUrlBuilder = /** @class */ (function () {\r\n    /**\r\n     * The resource URL builder constructor.\r\n     *\r\n     * @param {string} projectId The resource project ID.\r\n     * @param {string} version The endpoint API version.\r\n     * @constructor\r\n     */\r\n    function AuthResourceUrlBuilder(app, version) {\r\n        if (version === void 0) { version = 'v1'; }\r\n        this.app = app;\r\n        this.version = version;\r\n        if (useEmulator()) {\r\n            this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {\r\n                host: emulatorHost()\r\n            });\r\n        }\r\n        else {\r\n            this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the resource URL corresponding to the provided parameters.\r\n     *\r\n     * @param {string=} api The backend API name.\r\n     * @param {object=} params The optional additional parameters to substitute in the\r\n     *     URL path.\r\n     * @return {Promise<string>} The corresponding resource URL.\r\n     */\r\n    AuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\r\n        var _this = this;\r\n        return this.getProjectId()\r\n            .then(function (projectId) {\r\n            var baseParams = {\r\n                version: _this.version,\r\n                projectId: projectId,\r\n                api: api || '',\r\n            };\r\n            var baseUrl = utils.formatString(_this.urlFormat, baseParams);\r\n            // Substitute additional api related parameters.\r\n            return utils.formatString(baseUrl, params || {});\r\n        });\r\n    };\r\n    AuthResourceUrlBuilder.prototype.getProjectId = function () {\r\n        var _this = this;\r\n        if (this.projectId) {\r\n            return Promise.resolve(this.projectId);\r\n        }\r\n        return utils.findProjectId(this.app)\r\n            .then(function (projectId) {\r\n            if (!validator.isNonEmptyString(projectId)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Failed to determine project ID for Auth. Initialize the '\r\n                    + 'SDK with service account credentials or set project ID as an app option. '\r\n                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\r\n            }\r\n            _this.projectId = projectId;\r\n            return projectId;\r\n        });\r\n    };\r\n    return AuthResourceUrlBuilder;\r\n}());\r\n/** Tenant aware resource builder utility. */\r\nvar TenantAwareAuthResourceUrlBuilder = /** @class */ (function (_super) {\r\n    __extends(TenantAwareAuthResourceUrlBuilder, _super);\r\n    /**\r\n     * The tenant aware resource URL builder constructor.\r\n     *\r\n     * @param {string} projectId The resource project ID.\r\n     * @param {string} version The endpoint API version.\r\n     * @param {string} tenantId The tenant ID.\r\n     * @constructor\r\n     */\r\n    function TenantAwareAuthResourceUrlBuilder(app, version, tenantId) {\r\n        var _this = _super.call(this, app, version) || this;\r\n        _this.app = app;\r\n        _this.version = version;\r\n        _this.tenantId = tenantId;\r\n        if (useEmulator()) {\r\n            _this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {\r\n                host: emulatorHost()\r\n            });\r\n        }\r\n        else {\r\n            _this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns the resource URL corresponding to the provided parameters.\r\n     *\r\n     * @param {string=} api The backend API name.\r\n     * @param {object=} params The optional additional parameters to substitute in the\r\n     *     URL path.\r\n     * @return {Promise<string>} The corresponding resource URL.\r\n     */\r\n    TenantAwareAuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\r\n        var _this = this;\r\n        return _super.prototype.getUrl.call(this, api, params)\r\n            .then(function (url) {\r\n            return utils.formatString(url, { tenantId: _this.tenantId });\r\n        });\r\n    };\r\n    return TenantAwareAuthResourceUrlBuilder;\r\n}(AuthResourceUrlBuilder));\r\n/**\r\n * Auth-specific HTTP client which uses the special \"owner\" token\r\n * when communicating with the Auth Emulator.\r\n */\r\nvar AuthHttpClient = /** @class */ (function (_super) {\r\n    __extends(AuthHttpClient, _super);\r\n    function AuthHttpClient() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    AuthHttpClient.prototype.getToken = function () {\r\n        if (useEmulator()) {\r\n            return Promise.resolve('owner');\r\n        }\r\n        return _super.prototype.getToken.call(this);\r\n    };\r\n    return AuthHttpClient;\r\n}(api_request_1.AuthorizedHttpClient));\r\n/**\r\n * Validates an AuthFactorInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request The AuthFactorInfo request object.\r\n */\r\nfunction validateAuthFactorInfo(request) {\r\n    var validKeys = {\r\n        mfaEnrollmentId: true,\r\n        displayName: true,\r\n        phoneInfo: true,\r\n        enrolledAt: true,\r\n    };\r\n    // Remove unsupported keys from the original request.\r\n    for (var key in request) {\r\n        if (!(key in validKeys)) {\r\n            delete request[key];\r\n        }\r\n    }\r\n    // No enrollment ID is available for signupNewUser. Use another identifier.\r\n    var authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request);\r\n    // Enrollment uid may or may not be specified for update operations.\r\n    if (typeof request.mfaEnrollmentId !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.mfaEnrollmentId)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor \"uid\" must be a valid non-empty string.');\r\n    }\r\n    if (typeof request.displayName !== 'undefined' &&\r\n        !validator.isString(request.displayName)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The second factor \\\"displayName\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid string.\");\r\n    }\r\n    // enrolledAt must be a valid UTC date string.\r\n    if (typeof request.enrolledAt !== 'undefined' &&\r\n        !validator.isISODateString(request.enrolledAt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid \" +\r\n            'UTC date string.');\r\n    }\r\n    // Validate required fields depending on second factor type.\r\n    if (typeof request.phoneInfo !== 'undefined') {\r\n        // phoneNumber should be a string and a valid phone number.\r\n        if (!validator.isPhoneNumber(request.phoneInfo)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, \"The second factor \\\"phoneNumber\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a non-empty \" +\r\n                'E.164 standard compliant identifier string.');\r\n        }\r\n    }\r\n    else {\r\n        // Invalid second factor. For example, a phone second factor may have been provided without\r\n        // a phone number. A TOTP based second factor may require a secret key, etc.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, 'MFAInfo object provided is invalid.');\r\n    }\r\n}\r\n/**\r\n * Validates a providerUserInfo object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param {any} request The providerUserInfo request object.\r\n */\r\nfunction validateProviderUserInfo(request) {\r\n    var validKeys = {\r\n        rawId: true,\r\n        providerId: true,\r\n        email: true,\r\n        displayName: true,\r\n        photoUrl: true,\r\n    };\r\n    // Remove invalid keys from original request.\r\n    for (var key in request) {\r\n        if (!(key in validKeys)) {\r\n            delete request[key];\r\n        }\r\n    }\r\n    if (!validator.isNonEmptyString(request.providerId)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\r\n    }\r\n    if (typeof request.displayName !== 'undefined' &&\r\n        typeof request.displayName !== 'string') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The provider \\\"displayName\\\" for \\\"\" + request.providerId + \"\\\" must be a valid string.\");\r\n    }\r\n    if (!validator.isNonEmptyString(request.rawId)) {\r\n        // This is called localId on the backend but the developer specifies this as\r\n        // uid externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, \"The provider \\\"uid\\\" for \\\"\" + request.providerId + \"\\\" must be a valid non-empty string.\");\r\n    }\r\n    // email should be a string and a valid email.\r\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, \"The provider \\\"email\\\" for \\\"\" + request.providerId + \"\\\" must be a valid email string.\");\r\n    }\r\n    // photoUrl should be a URL.\r\n    if (typeof request.photoUrl !== 'undefined' &&\r\n        !validator.isURL(request.photoUrl)) {\r\n        // This is called photoUrl on the backend but the developer specifies this as\r\n        // photoURL externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, \"The provider \\\"photoURL\\\" for \\\"\" + request.providerId + \"\\\" must be a valid URL string.\");\r\n    }\r\n}\r\n/**\r\n * Validates a create/edit request object. All unsupported parameters\r\n * are removed from the original request. If an invalid field is passed\r\n * an error is thrown.\r\n *\r\n * @param request The create/edit request object.\r\n * @param writeOperationType The write operation type.\r\n */\r\nfunction validateCreateEditRequest(request, writeOperationType) {\r\n    var uploadAccountRequest = writeOperationType === WriteOperationType.Upload;\r\n    // Hash set of whitelisted parameters.\r\n    var validKeys = {\r\n        displayName: true,\r\n        localId: true,\r\n        email: true,\r\n        password: true,\r\n        rawPassword: true,\r\n        emailVerified: true,\r\n        photoUrl: true,\r\n        disabled: true,\r\n        disableUser: true,\r\n        deleteAttribute: true,\r\n        deleteProvider: true,\r\n        sanityCheck: true,\r\n        phoneNumber: true,\r\n        customAttributes: true,\r\n        validSince: true,\r\n        // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)\r\n        linkProviderUserInfo: !uploadAccountRequest,\r\n        // Pass tenantId only for uploadAccount requests.\r\n        tenantId: uploadAccountRequest,\r\n        passwordHash: uploadAccountRequest,\r\n        salt: uploadAccountRequest,\r\n        createdAt: uploadAccountRequest,\r\n        lastLoginAt: uploadAccountRequest,\r\n        providerUserInfo: uploadAccountRequest,\r\n        mfaInfo: uploadAccountRequest,\r\n        // Only for non-uploadAccount requests.\r\n        mfa: !uploadAccountRequest,\r\n    };\r\n    // Remove invalid keys from original request.\r\n    for (var key in request) {\r\n        if (!(key in validKeys)) {\r\n            delete request[key];\r\n        }\r\n    }\r\n    if (typeof request.tenantId !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.tenantId)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\r\n    }\r\n    // For any invalid parameter, use the external key name in the error description.\r\n    // displayName should be a string.\r\n    if (typeof request.displayName !== 'undefined' &&\r\n        !validator.isString(request.displayName)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\r\n    }\r\n    if ((typeof request.localId !== 'undefined' || uploadAccountRequest) &&\r\n        !validator.isUid(request.localId)) {\r\n        // This is called localId on the backend but the developer specifies this as\r\n        // uid externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\r\n    }\r\n    // email should be a string and a valid email.\r\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\r\n    }\r\n    // phoneNumber should be a string and a valid phone number.\r\n    if (typeof request.phoneNumber !== 'undefined' &&\r\n        !validator.isPhoneNumber(request.phoneNumber)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\r\n    }\r\n    // password should be a string and a minimum of 6 chars.\r\n    if (typeof request.password !== 'undefined' &&\r\n        !validator.isPassword(request.password)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\r\n    }\r\n    // rawPassword should be a string and a minimum of 6 chars.\r\n    if (typeof request.rawPassword !== 'undefined' &&\r\n        !validator.isPassword(request.rawPassword)) {\r\n        // This is called rawPassword on the backend but the developer specifies this as\r\n        // password externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\r\n    }\r\n    // emailVerified should be a boolean.\r\n    if (typeof request.emailVerified !== 'undefined' &&\r\n        typeof request.emailVerified !== 'boolean') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\r\n    }\r\n    // photoUrl should be a URL.\r\n    if (typeof request.photoUrl !== 'undefined' &&\r\n        !validator.isURL(request.photoUrl)) {\r\n        // This is called photoUrl on the backend but the developer specifies this as\r\n        // photoURL externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\r\n    }\r\n    // disabled should be a boolean.\r\n    if (typeof request.disabled !== 'undefined' &&\r\n        typeof request.disabled !== 'boolean') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\r\n    }\r\n    // validSince should be a number.\r\n    if (typeof request.validSince !== 'undefined' &&\r\n        !validator.isNumber(request.validSince)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\r\n    }\r\n    // createdAt should be a number.\r\n    if (typeof request.createdAt !== 'undefined' &&\r\n        !validator.isNumber(request.createdAt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\r\n    }\r\n    // lastSignInAt should be a number.\r\n    if (typeof request.lastLoginAt !== 'undefined' &&\r\n        !validator.isNumber(request.lastLoginAt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\r\n    }\r\n    // disableUser should be a boolean.\r\n    if (typeof request.disableUser !== 'undefined' &&\r\n        typeof request.disableUser !== 'boolean') {\r\n        // This is called disableUser on the backend but the developer specifies this as\r\n        // disabled externally. So the error message should use the client facing name.\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\r\n    }\r\n    // customAttributes should be stringified JSON with no blacklisted claims.\r\n    // The payload should not exceed 1KB.\r\n    if (typeof request.customAttributes !== 'undefined') {\r\n        var developerClaims_1;\r\n        try {\r\n            developerClaims_1 = JSON.parse(request.customAttributes);\r\n        }\r\n        catch (error) {\r\n            // JSON parsing error. This should never happen as we stringify the claims internally.\r\n            // However, we still need to check since setAccountInfo via edit requests could pass\r\n            // this field.\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\r\n        }\r\n        var invalidClaims_1 = [];\r\n        // Check for any invalid claims.\r\n        exports.RESERVED_CLAIMS.forEach(function (blacklistedClaim) {\r\n            if (Object.prototype.hasOwnProperty.call(developerClaims_1, blacklistedClaim)) {\r\n                invalidClaims_1.push(blacklistedClaim);\r\n            }\r\n        });\r\n        // Throw an error if an invalid claim is detected.\r\n        if (invalidClaims_1.length > 0) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims_1.length > 1 ?\r\n                \"Developer claims \\\"\" + invalidClaims_1.join('\", \"') + \"\\\" are reserved and cannot be specified.\" :\r\n                \"Developer claim \\\"\" + invalidClaims_1[0] + \"\\\" is reserved and cannot be specified.\");\r\n        }\r\n        // Check claims payload does not exceed maxmimum size.\r\n        if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, \"Developer claims payload should not exceed \" + MAX_CLAIMS_PAYLOAD_SIZE + \" characters.\");\r\n        }\r\n    }\r\n    // passwordHash has to be a base64 encoded string.\r\n    if (typeof request.passwordHash !== 'undefined' &&\r\n        !validator.isString(request.passwordHash)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\r\n    }\r\n    // salt has to be a base64 encoded string.\r\n    if (typeof request.salt !== 'undefined' &&\r\n        !validator.isString(request.salt)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\r\n    }\r\n    // providerUserInfo has to be an array of valid UserInfo requests.\r\n    if (typeof request.providerUserInfo !== 'undefined' &&\r\n        !validator.isArray(request.providerUserInfo)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\r\n    }\r\n    else if (validator.isArray(request.providerUserInfo)) {\r\n        request.providerUserInfo.forEach(function (providerUserInfoEntry) {\r\n            validateProviderUserInfo(providerUserInfoEntry);\r\n        });\r\n    }\r\n    // linkProviderUserInfo must be a (single) UserProvider value.\r\n    if (typeof request.linkProviderUserInfo !== 'undefined') {\r\n        validateProviderUserInfo(request.linkProviderUserInfo);\r\n    }\r\n    // mfaInfo is used for importUsers.\r\n    // mfa.enrollments is used for setAccountInfo.\r\n    // enrollments has to be an array of valid AuthFactorInfo requests.\r\n    var enrollments = null;\r\n    if (request.mfaInfo) {\r\n        enrollments = request.mfaInfo;\r\n    }\r\n    else if (request.mfa && request.mfa.enrollments) {\r\n        enrollments = request.mfa.enrollments;\r\n    }\r\n    if (enrollments) {\r\n        if (!validator.isArray(enrollments)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);\r\n        }\r\n        enrollments.forEach(function (authFactorInfoEntry) {\r\n            validateAuthFactorInfo(authFactorInfoEntry);\r\n        });\r\n    }\r\n}\r\n/** Instantiates the createSessionCookie endpoint settings. */\r\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    // Validate the ID token is a non-empty string.\r\n    if (!validator.isNonEmptyString(request.idToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\r\n    }\r\n    // Validate the custom session cookie duration.\r\n    if (!validator.isNumber(request.validDuration) ||\r\n        request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS ||\r\n        request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\r\n    }\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain the session cookie.\r\n    if (!validator.isNonEmptyString(response.sessionCookie)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\r\n    }\r\n});\r\n/** Instantiates the uploadAccount endpoint settings. */\r\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\r\n/** Instantiates the downloadAccount endpoint settings. */\r\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    // Validate next page token.\r\n    if (typeof request.nextPageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.nextPageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.maxResults) ||\r\n        request.maxResults <= 0 ||\r\n        request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' +\r\n            (MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE + \".\"));\r\n    }\r\n});\r\n/** Instantiates the getAccountInfo endpoint settings. */\r\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    if (!response.users || !response.users.length) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\r\n    }\r\n});\r\n/**\r\n * Instantiates the getAccountInfo endpoint settings for use when fetching info\r\n * for multiple accounts.\r\n */\r\nexports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n});\r\n/** Instantiates the deleteAccount endpoint settings. */\r\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    if (!request.localId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n});\r\nexports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings('/accounts:batchDelete', 'POST')\r\n    .setRequestValidator(function (request) {\r\n    if (!request.localIds) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifiers');\r\n    }\r\n    if (typeof request.force === 'undefined' || request.force !== true) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing force=true field');\r\n    }\r\n})\r\n    .setResponseValidator(function (response) {\r\n    var errors = response.errors || [];\r\n    errors.forEach(function (batchDeleteErrorInfo) {\r\n        if (typeof batchDeleteErrorInfo.index === 'undefined') {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field');\r\n        }\r\n        if (!batchDeleteErrorInfo.localId) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field');\r\n        }\r\n        // Allow the (error) message to be missing/undef.\r\n    });\r\n});\r\n/** Instantiates the setAccountInfo endpoint settings for updating existing accounts. */\r\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    // localId is a required parameter.\r\n    if (typeof request.localId === 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\r\n    }\r\n    // Throw error when tenantId is passed in POST body.\r\n    if (typeof request.tenantId !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\r\n    }\r\n    validateCreateEditRequest(request, WriteOperationType.Update);\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // If the localId is not returned, then the request failed.\r\n    if (!response.localId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\r\n    }\r\n});\r\n/**\r\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\r\n * uid being specified. The backend will create a new one if not provided and return it.\r\n */\r\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    // signupNewUser does not support customAttributes.\r\n    if (typeof request.customAttributes !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"customAttributes\" cannot be set when creating a new user.');\r\n    }\r\n    // signupNewUser does not support validSince.\r\n    if (typeof request.validSince !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"validSince\" cannot be set when creating a new user.');\r\n    }\r\n    // Throw error when tenantId is passed in POST body.\r\n    if (typeof request.tenantId !== 'undefined') {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\r\n    }\r\n    validateCreateEditRequest(request, WriteOperationType.Create);\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // If the localId is not returned, then the request failed.\r\n    if (!response.localId) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\r\n    }\r\n});\r\nvar FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    if (!validator.isEmail(request.email)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\r\n    }\r\n    if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + request.requestType + \"\\\" is not a supported email action request type.\");\r\n    }\r\n})\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // If the oobLink is not returned, then the request failed.\r\n    if (!response.oobLink) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\r\n    }\r\n});\r\n/** Instantiates the retrieve OIDC configuration endpoint settings. */\r\nvar GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain the OIDC provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\r\n    }\r\n});\r\n/** Instantiates the delete OIDC configuration endpoint settings. */\r\nvar DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\r\n/** Instantiates the create OIDC configuration endpoint settings. */\r\nvar CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain the OIDC provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\r\n    }\r\n});\r\n/** Instantiates the update OIDC configuration endpoint settings. */\r\nvar UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain the configuration resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\r\n    }\r\n});\r\n/** Instantiates the list OIDC configuration endpoint settings. */\r\nvar LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    // Validate next page token.\r\n    if (typeof request.pageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.pageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.pageSize) ||\r\n        request.pageSize <= 0 ||\r\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' +\r\n            (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\r\n    }\r\n});\r\n/** Instantiates the retrieve SAML configuration endpoint settings. */\r\nvar GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain the SAML provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\r\n    }\r\n});\r\n/** Instantiates the delete SAML configuration endpoint settings. */\r\nvar DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\r\n/** Instantiates the create SAML configuration endpoint settings. */\r\nvar CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain the SAML provider resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\r\n    }\r\n});\r\n/** Instantiates the update SAML configuration endpoint settings. */\r\nvar UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain the configuration resource name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\r\n    }\r\n});\r\n/** Instantiates the list SAML configuration endpoint settings. */\r\nvar LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    // Validate next page token.\r\n    if (typeof request.pageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.pageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.pageSize) ||\r\n        request.pageSize <= 0 ||\r\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive integer that does not exceed ' +\r\n            (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\r\n    }\r\n});\r\n/**\r\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\r\n */\r\nvar AbstractAuthRequestHandler = /** @class */ (function () {\r\n    /**\r\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\r\n     * @constructor\r\n     */\r\n    function AbstractAuthRequestHandler(app) {\r\n        this.app = app;\r\n        if (typeof app !== 'object' || app === null || !('options' in app)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\r\n        }\r\n        this.httpClient = new AuthHttpClient(app);\r\n    }\r\n    /**\r\n     * @param {any} response The response to check for errors.\r\n     * @return {string|null} The error code if present; null otherwise.\r\n     */\r\n    AbstractAuthRequestHandler.getErrorCode = function (response) {\r\n        return (validator.isNonNullObject(response) && response.error && response.error.message) || null;\r\n    };\r\n    AbstractAuthRequestHandler.addUidToRequest = function (id, request) {\r\n        if (!validator.isUid(id.uid)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\r\n        }\r\n        request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];\r\n        return request;\r\n    };\r\n    AbstractAuthRequestHandler.addEmailToRequest = function (id, request) {\r\n        if (!validator.isEmail(id.email)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\r\n        }\r\n        request.email ? request.email.push(id.email) : request.email = [id.email];\r\n        return request;\r\n    };\r\n    AbstractAuthRequestHandler.addPhoneToRequest = function (id, request) {\r\n        if (!validator.isPhoneNumber(id.phoneNumber)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\r\n        }\r\n        request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];\r\n        return request;\r\n    };\r\n    AbstractAuthRequestHandler.addProviderToRequest = function (id, request) {\r\n        if (!validator.isNonEmptyString(id.providerId)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\r\n        }\r\n        if (!validator.isNonEmptyString(id.providerUid)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);\r\n        }\r\n        var federatedUserId = {\r\n            providerId: id.providerId,\r\n            rawId: id.providerUid,\r\n        };\r\n        request.federatedUserId\r\n            ? request.federatedUserId.push(federatedUserId)\r\n            : request.federatedUserId = [federatedUserId];\r\n        return request;\r\n    };\r\n    /**\r\n     * Creates a new Firebase session cookie with the specified duration that can be used for\r\n     * session management (set as a server side session cookie with custom cookie policy).\r\n     * The session cookie JWT will have the same payload claims as the provided ID token.\r\n     *\r\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\r\n     * @param {number} expiresIn The session cookie duration in milliseconds.\r\n     *\r\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.createSessionCookie = function (idToken, expiresIn) {\r\n        var request = {\r\n            idToken: idToken,\r\n            // Convert to seconds.\r\n            validDuration: expiresIn / 1000,\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request)\r\n            .then(function (response) { return response.sessionCookie; });\r\n    };\r\n    /**\r\n     * Looks up a user by uid.\r\n     *\r\n     * @param {string} uid The uid of the user to lookup.\r\n     * @return {Promise<object>} A promise that resolves with the user information.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getAccountInfoByUid = function (uid) {\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        var request = {\r\n            localId: [uid],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    };\r\n    /**\r\n     * Looks up a user by email.\r\n     *\r\n     * @param {string} email The email of the user to lookup.\r\n     * @return {Promise<object>} A promise that resolves with the user information.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getAccountInfoByEmail = function (email) {\r\n        if (!validator.isEmail(email)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\r\n        }\r\n        var request = {\r\n            email: [email],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    };\r\n    /**\r\n     * Looks up a user by phone number.\r\n     *\r\n     * @param {string} phoneNumber The phone number of the user to lookup.\r\n     * @return {Promise<object>} A promise that resolves with the user information.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getAccountInfoByPhoneNumber = function (phoneNumber) {\r\n        if (!validator.isPhoneNumber(phoneNumber)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\r\n        }\r\n        var request = {\r\n            phoneNumber: [phoneNumber],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    };\r\n    AbstractAuthRequestHandler.prototype.getAccountInfoByFederatedUid = function (providerId, rawId) {\r\n        if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\r\n        }\r\n        var request = {\r\n            federatedUserId: [{\r\n                    providerId: providerId,\r\n                    rawId: rawId,\r\n                }],\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\r\n    };\r\n    /**\r\n     * Looks up multiple users by their identifiers (uid, email, etc).\r\n     *\r\n     * @param {UserIdentifier[]} identifiers The identifiers indicating the users\r\n     *     to be looked up. Must have <= 100 entries.\r\n     * @param {Promise<object>} A promise that resolves with the set of successfully\r\n     *     looked up users. Possibly empty if no users were looked up.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getAccountInfoByIdentifiers = function (identifiers) {\r\n        if (identifiers.length === 0) {\r\n            return Promise.resolve({ users: [] });\r\n        }\r\n        else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`identifiers` parameter must have <= ' + MAX_GET_ACCOUNTS_BATCH_SIZE + ' entries.');\r\n        }\r\n        var request = {};\r\n        for (var _i = 0, identifiers_1 = identifiers; _i < identifiers_1.length; _i++) {\r\n            var id = identifiers_1[_i];\r\n            if (identifier_1.isUidIdentifier(id)) {\r\n                request = AbstractAuthRequestHandler.addUidToRequest(id, request);\r\n            }\r\n            else if (identifier_1.isEmailIdentifier(id)) {\r\n                request = AbstractAuthRequestHandler.addEmailToRequest(id, request);\r\n            }\r\n            else if (identifier_1.isPhoneIdentifier(id)) {\r\n                request = AbstractAuthRequestHandler.addPhoneToRequest(id, request);\r\n            }\r\n            else if (identifier_1.isProviderIdentifier(id)) {\r\n                request = AbstractAuthRequestHandler.addProviderToRequest(id, request);\r\n            }\r\n            else {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Unrecognized identifier: ' + id);\r\n            }\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);\r\n    };\r\n    /**\r\n     * Exports the users (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param {string=} pageToken The next page token. If not specified, returns users starting\r\n     *     without any offset. Users are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n     *     users and the next page token if available. For the last page, an empty list of users\r\n     *     and no page token are returned.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.downloadAccount = function (maxResults, pageToken) {\r\n        if (maxResults === void 0) { maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE; }\r\n        // Construct request.\r\n        var request = {\r\n            maxResults: maxResults,\r\n            nextPageToken: pageToken,\r\n        };\r\n        // Remove next page token if not provided.\r\n        if (typeof request.nextPageToken === 'undefined') {\r\n            delete request.nextPageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request)\r\n            .then(function (response) {\r\n            // No more users available.\r\n            if (!response.users) {\r\n                response.users = [];\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Imports the list of users provided to Firebase Auth. This is useful when\r\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n     * At most, 1000 users are allowed to be imported one at a time.\r\n     * When importing a list of password users, UserImportOptions are required to be specified.\r\n     *\r\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\r\n     * @param {UserImportOptions=} options The user import options, required when the users provided\r\n     *     include password credentials.\r\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\r\n     *     with the result of the import. This includes the number of successful imports, the number\r\n     *     of failed uploads and their corresponding errors.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.uploadAccount = function (users, options) {\r\n        // This will throw if any error is detected in the hash options.\r\n        // For errors in the list of users, this will not throw and will report the errors and the\r\n        // corresponding user index in the user import generated response below.\r\n        // No need to validate raw request or raw response as this is done in UserImportBuilder.\r\n        var userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, function (userRequest) {\r\n            // Pass true to validate the uploadAccount specific fields.\r\n            validateCreateEditRequest(userRequest, WriteOperationType.Upload);\r\n        });\r\n        var request = userImportBuilder.buildRequest();\r\n        // Fail quickly if more users than allowed are to be imported.\r\n        if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, \"A maximum of \" + MAX_UPLOAD_ACCOUNT_BATCH_SIZE + \" users can be imported at once.\");\r\n        }\r\n        // If no remaining user in request after client side processing, there is no need\r\n        // to send the request to the server.\r\n        if (!request.users || request.users.length === 0) {\r\n            return Promise.resolve(userImportBuilder.buildResponse([]));\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request)\r\n            .then(function (response) {\r\n            // No error object is returned if no error encountered.\r\n            var failedUploads = (response.error || []);\r\n            // Rewrite response as UserImportResult and re-insert client previously detected errors.\r\n            return userImportBuilder.buildResponse(failedUploads);\r\n        });\r\n    };\r\n    /**\r\n     * Deletes an account identified by a uid.\r\n     *\r\n     * @param {string} uid The uid of the user to delete.\r\n     * @return {Promise<object>} A promise that resolves when the user is deleted.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.deleteAccount = function (uid) {\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        var request = {\r\n            localId: uid,\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\r\n    };\r\n    AbstractAuthRequestHandler.prototype.deleteAccounts = function (uids, force) {\r\n        if (uids.length === 0) {\r\n            return Promise.resolve({});\r\n        }\r\n        else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`uids` parameter must have <= ' + MAX_DELETE_ACCOUNTS_BATCH_SIZE + ' entries.');\r\n        }\r\n        var request = {\r\n            localIds: [],\r\n            force: force,\r\n        };\r\n        uids.forEach(function (uid) {\r\n            if (!validator.isUid(uid)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\r\n            }\r\n            request.localIds.push(uid);\r\n        });\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);\r\n    };\r\n    /**\r\n     * Sets additional developer claims on an existing user identified by provided UID.\r\n     *\r\n     * @param {string} uid The user to edit.\r\n     * @param {object} customUserClaims The developer claims to set.\r\n     * @return {Promise<string>} A promise that resolves when the operation completes\r\n     *     with the user id that was edited.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.setCustomUserClaims = function (uid, customUserClaims) {\r\n        // Validate user UID.\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        else if (!validator.isObject(customUserClaims)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\r\n        }\r\n        // Delete operation. Replace null with an empty object.\r\n        if (customUserClaims === null) {\r\n            customUserClaims = {};\r\n        }\r\n        // Construct custom user attribute editting request.\r\n        var request = {\r\n            localId: uid,\r\n            customAttributes: JSON.stringify(customUserClaims),\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\r\n            .then(function (response) {\r\n            return response.localId;\r\n        });\r\n    };\r\n    /**\r\n     * Edits an existing user.\r\n     *\r\n     * @param {string} uid The user to edit.\r\n     * @param {object} properties The properties to set on the user.\r\n     * @return {Promise<string>} A promise that resolves when the operation completes\r\n     *     with the user id that was edited.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.updateExistingAccount = function (uid, properties) {\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        else if (!validator.isNonNullObject(properties)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\r\n        }\r\n        else if (validator.isNonNullObject(properties.providerToLink)) {\r\n            // TODO(rsgowman): These checks overlap somewhat with\r\n            // validateProviderUserInfo. It may be possible to refactor a bit.\r\n            if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.providerId of properties argument must be a non-empty string.');\r\n            }\r\n            if (!validator.isNonEmptyString(properties.providerToLink.uid)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providerToLink.uid of properties argument must be a non-empty string.');\r\n            }\r\n        }\r\n        else if (typeof properties.providersToUnlink !== 'undefined') {\r\n            if (!validator.isArray(properties.providersToUnlink)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\r\n            }\r\n            properties.providersToUnlink.forEach(function (providerId) {\r\n                if (!validator.isNonEmptyString(providerId)) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'providersToUnlink of properties argument must be an array of strings.');\r\n                }\r\n            });\r\n        }\r\n        // Build the setAccountInfo request.\r\n        var request = deep_copy_1.deepCopy(properties);\r\n        request.localId = uid;\r\n        // For deleting displayName or photoURL, these values must be passed as null.\r\n        // They will be removed from the backend request and an additional parameter\r\n        // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\r\n        // with an array of the parameter names to delete will be passed.\r\n        // Parameters that are deletable and their deleteAttribute names.\r\n        // Use client facing names, photoURL instead of photoUrl.\r\n        var deletableParams = {\r\n            displayName: 'DISPLAY_NAME',\r\n            photoURL: 'PHOTO_URL',\r\n        };\r\n        // Properties to delete if available.\r\n        request.deleteAttribute = [];\r\n        for (var key in deletableParams) {\r\n            if (request[key] === null) {\r\n                // Add property identifier to list of attributes to delete.\r\n                request.deleteAttribute.push(deletableParams[key]);\r\n                // Remove property from request.\r\n                delete request[key];\r\n            }\r\n        }\r\n        if (request.deleteAttribute.length === 0) {\r\n            delete request.deleteAttribute;\r\n        }\r\n        // For deleting phoneNumber, this value must be passed as null.\r\n        // It will be removed from the backend request and an additional parameter\r\n        // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\r\n        // will be passed.\r\n        if (request.phoneNumber === null) {\r\n            request.deleteProvider ? request.deleteProvider.push('phone') : request.deleteProvider = ['phone'];\r\n            delete request.phoneNumber;\r\n        }\r\n        if (typeof (request.providerToLink) !== 'undefined') {\r\n            request.linkProviderUserInfo = deep_copy_1.deepCopy(request.providerToLink);\r\n            delete request.providerToLink;\r\n            request.linkProviderUserInfo.rawId = request.linkProviderUserInfo.uid;\r\n            delete request.linkProviderUserInfo.uid;\r\n        }\r\n        if (typeof (request.providersToUnlink) !== 'undefined') {\r\n            if (!validator.isArray(request.deleteProvider)) {\r\n                request.deleteProvider = [];\r\n            }\r\n            request.deleteProvider = request.deleteProvider.concat(request.providersToUnlink);\r\n            delete request.providersToUnlink;\r\n        }\r\n        // Rewrite photoURL to photoUrl.\r\n        if (typeof request.photoURL !== 'undefined') {\r\n            request.photoUrl = request.photoURL;\r\n            delete request.photoURL;\r\n        }\r\n        // Rewrite disabled to disableUser.\r\n        if (typeof request.disabled !== 'undefined') {\r\n            request.disableUser = request.disabled;\r\n            delete request.disabled;\r\n        }\r\n        // Construct mfa related user data.\r\n        if (validator.isNonNullObject(request.multiFactor)) {\r\n            if (request.multiFactor.enrolledFactors === null) {\r\n                // Remove all second factors.\r\n                request.mfa = {};\r\n            }\r\n            else if (validator.isArray(request.multiFactor.enrolledFactors)) {\r\n                request.mfa = {\r\n                    enrollments: [],\r\n                };\r\n                try {\r\n                    request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\r\n                        request.mfa.enrollments.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    return Promise.reject(e);\r\n                }\r\n                if (request.mfa.enrollments.length === 0) {\r\n                    delete request.mfa.enrollments;\r\n                }\r\n            }\r\n            delete request.multiFactor;\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\r\n            .then(function (response) {\r\n            return response.localId;\r\n        });\r\n    };\r\n    /**\r\n     * Revokes all refresh tokens for the specified user identified by the uid provided.\r\n     * In addition to revoking all refresh tokens for a user, all ID tokens issued\r\n     * before revocation will also be revoked on the Auth backend. Any request with an\r\n     * ID token generated before revocation will be rejected with a token expired error.\r\n     * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\r\n     * the same second as the revocation will still be valid. If there is a chance that a token\r\n     * was minted in the last second, delay for 1 second before revoking.\r\n     *\r\n     * @param {string} uid The user whose tokens are to be revoked.\r\n     * @return {Promise<string>} A promise that resolves when the operation completes\r\n     *     successfully with the user id of the corresponding user.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.revokeRefreshTokens = function (uid) {\r\n        // Validate user UID.\r\n        if (!validator.isUid(uid)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\r\n        }\r\n        var request = {\r\n            localId: uid,\r\n            // validSince is in UTC seconds.\r\n            validSince: Math.floor(new Date().getTime() / 1000),\r\n        };\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\r\n            .then(function (response) {\r\n            return response.localId;\r\n        });\r\n    };\r\n    /**\r\n     * Create a new user with the properties supplied.\r\n     *\r\n     * @param {object} properties The properties to set on the user.\r\n     * @return {Promise<string>} A promise that resolves when the operation completes\r\n     *     with the user id that was created.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.createNewAccount = function (properties) {\r\n        if (!validator.isNonNullObject(properties)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\r\n        }\r\n        var request = deep_copy_1.deepCopy(properties);\r\n        // Rewrite photoURL to photoUrl.\r\n        if (typeof request.photoURL !== 'undefined') {\r\n            request.photoUrl = request.photoURL;\r\n            delete request.photoURL;\r\n        }\r\n        // Rewrite uid to localId if it exists.\r\n        if (typeof request.uid !== 'undefined') {\r\n            request.localId = request.uid;\r\n            delete request.uid;\r\n        }\r\n        // Construct mfa related user data.\r\n        if (validator.isNonNullObject(request.multiFactor)) {\r\n            if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {\r\n                var mfaInfo_1 = [];\r\n                try {\r\n                    request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\r\n                        // Enrollment time and uid are not allowed for signupNewUser endpoint.\r\n                        // They will automatically be provisioned server side.\r\n                        if ('enrollmentTime' in multiFactorInfo) {\r\n                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"enrollmentTime\" is not supported when adding second factors via \"createUser()\"');\r\n                        }\r\n                        else if ('uid' in multiFactorInfo) {\r\n                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"uid\" is not supported when adding second factors via \"createUser()\"');\r\n                        }\r\n                        mfaInfo_1.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    return Promise.reject(e);\r\n                }\r\n                request.mfaInfo = mfaInfo_1;\r\n            }\r\n            delete request.multiFactor;\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request)\r\n            .then(function (response) {\r\n            // Return the user id.\r\n            return response.localId;\r\n        });\r\n    };\r\n    /**\r\n     * Generates the out of band email action link for the email specified using the action code settings provided.\r\n     * Returns a promise that resolves with the generated link.\r\n     *\r\n     * @param {string} requestType The request type. This could be either used for password reset,\r\n     *     email verification, email link sign-in.\r\n     * @param {string} email The email of the user the link is being sent to.\r\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\r\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n     *     deep link, etc. Required when requestType == 'EMAIL_SIGNIN'\r\n     * @return {Promise<string>} A promise that resolves with the email action link.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getEmailActionLink = function (requestType, email, actionCodeSettings) {\r\n        var request = { requestType: requestType, email: email, returnOobLink: true };\r\n        // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\r\n        // be completed.\r\n        if (typeof actionCodeSettings === 'undefined' && requestType === 'EMAIL_SIGNIN') {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'\"));\r\n        }\r\n        if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\r\n            try {\r\n                var builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\r\n                request = deep_copy_1.deepExtend(request, builder.buildRequest());\r\n            }\r\n            catch (e) {\r\n                return Promise.reject(e);\r\n            }\r\n        }\r\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request)\r\n            .then(function (response) {\r\n            // Return the link.\r\n            return response.oobLink;\r\n        });\r\n    };\r\n    /**\r\n     * Looks up an OIDC provider configuration by provider ID.\r\n     *\r\n     * @param {string} providerId The provider identifier of the configuration to lookup.\r\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the provider configuration information.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getOAuthIdpConfig = function (providerId) {\r\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, { providerId: providerId });\r\n    };\r\n    /**\r\n     * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param {string=} pageToken The next page token. If not specified, returns OIDC configurations\r\n     *     without any offset. Configurations are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n     *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\r\n     *     configuration and no page token are returned.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.listOAuthIdpConfigs = function (maxResults, pageToken) {\r\n        if (maxResults === void 0) { maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE; }\r\n        var request = {\r\n            pageSize: maxResults,\r\n        };\r\n        // Add next page token if provided.\r\n        if (typeof pageToken !== 'undefined') {\r\n            request.pageToken = pageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request)\r\n            .then(function (response) {\r\n            if (!response.oauthIdpConfigs) {\r\n                response.oauthIdpConfigs = [];\r\n                delete response.nextPageToken;\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Deletes an OIDC configuration identified by a providerId.\r\n     *\r\n     * @param {string} providerId The identifier of the OIDC configuration to delete.\r\n     * @return {Promise<void>} A promise that resolves when the OIDC provider is deleted.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.deleteOAuthIdpConfig = function (providerId) {\r\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, { providerId: providerId })\r\n            .then(function () {\r\n            // Return nothing.\r\n        });\r\n    };\r\n    /**\r\n     * Creates a new OIDC provider configuration with the properties provided.\r\n     *\r\n     * @param {AuthProviderConfig} options The properties to set on the new OIDC provider configuration to be created.\r\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the newly created OIDC\r\n     *     configuration.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.createOAuthIdpConfig = function (options) {\r\n        // Construct backend request.\r\n        var request;\r\n        try {\r\n            request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        var providerId = options.providerId;\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, { providerId: providerId })\r\n            .then(function (response) {\r\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Updates an existing OIDC provider configuration with the properties provided.\r\n     *\r\n     * @param {string} providerId The provider identifier of the OIDC configuration to update.\r\n     * @param {OIDCUpdateAuthProviderRequest} options The properties to update on the existing configuration.\r\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the modified provider\r\n     *     configuration.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.updateOAuthIdpConfig = function (providerId, options) {\r\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        // Construct backend request.\r\n        var request;\r\n        try {\r\n            request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        var updateMask = utils.generateUpdateMask(request);\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, { providerId: providerId, updateMask: updateMask.join(',') })\r\n            .then(function (response) {\r\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Looks up an SAML provider configuration by provider ID.\r\n     *\r\n     * @param {string} providerId The provider identifier of the configuration to lookup.\r\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the provider configuration information.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getInboundSamlConfig = function (providerId) {\r\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, { providerId: providerId });\r\n    };\r\n    /**\r\n     * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param {string=} pageToken The next page token. If not specified, returns SAML configurations starting\r\n     *     without any offset. Configurations are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n     *     SAML configurations and the next page token if available. For the last page, an empty list of provider\r\n     *     configuration and no page token are returned.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.listInboundSamlConfigs = function (maxResults, pageToken) {\r\n        if (maxResults === void 0) { maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE; }\r\n        var request = {\r\n            pageSize: maxResults,\r\n        };\r\n        // Add next page token if provided.\r\n        if (typeof pageToken !== 'undefined') {\r\n            request.pageToken = pageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request)\r\n            .then(function (response) {\r\n            if (!response.inboundSamlConfigs) {\r\n                response.inboundSamlConfigs = [];\r\n                delete response.nextPageToken;\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Deletes a SAML configuration identified by a providerId.\r\n     *\r\n     * @param {string} providerId The identifier of the SAML configuration to delete.\r\n     * @return {Promise<void>} A promise that resolves when the SAML provider is deleted.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.deleteInboundSamlConfig = function (providerId) {\r\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, { providerId: providerId })\r\n            .then(function () {\r\n            // Return nothing.\r\n        });\r\n    };\r\n    /**\r\n     * Creates a new SAML provider configuration with the properties provided.\r\n     *\r\n     * @param {AuthProviderConfig} options The properties to set on the new SAML provider configuration to be created.\r\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the newly created SAML\r\n     *     configuration.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.createInboundSamlConfig = function (options) {\r\n        // Construct backend request.\r\n        var request;\r\n        try {\r\n            request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        var providerId = options.providerId;\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, { providerId: providerId })\r\n            .then(function (response) {\r\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Updates an existing SAML provider configuration with the properties provided.\r\n     *\r\n     * @param {string} providerId The provider identifier of the SAML configuration to update.\r\n     * @param {SAMLUpdateAuthProviderRequest} options The properties to update on the existing configuration.\r\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the modified provider\r\n     *     configuration.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.updateInboundSamlConfig = function (providerId, options) {\r\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n        }\r\n        // Construct backend request.\r\n        var request;\r\n        try {\r\n            request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n        var updateMask = utils.generateUpdateMask(request);\r\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, { providerId: providerId, updateMask: updateMask.join(',') })\r\n            .then(function (response) {\r\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Invokes the request handler based on the API settings object passed.\r\n     *\r\n     * @param {AuthResourceUrlBuilder} urlBuilder The URL builder for Auth endpoints.\r\n     * @param {ApiSettings} apiSettings The API endpoint settings to apply to request and response.\r\n     * @param {object} requestData The request data.\r\n     * @param {object=} additionalResourceParams Additional resource related params if needed.\r\n     * @return {Promise<object>} A promise that resolves with the response.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.invokeRequestHandler = function (urlBuilder, apiSettings, requestData, additionalResourceParams) {\r\n        var _this = this;\r\n        return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams)\r\n            .then(function (url) {\r\n            // Validate request.\r\n            var requestValidator = apiSettings.getRequestValidator();\r\n            requestValidator(requestData);\r\n            // Process request.\r\n            var req = {\r\n                method: apiSettings.getHttpMethod(),\r\n                url: url,\r\n                headers: FIREBASE_AUTH_HEADER,\r\n                data: requestData,\r\n                timeout: FIREBASE_AUTH_TIMEOUT,\r\n            };\r\n            return _this.httpClient.send(req);\r\n        })\r\n            .then(function (response) {\r\n            // Validate response.\r\n            var responseValidator = apiSettings.getResponseValidator();\r\n            responseValidator(response.data);\r\n            // Return entire response.\r\n            return response.data;\r\n        })\r\n            .catch(function (err) {\r\n            if (err instanceof api_request_1.HttpError) {\r\n                var error = err.response.data;\r\n                var errorCode = AbstractAuthRequestHandler.getErrorCode(error);\r\n                if (!errorCode) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' +\r\n                        'internal error occurred while attempting to extract the ' +\r\n                        'errorcode from the error.');\r\n                }\r\n                throw error_1.FirebaseAuthError.fromServerError(errorCode, /* message */ undefined, error);\r\n            }\r\n            throw err;\r\n        });\r\n    };\r\n    /**\r\n     * @return {AuthResourceUrlBuilder} The current Auth user management resource URL builder.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getAuthUrlBuilder = function () {\r\n        if (!this.authUrlBuilder) {\r\n            this.authUrlBuilder = this.newAuthUrlBuilder();\r\n        }\r\n        return this.authUrlBuilder;\r\n    };\r\n    /**\r\n     * @return {AuthResourceUrlBuilder} The current project config resource URL builder.\r\n     */\r\n    AbstractAuthRequestHandler.prototype.getProjectConfigUrlBuilder = function () {\r\n        if (!this.projectConfigUrlBuilder) {\r\n            this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\r\n        }\r\n        return this.projectConfigUrlBuilder;\r\n    };\r\n    return AbstractAuthRequestHandler;\r\n}());\r\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\r\n/** Instantiates the getTenant endpoint settings. */\r\nvar GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain at least the tenant name.\r\n    if (!validator.isNonEmptyString(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\r\n    }\r\n});\r\n/** Instantiates the deleteTenant endpoint settings. */\r\nvar DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\r\n/** Instantiates the updateTenant endpoint settings. */\r\nvar UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain at least the tenant name.\r\n    if (!validator.isNonEmptyString(response.name) ||\r\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\r\n    }\r\n});\r\n/** Instantiates the listTenants endpoint settings. */\r\nvar LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET')\r\n    // Set request validator.\r\n    .setRequestValidator(function (request) {\r\n    // Validate next page token.\r\n    if (typeof request.pageToken !== 'undefined' &&\r\n        !validator.isNonEmptyString(request.pageToken)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\r\n    }\r\n    // Validate max results.\r\n    if (!validator.isNumber(request.pageSize) ||\r\n        request.pageSize <= 0 ||\r\n        request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Required \"maxResults\" must be a positive non-zero number that does not exceed ' +\r\n            (\"the allowed \" + MAX_LIST_TENANT_PAGE_SIZE + \".\"));\r\n    }\r\n});\r\n/** Instantiates the createTenant endpoint settings. */\r\nvar CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST')\r\n    // Set response validator.\r\n    .setResponseValidator(function (response) {\r\n    // Response should always contain at least the tenant name.\r\n    if (!validator.isNonEmptyString(response.name) ||\r\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\r\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\r\n    }\r\n});\r\n/**\r\n * Utility for sending requests to Auth server that are Auth instance related. This includes user and\r\n * tenant management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\r\n * additional tenant management related APIs.\r\n */\r\nvar AuthRequestHandler = /** @class */ (function (_super) {\r\n    __extends(AuthRequestHandler, _super);\r\n    /**\r\n     * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\r\n     *\r\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\r\n     * @constructor.\r\n     */\r\n    function AuthRequestHandler(app) {\r\n        var _this = _super.call(this, app) || this;\r\n        _this.tenantMgmtResourceBuilder = new AuthResourceUrlBuilder(app, 'v2');\r\n        return _this;\r\n    }\r\n    /**\r\n     * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\r\n     */\r\n    AuthRequestHandler.prototype.newAuthUrlBuilder = function () {\r\n        return new AuthResourceUrlBuilder(this.app, 'v1');\r\n    };\r\n    /**\r\n     * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\r\n     */\r\n    AuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\r\n        return new AuthResourceUrlBuilder(this.app, 'v2');\r\n    };\r\n    /**\r\n     * Looks up a tenant by tenant ID.\r\n     *\r\n     * @param {string} tenantId The tenant identifier of the tenant to lookup.\r\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the tenant information.\r\n     */\r\n    AuthRequestHandler.prototype.getTenant = function (tenantId) {\r\n        if (!validator.isNonEmptyString(tenantId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, GET_TENANT, {}, { tenantId: tenantId })\r\n            .then(function (response) {\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Exports the tenants (single batch only) with a size of maxResults and starting from\r\n     * the offset as specified by pageToken.\r\n     *\r\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param {string=} pageToken The next page token. If not specified, returns tenants starting\r\n     *     without any offset. Tenants are returned in the order they were created from oldest to\r\n     *     newest, relative to the page token offset.\r\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\r\n     *     tenants and the next page token if available. For the last page, an empty list of tenants\r\n     *     and no page token are returned.\r\n     */\r\n    AuthRequestHandler.prototype.listTenants = function (maxResults, pageToken) {\r\n        if (maxResults === void 0) { maxResults = MAX_LIST_TENANT_PAGE_SIZE; }\r\n        var request = {\r\n            pageSize: maxResults,\r\n            pageToken: pageToken,\r\n        };\r\n        // Remove next page token if not provided.\r\n        if (typeof request.pageToken === 'undefined') {\r\n            delete request.pageToken;\r\n        }\r\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, LIST_TENANTS, request)\r\n            .then(function (response) {\r\n            if (!response.tenants) {\r\n                response.tenants = [];\r\n                delete response.nextPageToken;\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n    /**\r\n     * Deletes a tenant identified by a tenantId.\r\n     *\r\n     * @param {string} tenantId The identifier of the tenant to delete.\r\n     * @return {Promise<void>} A promise that resolves when the tenant is deleted.\r\n     */\r\n    AuthRequestHandler.prototype.deleteTenant = function (tenantId) {\r\n        if (!validator.isNonEmptyString(tenantId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\r\n        }\r\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, DELETE_TENANT, {}, { tenantId: tenantId })\r\n            .then(function () {\r\n            // Return nothing.\r\n        });\r\n    };\r\n    /**\r\n     * Creates a new tenant with the properties provided.\r\n     *\r\n     * @param {TenantOptions} tenantOptions The properties to set on the new tenant to be created.\r\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the newly created tenant object.\r\n     */\r\n    AuthRequestHandler.prototype.createTenant = function (tenantOptions) {\r\n        try {\r\n            // Construct backend request.\r\n            var request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\r\n            return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, CREATE_TENANT, request)\r\n                .then(function (response) {\r\n                return response;\r\n            });\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    };\r\n    /**\r\n     * Updates an existing tenant with the properties provided.\r\n     *\r\n     * @param {string} tenantId The tenant identifier of the tenant to update.\r\n     * @param {TenantOptions} tenantOptions The properties to update on the existing tenant.\r\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the modified tenant object.\r\n     */\r\n    AuthRequestHandler.prototype.updateTenant = function (tenantId, tenantOptions) {\r\n        if (!validator.isNonEmptyString(tenantId)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\r\n        }\r\n        try {\r\n            // Construct backend request.\r\n            var request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);\r\n            // Do not traverse deep into testPhoneNumbers. The entire content should be replaced\r\n            // and not just specific phone numbers.\r\n            var updateMask = utils.generateUpdateMask(request, ['testPhoneNumbers']);\r\n            return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, UPDATE_TENANT, request, { tenantId: tenantId, updateMask: updateMask.join(',') })\r\n                .then(function (response) {\r\n                return response;\r\n            });\r\n        }\r\n        catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    };\r\n    return AuthRequestHandler;\r\n}(AbstractAuthRequestHandler));\r\nexports.AuthRequestHandler = AuthRequestHandler;\r\n/**\r\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\r\n * management related APIs for specified tenants.\r\n * This extends the BaseFirebaseAuthRequestHandler class.\r\n */\r\nvar TenantAwareAuthRequestHandler = /** @class */ (function (_super) {\r\n    __extends(TenantAwareAuthRequestHandler, _super);\r\n    /**\r\n     * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\r\n     * FirebaseApp and a tenant ID.\r\n     *\r\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\r\n     * @param {string} tenantId The request handler's tenant ID.\r\n     * @constructor\r\n     */\r\n    function TenantAwareAuthRequestHandler(app, tenantId) {\r\n        var _this = _super.call(this, app) || this;\r\n        _this.tenantId = tenantId;\r\n        return _this;\r\n    }\r\n    /**\r\n     * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\r\n     */\r\n    TenantAwareAuthRequestHandler.prototype.newAuthUrlBuilder = function () {\r\n        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v1', this.tenantId);\r\n    };\r\n    /**\r\n     * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\r\n     */\r\n    TenantAwareAuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\r\n        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v2', this.tenantId);\r\n    };\r\n    /**\r\n     * Imports the list of users provided to Firebase Auth. This is useful when\r\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n     * At most, 1000 users are allowed to be imported one at a time.\r\n     * When importing a list of password users, UserImportOptions are required to be specified.\r\n     *\r\n     * Overrides the superclass methods by adding an additional check to match tenant IDs of\r\n     * imported user records if present.\r\n     *\r\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\r\n     * @param {UserImportOptions=} options The user import options, required when the users provided\r\n     *     include password credentials.\r\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\r\n     *     with the result of the import. This includes the number of successful imports, the number\r\n     *     of failed uploads and their corresponding errors.\r\n     */\r\n    TenantAwareAuthRequestHandler.prototype.uploadAccount = function (users, options) {\r\n        var _this = this;\r\n        // Add additional check to match tenant ID of imported user records.\r\n        users.forEach(function (user, index) {\r\n            if (validator.isNonEmptyString(user.tenantId) &&\r\n                user.tenantId !== _this.tenantId) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, \"UserRecord of index \\\"\" + index + \"\\\" has mismatching tenant ID \\\"\" + user.tenantId + \"\\\"\");\r\n            }\r\n        });\r\n        return _super.prototype.uploadAccount.call(this, users, options);\r\n    };\r\n    return TenantAwareAuthRequestHandler;\r\n}(AbstractAuthRequestHandler));\r\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;\r\nfunction emulatorHost() {\r\n    return process.env.FIREBASE_AUTH_EMULATOR_HOST;\r\n}\r\n/**\r\n * When true the SDK should communicate with the Auth Emulator for all API\r\n * calls and also produce unsigned tokens.\r\n */\r\nfunction useEmulator() {\r\n    return !!emulatorHost();\r\n}\r\nexports.useEmulator = useEmulator;\r\n"]},"metadata":{},"sourceType":"script"}