{"ast":null,"code":"const {\n  ArgumentError\n} = require('../errors');\n\nconst {\n  JwksClient\n} = require('../JwksClient');\n\nconst supportedAlg = require('./config');\n\nconst handleSigningKeyError = (err, cb) => {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(err, null, null);\n  } // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n\n\n  if (err) {\n    return cb(err, null, null);\n  }\n};\n/**\r\n * Call hapiJwt2Key as a Promise\r\n * @param {object} options \r\n * @returns {Promise}\r\n */\n\n\nmodule.exports.hapiJwt2KeyAsync = options => {\n  const secretProvider = module.exports.hapiJwt2Key(options);\n  return function (decoded) {\n    return new Promise((resolve, reject) => {\n      const cb = (err, key) => {\n        !key || err ? reject(err) : resolve({\n          key\n        });\n      };\n\n      secretProvider(decoded, cb);\n    });\n  };\n};\n\nmodule.exports.hapiJwt2Key = function (options) {\n  if (options === null || options === undefined) {\n    throw new ArgumentError('An options object must be provided when initializing hapiJwt2Key');\n  }\n\n  const client = new JwksClient(options);\n  const onError = options.handleSigningKeyError || handleSigningKeyError;\n  return function secretProvider(decoded, cb) {\n    // We cannot find a signing certificate if there is no header (no kid).\n    if (!decoded || !decoded.header) {\n      return cb(new Error('Cannot find a signing certificate if there is no header'), null, null);\n    }\n\n    if (!supportedAlg.includes(decoded.header.alg)) {\n      return cb(new Error('Unsupported algorithm ' + decoded.header.alg + ' supplied.'), null, null);\n    }\n\n    client.getSigningKey(decoded.header.kid).then(key => {\n      return cb(null, key.publicKey || key.rsaPublicKey, key);\n    }).catch(err => {\n      return onError(err, newError => cb(newError, null, null));\n    });\n  };\n};","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/jwks-rsa/src/integrations/hapi.js"],"names":["ArgumentError","require","JwksClient","supportedAlg","handleSigningKeyError","err","cb","name","module","exports","hapiJwt2KeyAsync","options","secretProvider","hapiJwt2Key","decoded","Promise","resolve","reject","key","undefined","client","onError","header","Error","includes","alg","getSigningKey","kid","then","publicKey","rsaPublicKey","catch","newError"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAoBC,OAAO,CAAC,WAAD,CAAjC;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAiBD,OAAO,CAAC,eAAD,CAA9B;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,UAAD,CAA5B;;AAEA,MAAMG,qBAAqB,GAAG,CAACC,GAAD,EAAMC,EAAN,KAAa;AACzC;AACA,MAAID,GAAG,IAAIA,GAAG,CAACE,IAAJ,KAAa,yBAAxB,EAAmD;AACjD,WAAOD,EAAE,CAACD,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAT;AACD,GAJwC,CAMzC;;;AACA,MAAIA,GAAJ,EAAS;AACP,WAAOC,EAAE,CAACD,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAT;AACD;AACF,CAVD;AAYA;AACA;AACA;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,CAAeC,gBAAf,GAAmCC,OAAD,IAAa;AAC7C,QAAMC,cAAc,GAAGJ,MAAM,CAACC,OAAP,CAAeI,WAAf,CAA2BF,OAA3B,CAAvB;AACA,SAAO,UAASG,OAAT,EAAkB;AACvB,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,YAAMX,EAAE,GAAG,CAACD,GAAD,EAAMa,GAAN,KAAc;AACtB,SAACA,GAAD,IAAQb,GAAT,GAAgBY,MAAM,CAACZ,GAAD,CAAtB,GAA8BW,OAAO,CAAC;AAAEE,UAAAA;AAAF,SAAD,CAArC;AACD,OAFD;;AAGAN,MAAAA,cAAc,CAACE,OAAD,EAAUR,EAAV,CAAd;AACD,KALM,CAAP;AAMD,GAPD;AAQD,CAVD;;AAYAE,MAAM,CAACC,OAAP,CAAeI,WAAf,GAA6B,UAAUF,OAAV,EAAmB;AAC9C,MAAIA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAKQ,SAApC,EAA+C;AAC7C,UAAM,IAAInB,aAAJ,CAAkB,kEAAlB,CAAN;AACD;;AAED,QAAMoB,MAAM,GAAG,IAAIlB,UAAJ,CAAeS,OAAf,CAAf;AACA,QAAMU,OAAO,GAAGV,OAAO,CAACP,qBAAR,IAAiCA,qBAAjD;AAEA,SAAO,SAASQ,cAAT,CAAwBE,OAAxB,EAAiCR,EAAjC,EAAqC;AAC1C;AACA,QAAI,CAACQ,OAAD,IAAY,CAACA,OAAO,CAACQ,MAAzB,EAAiC;AAC/B,aAAOhB,EAAE,CAAC,IAAIiB,KAAJ,CAAU,yDAAV,CAAD,EAAuE,IAAvE,EAA6E,IAA7E,CAAT;AACD;;AAED,QAAI,CAACpB,YAAY,CAACqB,QAAb,CAAsBV,OAAO,CAACQ,MAAR,CAAeG,GAArC,CAAL,EAAgD;AAC9C,aAAOnB,EAAE,CAAC,IAAIiB,KAAJ,CAAU,2BAA2BT,OAAO,CAACQ,MAAR,CAAeG,GAA1C,GAAgD,YAA1D,CAAD,EAA0E,IAA1E,EAAgF,IAAhF,CAAT;AACD;;AAEDL,IAAAA,MAAM,CAACM,aAAP,CAAqBZ,OAAO,CAACQ,MAAR,CAAeK,GAApC,EACGC,IADH,CACQV,GAAG,IAAI;AACX,aAAOZ,EAAE,CAAC,IAAD,EAAOY,GAAG,CAACW,SAAJ,IAAiBX,GAAG,CAACY,YAA5B,EAA0CZ,GAA1C,CAAT;AACD,KAHH,EAGKa,KAHL,CAGW1B,GAAG,IAAI;AACd,aAAOgB,OAAO,CAAChB,GAAD,EAAO2B,QAAD,IAAc1B,EAAE,CAAC0B,QAAD,EAAW,IAAX,EAAiB,IAAjB,CAAtB,CAAd;AACD,KALH;AAMD,GAhBD;AAiBD,CAzBD","sourcesContent":["const { ArgumentError } = require('../errors');\r\nconst { JwksClient } = require('../JwksClient');\r\nconst supportedAlg = require('./config');\r\n\r\nconst handleSigningKeyError = (err, cb) => {\r\n  // If we didn't find a match, can't provide a key.\r\n  if (err && err.name === 'SigningKeyNotFoundError') {\r\n    return cb(err, null, null);\r\n  }\r\n\r\n  // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\r\n  if (err) {\r\n    return cb(err, null, null);\r\n  }\r\n};\r\n\r\n/**\r\n * Call hapiJwt2Key as a Promise\r\n * @param {object} options \r\n * @returns {Promise}\r\n */\r\nmodule.exports.hapiJwt2KeyAsync = (options) => {\r\n  const secretProvider = module.exports.hapiJwt2Key(options);\r\n  return function(decoded) {\r\n    return new Promise((resolve, reject) => {\r\n      const cb = (err, key) => {\r\n        (!key || err) ? reject(err) : resolve({ key });\r\n      };\r\n      secretProvider(decoded, cb);\r\n    });\r\n  };\r\n}; \r\n\r\nmodule.exports.hapiJwt2Key = function (options) {\r\n  if (options === null || options === undefined) {\r\n    throw new ArgumentError('An options object must be provided when initializing hapiJwt2Key');\r\n  }\r\n\r\n  const client = new JwksClient(options);\r\n  const onError = options.handleSigningKeyError || handleSigningKeyError;\r\n\r\n  return function secretProvider(decoded, cb) {\r\n    // We cannot find a signing certificate if there is no header (no kid).\r\n    if (!decoded || !decoded.header) {\r\n      return cb(new Error('Cannot find a signing certificate if there is no header'), null, null);\r\n    }\r\n\r\n    if (!supportedAlg.includes(decoded.header.alg)) {\r\n      return cb(new Error('Unsupported algorithm ' + decoded.header.alg + ' supplied.'), null, null);\r\n    }\r\n\r\n    client.getSigningKey(decoded.header.kid)\r\n      .then(key => {\r\n        return cb(null, key.publicKey || key.rsaPublicKey, key);\r\n      }).catch(err => {\r\n        return onError(err, (newError) => cb(newError, null, null));\r\n      });\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}