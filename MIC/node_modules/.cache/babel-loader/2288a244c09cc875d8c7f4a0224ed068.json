{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst _1 = require(\".\");\n\nconst util_1 = require(\"./util\");\n\nconst reference_1 = require(\"./reference\");\n/*!\r\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\r\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\r\n * negative numeric value expressed in that format.\r\n *\r\n * This constant is used to specify startAt/endAt values when querying for all\r\n * descendants in a single collection.\r\n */\n\n\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\r\n * The query limit used for recursive deletes when fetching all descendants of\r\n * the specified reference to delete. This is done to prevent the query stream\r\n * from streaming documents faster than Firestore can delete.\r\n */\n// Visible for testing.\n\nexports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;\n/*!\r\n * The number of pending BulkWriter operations at which RecursiveDelete\r\n * starts the next limit query to fetch descendants. By starting the query\r\n * while there are pending operations, Firestore can improve BulkWriter\r\n * throughput. This helps prevent BulkWriter from idling while Firestore\r\n * fetches the next query.\r\n */\n\nexports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;\n/**\r\n * Class used to store state required for running a recursive delete operation.\r\n * Each recursive delete call should use a new instance of the class.\r\n * @private\r\n */\n\nclass RecursiveDelete {\n  /**\r\n   *\r\n   * @param firestore The Firestore instance to use.\r\n   * @param writer The BulkWriter instance to use for delete operations.\r\n   * @param ref The document or collection reference to recursively delete.\r\n   * @param maxLimit The query limit to use when fetching descendants\r\n   * @param minLimit The number of pending BulkWriter operations at which\r\n   * RecursiveDelete starts the next limit query to fetch descendants.\r\n   */\n  constructor(firestore, writer, ref, maxLimit, minLimit) {\n    this.firestore = firestore;\n    this.writer = writer;\n    this.ref = ref;\n    this.maxLimit = maxLimit;\n    this.minLimit = minLimit;\n    /**\r\n     * The number of deletes that failed with a permanent error.\r\n     * @private\r\n     */\n\n    this.errorCount = 0;\n    /**\r\n     * Whether there are still documents to delete that still need to be fetched.\r\n     * @private\r\n     */\n\n    this.documentsPending = true;\n    /**\r\n     * Whether run() has been called.\r\n     * @private\r\n     */\n\n    this.started = false;\n    /**\r\n     * A deferred promise that resolves when the recursive delete operation\r\n     * is completed.\r\n     * @private\r\n     */\n\n    this.completionDeferred = new util_1.Deferred();\n    /**\r\n     * Whether a query stream is currently in progress. Only one stream can be\r\n     * run at a time.\r\n     * @private\r\n     */\n\n    this.streamInProgress = false;\n    /**\r\n     * The number of pending BulkWriter operations. Used to determine when the\r\n     * next query can be run.\r\n     * @private\r\n     */\n\n    this.pendingOpsCount = 0;\n    this.errorStack = '';\n    this.maxPendingOps = maxLimit;\n    this.minPendingOps = minLimit;\n  }\n  /**\r\n   * Recursively deletes the reference provided in the class constructor.\r\n   * Returns a promise that resolves when all descendants have been deleted, or\r\n   * if an error occurs.\r\n   */\n\n\n  run() {\n    assert(!this.started, 'RecursiveDelete.run() should only be called once.'); // Capture the error stack to preserve stack tracing across async calls.\n\n    this.errorStack = Error().stack;\n\n    this.writer._verifyNotClosed();\n\n    this.setupStream();\n    return this.completionDeferred.promise;\n  }\n  /**\r\n   * Creates a query stream and attaches event handlers to it.\r\n   * @private\r\n   */\n\n\n  setupStream() {\n    const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference ? this.ref : this.ref);\n    this.streamInProgress = true;\n    let streamedDocsCount = 0;\n    stream.on('error', err => {\n      err.code = 14\n      /* UNAVAILABLE */\n      ;\n      err.stack = 'Failed to fetch children documents: ' + err.stack;\n      this.lastError = err;\n      this.onQueryEnd();\n    }).on('data', snap => {\n      streamedDocsCount++;\n      this.lastDocumentSnap = snap;\n      this.deleteRef(snap.ref);\n    }).on('end', () => {\n      this.streamInProgress = false; // If there are fewer than the number of documents specified in the\n      // limit() field, we know that the query is complete.\n\n      if (streamedDocsCount < this.minPendingOps) {\n        this.onQueryEnd();\n      } else if (this.pendingOpsCount === 0) {\n        this.setupStream();\n      }\n    });\n  }\n  /**\r\n   * Retrieves all descendant documents nested under the provided reference.\r\n   * @param ref The reference to fetch all descendants for.\r\n   * @private\r\n   * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\r\n   */\n\n\n  getAllDescendants(ref) {\n    // The parent is the closest ancestor document to the location we're\n    // deleting. If we are deleting a document, the parent is the path of that\n    // document. If we are deleting a collection, the parent is the path of the\n    // document containing that collection (or the database root, if it is a\n    // root collection).\n    let parentPath = ref._resourcePath;\n\n    if (ref instanceof _1.CollectionReference) {\n      parentPath = parentPath.popLast();\n    }\n\n    const collectionId = ref instanceof _1.CollectionReference ? ref.id : ref.parent.id;\n    let query = new _1.Query(this.firestore, reference_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId,\n    /* requireConsistency= */\n    false)); // Query for names only to fetch empty snapshots.\n\n    query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);\n\n    if (ref instanceof _1.CollectionReference) {\n      // To find all descendants of a collection reference, we need to use a\n      // composite filter that captures all documents that start with the\n      // collection prefix. The MIN_KEY constant represents the minimum key in\n      // this collection, and a null byte + the MIN_KEY represents the minimum\n      // key is the next possible collection.\n      const nullChar = String.fromCharCode(0);\n      const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n      const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n      query = query.where(_1.FieldPath.documentId(), '>=', startAt).where(_1.FieldPath.documentId(), '<', endAt);\n    }\n\n    if (this.lastDocumentSnap) {\n      query = query.startAfter(this.lastDocumentSnap);\n    }\n\n    return query.stream();\n  }\n  /**\r\n   * Called when all descendants of the provided reference have been streamed\r\n   * or if a permanent error occurs during the stream. Deletes the developer\r\n   * provided reference and wraps any errors that occurred.\r\n   * @private\r\n   */\n\n\n  onQueryEnd() {\n    this.documentsPending = false;\n\n    if (this.ref instanceof _1.DocumentReference) {\n      this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));\n    }\n\n    this.writer.flush().then(async () => {\n      var _a;\n\n      if (this.lastError === undefined) {\n        this.completionDeferred.resolve();\n      } else {\n        let error = new (require('google-gax').GoogleError)(`${this.errorCount} ` + `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` + 'failed. The last delete failed with: ');\n\n        if (this.lastError.code !== undefined) {\n          error.code = this.lastError.code;\n        }\n\n        error = util_1.wrapError(error, this.errorStack); // Wrap the BulkWriter error last to provide the full stack trace.\n\n        this.completionDeferred.reject(this.lastError.stack ? util_1.wrapError(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '') : error);\n      }\n    });\n  }\n  /**\r\n   * Deletes the provided reference and starts the next stream if conditions\r\n   * are met.\r\n   * @private\r\n   */\n\n\n  deleteRef(docRef) {\n    this.pendingOpsCount++;\n    this.writer.delete(docRef).catch(err => {\n      this.incrementErrorCount(err);\n    }).then(() => {\n      this.pendingOpsCount--; // We wait until the previous stream has ended in order to sure the\n      // startAfter document is correct. Starting the next stream while\n      // there are pending operations allows Firestore to maximize\n      // BulkWriter throughput.\n\n      if (this.documentsPending && !this.streamInProgress && this.pendingOpsCount < this.minPendingOps) {\n        this.setupStream();\n      }\n    });\n  }\n\n  incrementErrorCount(err) {\n    this.errorCount++;\n    this.lastError = err;\n  }\n\n}\n\nexports.RecursiveDelete = RecursiveDelete;","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/@google-cloud/firestore/build/src/recursive-delete.js"],"names":["Object","defineProperty","exports","value","assert","require","_1","util_1","reference_1","REFERENCE_NAME_MIN_ID","RECURSIVE_DELETE_MAX_PENDING_OPS","RECURSIVE_DELETE_MIN_PENDING_OPS","RecursiveDelete","constructor","firestore","writer","ref","maxLimit","minLimit","errorCount","documentsPending","started","completionDeferred","Deferred","streamInProgress","pendingOpsCount","errorStack","maxPendingOps","minPendingOps","run","Error","stack","_verifyNotClosed","setupStream","promise","stream","getAllDescendants","CollectionReference","streamedDocsCount","on","err","code","lastError","onQueryEnd","snap","lastDocumentSnap","deleteRef","parentPath","_resourcePath","popLast","collectionId","id","parent","query","Query","QueryOptions","forKindlessAllDescendants","select","FieldPath","documentId","limit","nullChar","String","fromCharCode","startAt","endAt","where","startAfter","DocumentReference","delete","catch","incrementErrorCount","flush","then","_a","undefined","resolve","error","GoogleError","wrapError","reject","docRef"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assert = require(\"assert\");\r\nconst _1 = require(\".\");\r\nconst util_1 = require(\"./util\");\r\nconst reference_1 = require(\"./reference\");\r\n/*!\r\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\r\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\r\n * negative numeric value expressed in that format.\r\n *\r\n * This constant is used to specify startAt/endAt values when querying for all\r\n * descendants in a single collection.\r\n */\r\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\r\n/*!\r\n * The query limit used for recursive deletes when fetching all descendants of\r\n * the specified reference to delete. This is done to prevent the query stream\r\n * from streaming documents faster than Firestore can delete.\r\n */\r\n// Visible for testing.\r\nexports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;\r\n/*!\r\n * The number of pending BulkWriter operations at which RecursiveDelete\r\n * starts the next limit query to fetch descendants. By starting the query\r\n * while there are pending operations, Firestore can improve BulkWriter\r\n * throughput. This helps prevent BulkWriter from idling while Firestore\r\n * fetches the next query.\r\n */\r\nexports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;\r\n/**\r\n * Class used to store state required for running a recursive delete operation.\r\n * Each recursive delete call should use a new instance of the class.\r\n * @private\r\n */\r\nclass RecursiveDelete {\r\n    /**\r\n     *\r\n     * @param firestore The Firestore instance to use.\r\n     * @param writer The BulkWriter instance to use for delete operations.\r\n     * @param ref The document or collection reference to recursively delete.\r\n     * @param maxLimit The query limit to use when fetching descendants\r\n     * @param minLimit The number of pending BulkWriter operations at which\r\n     * RecursiveDelete starts the next limit query to fetch descendants.\r\n     */\r\n    constructor(firestore, writer, ref, maxLimit, minLimit) {\r\n        this.firestore = firestore;\r\n        this.writer = writer;\r\n        this.ref = ref;\r\n        this.maxLimit = maxLimit;\r\n        this.minLimit = minLimit;\r\n        /**\r\n         * The number of deletes that failed with a permanent error.\r\n         * @private\r\n         */\r\n        this.errorCount = 0;\r\n        /**\r\n         * Whether there are still documents to delete that still need to be fetched.\r\n         * @private\r\n         */\r\n        this.documentsPending = true;\r\n        /**\r\n         * Whether run() has been called.\r\n         * @private\r\n         */\r\n        this.started = false;\r\n        /**\r\n         * A deferred promise that resolves when the recursive delete operation\r\n         * is completed.\r\n         * @private\r\n         */\r\n        this.completionDeferred = new util_1.Deferred();\r\n        /**\r\n         * Whether a query stream is currently in progress. Only one stream can be\r\n         * run at a time.\r\n         * @private\r\n         */\r\n        this.streamInProgress = false;\r\n        /**\r\n         * The number of pending BulkWriter operations. Used to determine when the\r\n         * next query can be run.\r\n         * @private\r\n         */\r\n        this.pendingOpsCount = 0;\r\n        this.errorStack = '';\r\n        this.maxPendingOps = maxLimit;\r\n        this.minPendingOps = minLimit;\r\n    }\r\n    /**\r\n     * Recursively deletes the reference provided in the class constructor.\r\n     * Returns a promise that resolves when all descendants have been deleted, or\r\n     * if an error occurs.\r\n     */\r\n    run() {\r\n        assert(!this.started, 'RecursiveDelete.run() should only be called once.');\r\n        // Capture the error stack to preserve stack tracing across async calls.\r\n        this.errorStack = Error().stack;\r\n        this.writer._verifyNotClosed();\r\n        this.setupStream();\r\n        return this.completionDeferred.promise;\r\n    }\r\n    /**\r\n     * Creates a query stream and attaches event handlers to it.\r\n     * @private\r\n     */\r\n    setupStream() {\r\n        const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference\r\n            ? this.ref\r\n            : this.ref);\r\n        this.streamInProgress = true;\r\n        let streamedDocsCount = 0;\r\n        stream\r\n            .on('error', err => {\r\n            err.code = 14 /* UNAVAILABLE */;\r\n            err.stack = 'Failed to fetch children documents: ' + err.stack;\r\n            this.lastError = err;\r\n            this.onQueryEnd();\r\n        })\r\n            .on('data', (snap) => {\r\n            streamedDocsCount++;\r\n            this.lastDocumentSnap = snap;\r\n            this.deleteRef(snap.ref);\r\n        })\r\n            .on('end', () => {\r\n            this.streamInProgress = false;\r\n            // If there are fewer than the number of documents specified in the\r\n            // limit() field, we know that the query is complete.\r\n            if (streamedDocsCount < this.minPendingOps) {\r\n                this.onQueryEnd();\r\n            }\r\n            else if (this.pendingOpsCount === 0) {\r\n                this.setupStream();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Retrieves all descendant documents nested under the provided reference.\r\n     * @param ref The reference to fetch all descendants for.\r\n     * @private\r\n     * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\r\n     */\r\n    getAllDescendants(ref) {\r\n        // The parent is the closest ancestor document to the location we're\r\n        // deleting. If we are deleting a document, the parent is the path of that\r\n        // document. If we are deleting a collection, the parent is the path of the\r\n        // document containing that collection (or the database root, if it is a\r\n        // root collection).\r\n        let parentPath = ref._resourcePath;\r\n        if (ref instanceof _1.CollectionReference) {\r\n            parentPath = parentPath.popLast();\r\n        }\r\n        const collectionId = ref instanceof _1.CollectionReference\r\n            ? ref.id\r\n            : ref.parent.id;\r\n        let query = new _1.Query(this.firestore, reference_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId, \r\n        /* requireConsistency= */ false));\r\n        // Query for names only to fetch empty snapshots.\r\n        query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);\r\n        if (ref instanceof _1.CollectionReference) {\r\n            // To find all descendants of a collection reference, we need to use a\r\n            // composite filter that captures all documents that start with the\r\n            // collection prefix. The MIN_KEY constant represents the minimum key in\r\n            // this collection, and a null byte + the MIN_KEY represents the minimum\r\n            // key is the next possible collection.\r\n            const nullChar = String.fromCharCode(0);\r\n            const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\r\n            const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\r\n            query = query\r\n                .where(_1.FieldPath.documentId(), '>=', startAt)\r\n                .where(_1.FieldPath.documentId(), '<', endAt);\r\n        }\r\n        if (this.lastDocumentSnap) {\r\n            query = query.startAfter(this.lastDocumentSnap);\r\n        }\r\n        return query.stream();\r\n    }\r\n    /**\r\n     * Called when all descendants of the provided reference have been streamed\r\n     * or if a permanent error occurs during the stream. Deletes the developer\r\n     * provided reference and wraps any errors that occurred.\r\n     * @private\r\n     */\r\n    onQueryEnd() {\r\n        this.documentsPending = false;\r\n        if (this.ref instanceof _1.DocumentReference) {\r\n            this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));\r\n        }\r\n        this.writer.flush().then(async () => {\r\n            var _a;\r\n            if (this.lastError === undefined) {\r\n                this.completionDeferred.resolve();\r\n            }\r\n            else {\r\n                let error = new (require('google-gax').GoogleError)(`${this.errorCount} ` +\r\n                    `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` +\r\n                    'failed. The last delete failed with: ');\r\n                if (this.lastError.code !== undefined) {\r\n                    error.code = this.lastError.code;\r\n                }\r\n                error = util_1.wrapError(error, this.errorStack);\r\n                // Wrap the BulkWriter error last to provide the full stack trace.\r\n                this.completionDeferred.reject(this.lastError.stack\r\n                    ? util_1.wrapError(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '')\r\n                    : error);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Deletes the provided reference and starts the next stream if conditions\r\n     * are met.\r\n     * @private\r\n     */\r\n    deleteRef(docRef) {\r\n        this.pendingOpsCount++;\r\n        this.writer\r\n            .delete(docRef)\r\n            .catch(err => {\r\n            this.incrementErrorCount(err);\r\n        })\r\n            .then(() => {\r\n            this.pendingOpsCount--;\r\n            // We wait until the previous stream has ended in order to sure the\r\n            // startAfter document is correct. Starting the next stream while\r\n            // there are pending operations allows Firestore to maximize\r\n            // BulkWriter throughput.\r\n            if (this.documentsPending &&\r\n                !this.streamInProgress &&\r\n                this.pendingOpsCount < this.minPendingOps) {\r\n                this.setupStream();\r\n            }\r\n        });\r\n    }\r\n    incrementErrorCount(err) {\r\n        this.errorCount++;\r\n        this.lastError = err;\r\n    }\r\n}\r\nexports.RecursiveDelete = RecursiveDelete;\r\n//# sourceMappingURL=recursive-delete.js.map"]},"metadata":{},"sourceType":"script"}