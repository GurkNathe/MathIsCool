{"ast":null,"code":"const {\n  EOL\n} = require('os');\n\nconst base64url = require('../help/base64url');\n\nconst isDisjoint = require('../help/is_disjoint');\n\nconst isObject = require('../help/is_object');\n\nlet validateCrit = require('../help/validate_crit');\n\nconst getKey = require('../help/get_key');\n\nconst {\n  KeyStore\n} = require('../jwks');\n\nconst errors = require('../errors');\n\nconst {\n  check,\n  verify\n} = require('../jwa');\n\nconst JWK = require('../jwk');\n\nconst {\n  detect: resolveSerialization\n} = require('./serializers');\n\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid);\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed']);\n/*\r\n * @public\r\n */\n\nconst jwsVerify = (skipDisjointCheck, serialization, jws, key, {\n  crit = [],\n  complete = false,\n  algorithms\n} = {}) => {\n  key = getKey(key, true);\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings');\n  } else if (algorithms) {\n    algorithms = new Set(algorithms);\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jws);\n  }\n\n  let prot; // protected header\n\n  let header; // unprotected header\n\n  let payload;\n  let signature;\n  let alg; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened';\n    const {\n      signatures,\n      ...root\n    } = jws;\n    jws = { ...root,\n      ...signatures[0]\n    };\n  }\n\n  let decoded;\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    let parsedProt = {};\n\n    switch (serialization) {\n      case 'compact':\n        // compact serialization format\n        [prot, payload, signature] = jws.split('.');\n        break;\n\n      case 'flattened':\n        // flattened serialization format\n        ({\n          protected: prot,\n          payload,\n          signature,\n          header\n        } = jws);\n        break;\n\n      case 'preparsed':\n        {\n          // from the JWT module\n          ({\n            decoded\n          } = jws);\n          [prot, payload, signature] = jws.token.split('.');\n          break;\n        }\n    }\n\n    if (!header) {\n      skipDisjointCheck = true;\n    }\n\n    if (decoded) {\n      parsedProt = decoded.header;\n    } else if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot);\n      } catch (err) {\n        throw new errors.JWSInvalid('could not parse JWS protected header');\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true;\n    }\n\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    const combinedHeader = { ...parsedProt,\n      ...header\n    };\n    validateCrit(parsedProt, header, crit);\n    alg = parsedProt.alg || header && header.alg;\n\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm');\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key;\n      const keys = keystore.all({\n        kid: combinedHeader.kid,\n        alg: combinedHeader.alg,\n        key_ops: ['verify']\n      });\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            const errs = [];\n\n            for (const key of keys) {\n              try {\n                return jwsVerify(true, serialization, jws, key, {\n                  crit,\n                  complete,\n                  algorithms: algorithms ? [...algorithms] : undefined\n                });\n              } catch (err) {\n                errs.push(err);\n                continue;\n              }\n            }\n\n            const multi = new errors.JOSEMultiError(errs);\n\n            if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n              throw new errors.JWSVerificationFailed();\n            }\n\n            throw multi;\n          }\n      }\n    }\n\n    if (key === JWK.EmbeddedJWK) {\n      if (!isObject(combinedHeader.jwk)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object');\n      }\n\n      key = JWK.asKey(combinedHeader.jwk);\n\n      if (key.type !== 'public') {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key');\n      }\n    } else if (key === JWK.EmbeddedX5C) {\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(c => typeof c !== 'string' || !c)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings');\n      }\n\n      key = JWK.asKey(`-----BEGIN CERTIFICATE-----${EOL}${(combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END CERTIFICATE-----`, {\n        x5c: combinedHeader.x5c\n      });\n    }\n\n    check(key, 'verify', alg);\n    const toBeVerified = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.isBuffer(payload) ? payload : Buffer.from(payload)]);\n\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed();\n    }\n\n    if (combinedHeader.b64 === false) {\n      payload = Buffer.from(payload);\n    } else {\n      payload = base64url.decodeToBuffer(payload);\n    }\n\n    if (complete) {\n      const result = {\n        payload,\n        key\n      };\n      if (prot) result.protected = parsedProt;\n      if (header) result.header = header;\n      return result;\n    }\n\n    return payload;\n  } // general serialization format\n\n\n  const {\n    signatures,\n    ...root\n  } = jws;\n  const errs = [];\n\n  for (const recipient of signatures) {\n    try {\n      return jwsVerify(false, 'flattened', { ...root,\n        ...recipient\n      }, key, {\n        crit,\n        complete,\n        algorithms: algorithms ? [...algorithms] : undefined\n      });\n    } catch (err) {\n      errs.push(err);\n      continue;\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs);\n\n  if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n    throw new errors.JWSVerificationFailed();\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = {\n  bare: jwsVerify,\n  verify: jwsVerify.bind(undefined, false, undefined)\n};","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/jose/lib/jws/verify.js"],"names":["EOL","require","base64url","isDisjoint","isObject","validateCrit","getKey","KeyStore","errors","check","verify","JWK","detect","resolveSerialization","bind","undefined","JWSInvalid","SINGLE_RECIPIENT","Set","jwsVerify","skipDisjointCheck","serialization","jws","key","crit","complete","algorithms","Array","isArray","some","s","TypeError","prot","header","payload","signature","alg","signatures","length","root","decoded","has","parsedProt","split","protected","token","JSON","decode","err","combinedHeader","JOSEAlgNotWhitelisted","keystore","keys","all","kid","key_ops","JWKSNoMatchingKey","errs","push","multi","JOSEMultiError","e","JWSVerificationFailed","EmbeddedJWK","jwk","asKey","type","EmbeddedX5C","x5c","c","match","join","toBeVerified","Buffer","concat","from","isBuffer","decodeToBuffer","b64","result","recipient","every","module","exports","bare"],"mappings":"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","sourcesContent":["const { EOL } = require('os')\r\n\r\nconst base64url = require('../help/base64url')\r\nconst isDisjoint = require('../help/is_disjoint')\r\nconst isObject = require('../help/is_object')\r\nlet validateCrit = require('../help/validate_crit')\r\nconst getKey = require('../help/get_key')\r\nconst { KeyStore } = require('../jwks')\r\nconst errors = require('../errors')\r\nconst { check, verify } = require('../jwa')\r\nconst JWK = require('../jwk')\r\n\r\nconst { detect: resolveSerialization } = require('./serializers')\r\n\r\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid)\r\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed'])\r\n\r\n/*\r\n * @public\r\n */\r\nconst jwsVerify = (skipDisjointCheck, serialization, jws, key, { crit = [], complete = false, algorithms } = {}) => {\r\n  key = getKey(key, true)\r\n\r\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\r\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings')\r\n  } else if (algorithms) {\r\n    algorithms = new Set(algorithms)\r\n  }\r\n\r\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\r\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\r\n  }\r\n\r\n  if (!serialization) {\r\n    serialization = resolveSerialization(jws)\r\n  }\r\n\r\n  let prot // protected header\r\n  let header // unprotected header\r\n  let payload\r\n  let signature\r\n  let alg\r\n\r\n  // treat general format with one recipient as flattened\r\n  // skips iteration and avoids multi errors in this case\r\n  if (serialization === 'general' && jws.signatures.length === 1) {\r\n    serialization = 'flattened'\r\n    const { signatures, ...root } = jws\r\n    jws = { ...root, ...signatures[0] }\r\n  }\r\n\r\n  let decoded\r\n\r\n  if (SINGLE_RECIPIENT.has(serialization)) {\r\n    let parsedProt = {}\r\n\r\n    switch (serialization) {\r\n      case 'compact': // compact serialization format\r\n        ([prot, payload, signature] = jws.split('.'))\r\n        break\r\n      case 'flattened': // flattened serialization format\r\n        ({ protected: prot, payload, signature, header } = jws)\r\n        break\r\n      case 'preparsed': { // from the JWT module\r\n        ({ decoded } = jws);\r\n        ([prot, payload, signature] = jws.token.split('.'))\r\n        break\r\n      }\r\n    }\r\n\r\n    if (!header) {\r\n      skipDisjointCheck = true\r\n    }\r\n\r\n    if (decoded) {\r\n      parsedProt = decoded.header\r\n    } else if (prot) {\r\n      try {\r\n        parsedProt = base64url.JSON.decode(prot)\r\n      } catch (err) {\r\n        throw new errors.JWSInvalid('could not parse JWS protected header')\r\n      }\r\n    } else {\r\n      skipDisjointCheck = skipDisjointCheck || true\r\n    }\r\n\r\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\r\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')\r\n    }\r\n\r\n    const combinedHeader = { ...parsedProt, ...header }\r\n    validateCrit(parsedProt, header, crit)\r\n\r\n    alg = parsedProt.alg || (header && header.alg)\r\n    if (!alg) {\r\n      throw new errors.JWSInvalid('missing JWS signature algorithm')\r\n    } else if (algorithms && !algorithms.has(alg)) {\r\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted')\r\n    }\r\n\r\n    if (key instanceof KeyStore) {\r\n      const keystore = key\r\n      const keys = keystore.all({ kid: combinedHeader.kid, alg: combinedHeader.alg, key_ops: ['verify'] })\r\n      switch (keys.length) {\r\n        case 0:\r\n          throw new errors.JWKSNoMatchingKey()\r\n        case 1:\r\n          // treat the call as if a Key instance was passed in\r\n          // skips iteration and avoids multi errors in this case\r\n          key = keys[0]\r\n          break\r\n        default: {\r\n          const errs = []\r\n          for (const key of keys) {\r\n            try {\r\n              return jwsVerify(true, serialization, jws, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\r\n            } catch (err) {\r\n              errs.push(err)\r\n              continue\r\n            }\r\n          }\r\n\r\n          const multi = new errors.JOSEMultiError(errs)\r\n          if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\r\n            throw new errors.JWSVerificationFailed()\r\n          }\r\n          throw multi\r\n        }\r\n      }\r\n    }\r\n\r\n    if (key === JWK.EmbeddedJWK) {\r\n      if (!isObject(combinedHeader.jwk)) {\r\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object')\r\n      }\r\n      key = JWK.asKey(combinedHeader.jwk)\r\n      if (key.type !== 'public') {\r\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key')\r\n      }\r\n    } else if (key === JWK.EmbeddedX5C) {\r\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(c => typeof c !== 'string' || !c)) {\r\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings')\r\n      }\r\n      key = JWK.asKey(\r\n        `-----BEGIN CERTIFICATE-----${EOL}${(combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END CERTIFICATE-----`,\r\n        { x5c: combinedHeader.x5c }\r\n      )\r\n    }\r\n\r\n    check(key, 'verify', alg)\r\n\r\n    const toBeVerified = Buffer.concat([\r\n      Buffer.from(prot || ''),\r\n      Buffer.from('.'),\r\n      Buffer.isBuffer(payload) ? payload : Buffer.from(payload)\r\n    ])\r\n\r\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\r\n      throw new errors.JWSVerificationFailed()\r\n    }\r\n\r\n    if (combinedHeader.b64 === false) {\r\n      payload = Buffer.from(payload)\r\n    } else {\r\n      payload = base64url.decodeToBuffer(payload)\r\n    }\r\n\r\n    if (complete) {\r\n      const result = { payload, key }\r\n      if (prot) result.protected = parsedProt\r\n      if (header) result.header = header\r\n      return result\r\n    }\r\n\r\n    return payload\r\n  }\r\n\r\n  // general serialization format\r\n  const { signatures, ...root } = jws\r\n  const errs = []\r\n  for (const recipient of signatures) {\r\n    try {\r\n      return jwsVerify(false, 'flattened', { ...root, ...recipient }, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\r\n    } catch (err) {\r\n      errs.push(err)\r\n      continue\r\n    }\r\n  }\r\n\r\n  const multi = new errors.JOSEMultiError(errs)\r\n  if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\r\n    throw new errors.JWSVerificationFailed()\r\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\r\n    throw new errors.JWKSNoMatchingKey()\r\n  }\r\n  throw multi\r\n}\r\n\r\nmodule.exports = {\r\n  bare: jwsVerify,\r\n  verify: jwsVerify.bind(undefined, false, undefined)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}