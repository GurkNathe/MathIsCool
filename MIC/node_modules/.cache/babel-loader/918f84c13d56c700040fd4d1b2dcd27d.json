{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto_1 = require(\"crypto\");\n\nconst gapicConfig = require(\"./v1/firestore_client_config.json\");\n/**\r\n * A Promise implementation that supports deferred resolution.\r\n * @private\r\n */\n\n\nclass Deferred {\n  constructor() {\n    this.resolve = () => {};\n\n    this.reject = () => {};\n\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n\n}\n\nexports.Deferred = Deferred;\n/**\r\n * Generate a unique client-side identifier.\r\n *\r\n * Used for the creation of new documents.\r\n *\r\n * @private\r\n * @returns {string} A unique 20-character wide identifier.\r\n */\n\nfunction autoId() {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let autoId = '';\n\n  while (autoId.length < 20) {\n    const bytes = crypto_1.randomBytes(40);\n    bytes.forEach(b => {\n      // Length of `chars` is 62. We only take bytes between 0 and 62*4-1\n      // (both inclusive). The value is then evenly mapped to indices of `char`\n      // via a modulo operation.\n      const maxValue = 62 * 4 - 1;\n\n      if (autoId.length < 20 && b <= maxValue) {\n        autoId += chars.charAt(b % 62);\n      }\n    });\n  }\n\n  return autoId;\n}\n\nexports.autoId = autoId;\n/**\r\n * Generate a short and semi-random client-side identifier.\r\n *\r\n * Used for the creation of request tags.\r\n *\r\n * @private\r\n * @returns {string} A random 5-character wide identifier.\r\n */\n\nfunction requestTag() {\n  return autoId().substr(0, 5);\n}\n\nexports.requestTag = requestTag;\n/**\r\n * Determines whether `value` is a JavaScript object.\r\n *\r\n * @private\r\n */\n\nfunction isObject(value) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexports.isObject = isObject;\n/**\r\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\r\n * 'Map' in Firestore.\r\n *\r\n * @private\r\n * @param input The argument to verify.\r\n * @returns 'true' if the input can be a treated as a plain object.\r\n */\n\nfunction isPlainObject(input) {\n  return isObject(input) && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null || input.constructor.name === 'Object');\n}\n\nexports.isPlainObject = isPlainObject;\n/**\r\n * Returns whether `value` has no custom properties.\r\n *\r\n * @private\r\n */\n\nfunction isEmpty(value) {\n  return Object.keys(value).length === 0;\n}\n\nexports.isEmpty = isEmpty;\n/**\r\n * Determines whether `value` is a JavaScript function.\r\n *\r\n * @private\r\n */\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nexports.isFunction = isFunction;\n/**\r\n * Determines whether the provided error is considered permanent for the given\r\n * RPC.\r\n *\r\n * @private\r\n */\n\nfunction isPermanentRpcError(err, methodName) {\n  if (err.code !== undefined) {\n    const retryCodes = getRetryCodes(methodName);\n    return retryCodes.indexOf(err.code) === -1;\n  } else {\n    return false;\n  }\n}\n\nexports.isPermanentRpcError = isPermanentRpcError;\nlet serviceConfig;\n/** Lazy-loads the service config when first accessed. */\n\nfunction getServiceConfig(methodName) {\n  if (!serviceConfig) {\n    serviceConfig = require('google-gax').constructSettings('google.firestore.v1.Firestore', gapicConfig, {}, require('google-gax').Status);\n  }\n\n  return serviceConfig[methodName];\n}\n/**\r\n * Returns the list of retryable error codes specified in the service\r\n * configuration.\r\n * @private\r\n */\n\n\nfunction getRetryCodes(methodName) {\n  var _a, _b, _c;\n\n  return (_c = (_b = (_a = getServiceConfig(methodName)) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.retryCodes) !== null && _c !== void 0 ? _c : [];\n}\n\nexports.getRetryCodes = getRetryCodes;\n/**\r\n * Returns the backoff setting from the service configuration.\r\n * @private\r\n */\n\nfunction getRetryParams(methodName) {\n  var _a, _b, _c;\n\n  return (_c = (_b = (_a = getServiceConfig(methodName)) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.backoffSettings) !== null && _c !== void 0 ? _c : require('google-gax').createDefaultBackoffSettings();\n}\n\nexports.getRetryParams = getRetryParams;\n/**\r\n * Returns a promise with a void return type. The returned promise swallows all\r\n * errors and never throws.\r\n *\r\n * This is primarily used to wait for a promise to complete when the result of\r\n * the promise will be discarded.\r\n *\r\n * @private\r\n */\n\nfunction silencePromise(promise) {\n  return promise.then(() => {}, () => {});\n}\n\nexports.silencePromise = silencePromise;\n/**\r\n * Wraps the provided error in a new error that includes the provided stack.\r\n *\r\n * Used to preserve stack traces across async calls.\r\n * @private\r\n */\n\nfunction wrapError(err, stack) {\n  err.stack += '\\nCaused by: ' + stack;\n  return err;\n}\n\nexports.wrapError = wrapError;","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/@google-cloud/firestore/build/src/util.js"],"names":["Object","defineProperty","exports","value","crypto_1","require","gapicConfig","Deferred","constructor","resolve","reject","promise","Promise","autoId","chars","length","bytes","randomBytes","forEach","b","maxValue","charAt","requestTag","substr","isObject","prototype","toString","call","isPlainObject","input","getPrototypeOf","name","isEmpty","keys","isFunction","isPermanentRpcError","err","methodName","code","undefined","retryCodes","getRetryCodes","indexOf","serviceConfig","getServiceConfig","constructSettings","Status","_a","_b","_c","retry","getRetryParams","backoffSettings","createDefaultBackoffSettings","silencePromise","then","wrapError","stack"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2018 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst crypto_1 = require(\"crypto\");\r\nconst gapicConfig = require(\"./v1/firestore_client_config.json\");\r\n/**\r\n * A Promise implementation that supports deferred resolution.\r\n * @private\r\n */\r\nclass Deferred {\r\n    constructor() {\r\n        this.resolve = () => { };\r\n        this.reject = () => { };\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n}\r\nexports.Deferred = Deferred;\r\n/**\r\n * Generate a unique client-side identifier.\r\n *\r\n * Used for the creation of new documents.\r\n *\r\n * @private\r\n * @returns {string} A unique 20-character wide identifier.\r\n */\r\nfunction autoId() {\r\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n    let autoId = '';\r\n    while (autoId.length < 20) {\r\n        const bytes = crypto_1.randomBytes(40);\r\n        bytes.forEach(b => {\r\n            // Length of `chars` is 62. We only take bytes between 0 and 62*4-1\r\n            // (both inclusive). The value is then evenly mapped to indices of `char`\r\n            // via a modulo operation.\r\n            const maxValue = 62 * 4 - 1;\r\n            if (autoId.length < 20 && b <= maxValue) {\r\n                autoId += chars.charAt(b % 62);\r\n            }\r\n        });\r\n    }\r\n    return autoId;\r\n}\r\nexports.autoId = autoId;\r\n/**\r\n * Generate a short and semi-random client-side identifier.\r\n *\r\n * Used for the creation of request tags.\r\n *\r\n * @private\r\n * @returns {string} A random 5-character wide identifier.\r\n */\r\nfunction requestTag() {\r\n    return autoId().substr(0, 5);\r\n}\r\nexports.requestTag = requestTag;\r\n/**\r\n * Determines whether `value` is a JavaScript object.\r\n *\r\n * @private\r\n */\r\nfunction isObject(value) {\r\n    return Object.prototype.toString.call(value) === '[object Object]';\r\n}\r\nexports.isObject = isObject;\r\n/**\r\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\r\n * 'Map' in Firestore.\r\n *\r\n * @private\r\n * @param input The argument to verify.\r\n * @returns 'true' if the input can be a treated as a plain object.\r\n */\r\nfunction isPlainObject(input) {\r\n    return (isObject(input) &&\r\n        (Object.getPrototypeOf(input) === Object.prototype ||\r\n            Object.getPrototypeOf(input) === null ||\r\n            input.constructor.name === 'Object'));\r\n}\r\nexports.isPlainObject = isPlainObject;\r\n/**\r\n * Returns whether `value` has no custom properties.\r\n *\r\n * @private\r\n */\r\nfunction isEmpty(value) {\r\n    return Object.keys(value).length === 0;\r\n}\r\nexports.isEmpty = isEmpty;\r\n/**\r\n * Determines whether `value` is a JavaScript function.\r\n *\r\n * @private\r\n */\r\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.isFunction = isFunction;\r\n/**\r\n * Determines whether the provided error is considered permanent for the given\r\n * RPC.\r\n *\r\n * @private\r\n */\r\nfunction isPermanentRpcError(err, methodName) {\r\n    if (err.code !== undefined) {\r\n        const retryCodes = getRetryCodes(methodName);\r\n        return retryCodes.indexOf(err.code) === -1;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nexports.isPermanentRpcError = isPermanentRpcError;\r\nlet serviceConfig;\r\n/** Lazy-loads the service config when first accessed. */\r\nfunction getServiceConfig(methodName) {\r\n    if (!serviceConfig) {\r\n        serviceConfig = require('google-gax').constructSettings('google.firestore.v1.Firestore', gapicConfig, {}, require('google-gax').Status);\r\n    }\r\n    return serviceConfig[methodName];\r\n}\r\n/**\r\n * Returns the list of retryable error codes specified in the service\r\n * configuration.\r\n * @private\r\n */\r\nfunction getRetryCodes(methodName) {\r\n    var _a, _b, _c;\r\n    return (_c = (_b = (_a = getServiceConfig(methodName)) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.retryCodes) !== null && _c !== void 0 ? _c : [];\r\n}\r\nexports.getRetryCodes = getRetryCodes;\r\n/**\r\n * Returns the backoff setting from the service configuration.\r\n * @private\r\n */\r\nfunction getRetryParams(methodName) {\r\n    var _a, _b, _c;\r\n    return ((_c = (_b = (_a = getServiceConfig(methodName)) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.backoffSettings) !== null && _c !== void 0 ? _c : require('google-gax').createDefaultBackoffSettings());\r\n}\r\nexports.getRetryParams = getRetryParams;\r\n/**\r\n * Returns a promise with a void return type. The returned promise swallows all\r\n * errors and never throws.\r\n *\r\n * This is primarily used to wait for a promise to complete when the result of\r\n * the promise will be discarded.\r\n *\r\n * @private\r\n */\r\nfunction silencePromise(promise) {\r\n    return promise.then(() => { }, () => { });\r\n}\r\nexports.silencePromise = silencePromise;\r\n/**\r\n * Wraps the provided error in a new error that includes the provided stack.\r\n *\r\n * Used to preserve stack traces across async calls.\r\n * @private\r\n */\r\nfunction wrapError(err, stack) {\r\n    err.stack += '\\nCaused by: ' + stack;\r\n    return err;\r\n}\r\nexports.wrapError = wrapError;\r\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}