{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url_1 = require(\"url\");\n\nconst util_1 = require(\"./util\");\n\nconst timestamp_1 = require(\"./timestamp\");\n/**\r\n * Generates an error message to use with custom objects that cannot be\r\n * serialized.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The value that failed serialization.\r\n * @param path The field path that the object is assigned to.\r\n */\n\n\nfunction customObjectMessage(arg, value, path) {\n  const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\n\n  if (util_1.isObject(value)) {\n    // We use the base class name as the type name as the sentinel classes\n    // returned by the public FieldValue API are subclasses of FieldValue. By\n    // using the base name, we reduce the number of special cases below.\n    const typeName = value.constructor.name;\n\n    switch (typeName) {\n      case 'DocumentReference':\n      case 'FieldPath':\n      case 'FieldValue':\n      case 'GeoPoint':\n      case 'Timestamp':\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type \"${typeName}\" that doesn't match the ` + `expected instance${fieldPathMessage}. Please ensure that the ` + 'Firestore types you are using are from the same NPM package.)';\n\n      case 'Object':\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type \"${typeof value}\" as a Firestore argument${fieldPathMessage}.`;\n\n      default:\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type \"${typeName}\"${fieldPathMessage}. Firestore doesn't support JavaScript ` + 'objects with custom prototypes (i.e. objects that were created ' + 'via the \"new\" operator).';\n    }\n  } else {\n    return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;\n  }\n}\n\nexports.customObjectMessage = customObjectMessage;\n/**\r\n * Validates that 'value' is a function.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the function can be omitted.\r\n */\n\nfunction validateFunction(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (!util_1.isFunction(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'function'));\n    }\n  }\n}\n\nexports.validateFunction = validateFunction;\n/**\r\n * Validates that 'value' is an object.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the object can be omitted.\r\n */\n\nfunction validateObject(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'object'));\n    }\n  }\n}\n\nexports.validateObject = validateObject;\n/**\r\n * Validates that 'value' is a string.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the string can be omitted.\r\n */\n\nfunction validateString(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'string') {\n      throw new Error(invalidArgumentMessage(arg, 'string'));\n    }\n  }\n}\n\nexports.validateString = validateString;\n/**\r\n * Validates that 'value' is a host.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the host can be omitted.\r\n */\n\nfunction validateHost(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    validateString(arg, value);\n    const urlString = `http://${value}/`;\n    let parsed;\n\n    try {\n      parsed = new url_1.URL(urlString);\n    } catch (e) {\n      throw new Error(invalidArgumentMessage(arg, 'host'));\n    }\n\n    if (parsed.search !== '' || parsed.pathname !== '/' || parsed.username !== '') {\n      throw new Error(invalidArgumentMessage(arg, 'host'));\n    }\n  }\n}\n\nexports.validateHost = validateHost;\n/**\r\n * Validates that 'value' is a boolean.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the boolean can be omitted.\r\n */\n\nfunction validateBoolean(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'boolean') {\n      throw new Error(invalidArgumentMessage(arg, 'boolean'));\n    }\n  }\n}\n\nexports.validateBoolean = validateBoolean;\n/**\r\n * Validates that 'value' is a number.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the number can be omitted.\r\n */\n\nfunction validateNumber(arg, value, options) {\n  const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;\n  const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;\n\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'number' || isNaN(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'number'));\n    } else if (value < min || value > max) {\n      throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n    }\n  }\n}\n\nexports.validateNumber = validateNumber;\n/**\r\n * Validates that 'value' is a integer.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the integer can be omitted.\r\n */\n\nfunction validateInteger(arg, value, options) {\n  const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;\n  const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;\n\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {\n      throw new Error(invalidArgumentMessage(arg, 'integer'));\n    } else if (value < min || value > max) {\n      throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n    }\n  }\n}\n\nexports.validateInteger = validateInteger;\n/**\r\n * Validates that 'value' is a Timestamp.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the Timestamp can be omitted.\r\n */\n\nfunction validateTimestamp(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (!(value instanceof timestamp_1.Timestamp)) {\n      throw new Error(invalidArgumentMessage(arg, 'Timestamp'));\n    }\n  }\n}\n\nexports.validateTimestamp = validateTimestamp;\n/**\r\n * Generates an error message to use with invalid arguments.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param expectedType The expected input type.\r\n */\n\nfunction invalidArgumentMessage(arg, expectedType) {\n  return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;\n}\n\nexports.invalidArgumentMessage = invalidArgumentMessage;\n/**\r\n * Enforces the 'options.optional' constraint for 'value'.\r\n *\r\n * @private\r\n * @param value The input to validate.\r\n * @param options Whether the function can be omitted.\r\n * @return Whether the object is omitted and is allowed to be omitted.\r\n */\n\nfunction validateOptional(value, options) {\n  return value === undefined && options !== undefined && options.optional === true;\n}\n\nexports.validateOptional = validateOptional;\n/**\r\n * Formats the given word as plural conditionally given the preceding number.\r\n *\r\n * @private\r\n * @param num The number to use for formatting.\r\n * @param str The string to format.\r\n */\n\nfunction formatPlural(num, str) {\n  return `${num} ${str}` + (num === 1 ? '' : 's');\n}\n/**\r\n * Creates a descriptive name for the provided argument name or index.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @return Either the argument name or its index description.\r\n */\n\n\nfunction formatArgumentName(arg) {\n  return typeof arg === 'string' ? `Value for argument \"${arg}\"` : `Element at index ${arg}`;\n}\n/**\r\n * Verifies that 'args' has at least 'minSize' elements.\r\n *\r\n * @private\r\n * @param funcName The function name to use in the error message.\r\n * @param args The array (or array-like structure) to verify.\r\n * @param minSize The minimum number of elements to enforce.\r\n * @throws if the expectation is not met.\r\n */\n\n\nfunction validateMinNumberOfArguments(funcName, args, minSize) {\n  if (args.length < minSize) {\n    throw new Error(`Function \"${funcName}()\" requires at least ` + `${formatPlural(minSize, 'argument')}.`);\n  }\n}\n\nexports.validateMinNumberOfArguments = validateMinNumberOfArguments;\n/**\r\n * Verifies that 'args' has at most 'maxSize' elements.\r\n *\r\n * @private\r\n * @param funcName The function name to use in the error message.\r\n * @param args The array (or array-like structure) to verify.\r\n * @param maxSize The maximum number of elements to enforce.\r\n * @throws if the expectation is not met.\r\n */\n\nfunction validateMaxNumberOfArguments(funcName, args, maxSize) {\n  if (args.length > maxSize) {\n    throw new Error(`Function \"${funcName}()\" accepts at most ` + `${formatPlural(maxSize, 'argument')}.`);\n  }\n}\n\nexports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;\n/**\r\n * Validates that the provided named option equals one of the expected values.\r\n *\r\n * @param arg The argument name or argument index (for varargs methods).).\r\n * @param value The input to validate.\r\n * @param allowedValues A list of expected values.\r\n * @param options Whether the input can be omitted.\r\n * @private\r\n */\n\nfunction validateEnumValue(arg, value, allowedValues, options) {\n  if (!validateOptional(value, options)) {\n    const expectedDescription = [];\n\n    for (const allowed of allowedValues) {\n      if (allowed === value) {\n        return;\n      }\n\n      expectedDescription.push(allowed);\n    }\n\n    throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);\n  }\n}\n\nexports.validateEnumValue = validateEnumValue;","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/@google-cloud/firestore/build/src/validate.js"],"names":["Object","defineProperty","exports","value","url_1","require","util_1","timestamp_1","customObjectMessage","arg","path","fieldPathMessage","isObject","typeName","constructor","name","invalidArgumentMessage","validateFunction","options","validateOptional","isFunction","Error","validateObject","validateString","validateHost","urlString","parsed","URL","e","search","pathname","username","validateBoolean","validateNumber","min","undefined","minValue","Infinity","max","maxValue","isNaN","formatArgumentName","validateInteger","validateTimestamp","Timestamp","expectedType","optional","formatPlural","num","str","validateMinNumberOfArguments","funcName","args","minSize","length","validateMaxNumberOfArguments","maxSize","validateEnumValue","allowedValues","expectedDescription","allowed","push","join"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2017 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst url_1 = require(\"url\");\r\nconst util_1 = require(\"./util\");\r\nconst timestamp_1 = require(\"./timestamp\");\r\n/**\r\n * Generates an error message to use with custom objects that cannot be\r\n * serialized.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The value that failed serialization.\r\n * @param path The field path that the object is assigned to.\r\n */\r\nfunction customObjectMessage(arg, value, path) {\r\n    const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\r\n    if (util_1.isObject(value)) {\r\n        // We use the base class name as the type name as the sentinel classes\r\n        // returned by the public FieldValue API are subclasses of FieldValue. By\r\n        // using the base name, we reduce the number of special cases below.\r\n        const typeName = value.constructor.name;\r\n        switch (typeName) {\r\n            case 'DocumentReference':\r\n            case 'FieldPath':\r\n            case 'FieldValue':\r\n            case 'GeoPoint':\r\n            case 'Timestamp':\r\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type \"${typeName}\" that doesn't match the ` +\r\n                    `expected instance${fieldPathMessage}. Please ensure that the ` +\r\n                    'Firestore types you are using are from the same NPM package.)');\r\n            case 'Object':\r\n                return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type \"${typeof value}\" as a Firestore argument${fieldPathMessage}.`;\r\n            default:\r\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type \"${typeName}\"${fieldPathMessage}. Firestore doesn't support JavaScript ` +\r\n                    'objects with custom prototypes (i.e. objects that were created ' +\r\n                    'via the \"new\" operator).');\r\n        }\r\n    }\r\n    else {\r\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;\r\n    }\r\n}\r\nexports.customObjectMessage = customObjectMessage;\r\n/**\r\n * Validates that 'value' is a function.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the function can be omitted.\r\n */\r\nfunction validateFunction(arg, value, options) {\r\n    if (!validateOptional(value, options)) {\r\n        if (!util_1.isFunction(value)) {\r\n            throw new Error(invalidArgumentMessage(arg, 'function'));\r\n        }\r\n    }\r\n}\r\nexports.validateFunction = validateFunction;\r\n/**\r\n * Validates that 'value' is an object.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the object can be omitted.\r\n */\r\nfunction validateObject(arg, value, options) {\r\n    if (!validateOptional(value, options)) {\r\n        if (!util_1.isObject(value)) {\r\n            throw new Error(invalidArgumentMessage(arg, 'object'));\r\n        }\r\n    }\r\n}\r\nexports.validateObject = validateObject;\r\n/**\r\n * Validates that 'value' is a string.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the string can be omitted.\r\n */\r\nfunction validateString(arg, value, options) {\r\n    if (!validateOptional(value, options)) {\r\n        if (typeof value !== 'string') {\r\n            throw new Error(invalidArgumentMessage(arg, 'string'));\r\n        }\r\n    }\r\n}\r\nexports.validateString = validateString;\r\n/**\r\n * Validates that 'value' is a host.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the host can be omitted.\r\n */\r\nfunction validateHost(arg, value, options) {\r\n    if (!validateOptional(value, options)) {\r\n        validateString(arg, value);\r\n        const urlString = `http://${value}/`;\r\n        let parsed;\r\n        try {\r\n            parsed = new url_1.URL(urlString);\r\n        }\r\n        catch (e) {\r\n            throw new Error(invalidArgumentMessage(arg, 'host'));\r\n        }\r\n        if (parsed.search !== '' ||\r\n            parsed.pathname !== '/' ||\r\n            parsed.username !== '') {\r\n            throw new Error(invalidArgumentMessage(arg, 'host'));\r\n        }\r\n    }\r\n}\r\nexports.validateHost = validateHost;\r\n/**\r\n * Validates that 'value' is a boolean.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the boolean can be omitted.\r\n */\r\nfunction validateBoolean(arg, value, options) {\r\n    if (!validateOptional(value, options)) {\r\n        if (typeof value !== 'boolean') {\r\n            throw new Error(invalidArgumentMessage(arg, 'boolean'));\r\n        }\r\n    }\r\n}\r\nexports.validateBoolean = validateBoolean;\r\n/**\r\n * Validates that 'value' is a number.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the number can be omitted.\r\n */\r\nfunction validateNumber(arg, value, options) {\r\n    const min = options !== undefined && options.minValue !== undefined\r\n        ? options.minValue\r\n        : -Infinity;\r\n    const max = options !== undefined && options.maxValue !== undefined\r\n        ? options.maxValue\r\n        : Infinity;\r\n    if (!validateOptional(value, options)) {\r\n        if (typeof value !== 'number' || isNaN(value)) {\r\n            throw new Error(invalidArgumentMessage(arg, 'number'));\r\n        }\r\n        else if (value < min || value > max) {\r\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\r\n        }\r\n    }\r\n}\r\nexports.validateNumber = validateNumber;\r\n/**\r\n * Validates that 'value' is a integer.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the integer can be omitted.\r\n */\r\nfunction validateInteger(arg, value, options) {\r\n    const min = options !== undefined && options.minValue !== undefined\r\n        ? options.minValue\r\n        : -Infinity;\r\n    const max = options !== undefined && options.maxValue !== undefined\r\n        ? options.maxValue\r\n        : Infinity;\r\n    if (!validateOptional(value, options)) {\r\n        if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {\r\n            throw new Error(invalidArgumentMessage(arg, 'integer'));\r\n        }\r\n        else if (value < min || value > max) {\r\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\r\n        }\r\n    }\r\n}\r\nexports.validateInteger = validateInteger;\r\n/**\r\n * Validates that 'value' is a Timestamp.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param value The input to validate.\r\n * @param options Options that specify whether the Timestamp can be omitted.\r\n */\r\nfunction validateTimestamp(arg, value, options) {\r\n    if (!validateOptional(value, options)) {\r\n        if (!(value instanceof timestamp_1.Timestamp)) {\r\n            throw new Error(invalidArgumentMessage(arg, 'Timestamp'));\r\n        }\r\n    }\r\n}\r\nexports.validateTimestamp = validateTimestamp;\r\n/**\r\n * Generates an error message to use with invalid arguments.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @param expectedType The expected input type.\r\n */\r\nfunction invalidArgumentMessage(arg, expectedType) {\r\n    return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;\r\n}\r\nexports.invalidArgumentMessage = invalidArgumentMessage;\r\n/**\r\n * Enforces the 'options.optional' constraint for 'value'.\r\n *\r\n * @private\r\n * @param value The input to validate.\r\n * @param options Whether the function can be omitted.\r\n * @return Whether the object is omitted and is allowed to be omitted.\r\n */\r\nfunction validateOptional(value, options) {\r\n    return (value === undefined && options !== undefined && options.optional === true);\r\n}\r\nexports.validateOptional = validateOptional;\r\n/**\r\n * Formats the given word as plural conditionally given the preceding number.\r\n *\r\n * @private\r\n * @param num The number to use for formatting.\r\n * @param str The string to format.\r\n */\r\nfunction formatPlural(num, str) {\r\n    return `${num} ${str}` + (num === 1 ? '' : 's');\r\n}\r\n/**\r\n * Creates a descriptive name for the provided argument name or index.\r\n *\r\n * @private\r\n * @param arg The argument name or argument index (for varargs methods).\r\n * @return Either the argument name or its index description.\r\n */\r\nfunction formatArgumentName(arg) {\r\n    return typeof arg === 'string'\r\n        ? `Value for argument \"${arg}\"`\r\n        : `Element at index ${arg}`;\r\n}\r\n/**\r\n * Verifies that 'args' has at least 'minSize' elements.\r\n *\r\n * @private\r\n * @param funcName The function name to use in the error message.\r\n * @param args The array (or array-like structure) to verify.\r\n * @param minSize The minimum number of elements to enforce.\r\n * @throws if the expectation is not met.\r\n */\r\nfunction validateMinNumberOfArguments(funcName, args, minSize) {\r\n    if (args.length < minSize) {\r\n        throw new Error(`Function \"${funcName}()\" requires at least ` +\r\n            `${formatPlural(minSize, 'argument')}.`);\r\n    }\r\n}\r\nexports.validateMinNumberOfArguments = validateMinNumberOfArguments;\r\n/**\r\n * Verifies that 'args' has at most 'maxSize' elements.\r\n *\r\n * @private\r\n * @param funcName The function name to use in the error message.\r\n * @param args The array (or array-like structure) to verify.\r\n * @param maxSize The maximum number of elements to enforce.\r\n * @throws if the expectation is not met.\r\n */\r\nfunction validateMaxNumberOfArguments(funcName, args, maxSize) {\r\n    if (args.length > maxSize) {\r\n        throw new Error(`Function \"${funcName}()\" accepts at most ` +\r\n            `${formatPlural(maxSize, 'argument')}.`);\r\n    }\r\n}\r\nexports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;\r\n/**\r\n * Validates that the provided named option equals one of the expected values.\r\n *\r\n * @param arg The argument name or argument index (for varargs methods).).\r\n * @param value The input to validate.\r\n * @param allowedValues A list of expected values.\r\n * @param options Whether the input can be omitted.\r\n * @private\r\n */\r\nfunction validateEnumValue(arg, value, allowedValues, options) {\r\n    if (!validateOptional(value, options)) {\r\n        const expectedDescription = [];\r\n        for (const allowed of allowedValues) {\r\n            if (allowed === value) {\r\n                return;\r\n            }\r\n            expectedDescription.push(allowed);\r\n        }\r\n        throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);\r\n    }\r\n}\r\nexports.validateEnumValue = validateEnumValue;\r\n//# sourceMappingURL=validate.js.map"]},"metadata":{},"sourceType":"script"}