{"ast":null,"code":"/*! firebase-admin v9.10.0 */\n\"use strict\";\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Auth = exports.TenantAwareAuth = exports.BaseAuth = void 0;\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar user_record_1 = require(\"./user-record\");\n\nvar identifier_1 = require(\"./identifier\");\n\nvar token_generator_1 = require(\"./token-generator\");\n\nvar auth_api_request_1 = require(\"./auth-api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar utils = require(\"../utils/index\");\n\nvar validator = require(\"../utils/validator\");\n\nvar token_verifier_1 = require(\"./token-verifier\");\n\nvar auth_config_1 = require(\"./auth-config\");\n\nvar tenant_manager_1 = require(\"./tenant-manager\");\n\nvar crypto_signer_1 = require(\"../utils/crypto-signer\");\n/**\r\n * Base Auth class. Mainly used for user management APIs.\r\n */\n\n\nvar BaseAuth =\n/** @class */\nfunction () {\n  /**\r\n   * The BaseAuth class constructor.\r\n   *\r\n   * @param app The FirebaseApp to associate with this Auth instance.\r\n   * @param authRequestHandler The RPC request handler for this instance.\r\n   * @param tokenGenerator Optional token generator. If not specified, a\r\n   *     (non-tenant-aware) instance will be created. Use this paramter to\r\n   *     specify a tenant-aware tokenGenerator.\r\n   * @constructor\r\n   */\n  function BaseAuth(app, authRequestHandler, tokenGenerator) {\n    this.authRequestHandler = authRequestHandler;\n\n    if (tokenGenerator) {\n      this.tokenGenerator = tokenGenerator;\n    } else {\n      this.tokenGenerator = createFirebaseTokenGenerator(app);\n    }\n\n    this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(app);\n    this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(app);\n  }\n  /**\r\n   * Creates a new custom token that can be sent back to a client to use with\r\n   * signInWithCustomToken().\r\n   *\r\n   * @param {string} uid The uid to use as the JWT subject.\r\n   * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\r\n   *\r\n   * @return {Promise<string>} A JWT for the provided payload.\r\n   */\n\n\n  BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n    return this.tokenGenerator.createCustomToken(uid, developerClaims);\n  };\n  /**\r\n   * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\r\n   * the promise if the token could not be verified. If checkRevoked is set to true,\r\n   * verifies if the session corresponding to the ID token was revoked. If the corresponding\r\n   * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\r\n   * the check is not applied.\r\n   *\r\n   * @param {string} idToken The JWT to verify.\r\n   * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\r\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n   *     verification.\r\n   */\n\n\n  BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    var isEmulator = auth_api_request_1.useEmulator();\n    return this.idTokenVerifier.verifyJWT(idToken, isEmulator).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n      }\n\n      return decodedIdToken;\n    });\n  };\n  /**\r\n   * Looks up the user identified by the provided user id and returns a promise that is\r\n   * fulfilled with a user record for the given user if that user is found.\r\n   *\r\n   * @param {string} uid The uid of the user to look up.\r\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\r\n   */\n\n\n  BaseAuth.prototype.getUser = function (uid) {\n    return this.authRequestHandler.getAccountInfoByUid(uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\r\n   * Looks up the user identified by the provided email and returns a promise that is\r\n   * fulfilled with a user record for the given user if that user is found.\r\n   *\r\n   * @param {string} email The email of the user to look up.\r\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\r\n   */\n\n\n  BaseAuth.prototype.getUserByEmail = function (email) {\n    return this.authRequestHandler.getAccountInfoByEmail(email).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\r\n   * Looks up the user identified by the provided phone number and returns a promise that is\r\n   * fulfilled with a user record for the given user if that user is found.\r\n   *\r\n   * @param {string} phoneNumber The phone number of the user to look up.\r\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\r\n   */\n\n\n  BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n    return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\r\n   * Gets the user data for the user corresponding to a given provider id.\r\n   *\r\n   * See [Retrieve user data](/docs/auth/admin/manage-users#retrieve_user_data)\r\n   * for code samples and detailed documentation.\r\n   *\r\n   * @param providerId The provider ID, for example, \"google.com\" for the\r\n   *   Google provider.\r\n   * @param uid The user identifier for the given provider.\r\n   *\r\n   * @return A promise fulfilled with the user data corresponding to the\r\n   *   given provider id.\r\n   */\n\n\n  BaseAuth.prototype.getUserByProviderUid = function (providerId, uid) {\n    // Although we don't really advertise it, we want to also handle\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // reroute this request appropriately.\n    if (providerId === 'phone') {\n      return this.getUserByPhoneNumber(uid);\n    } else if (providerId === 'email') {\n      return this.getUserByEmail(uid);\n    }\n\n    return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\r\n   * Gets the user data corresponding to the specified identifiers.\r\n   *\r\n   * There are no ordering guarantees; in particular, the nth entry in the result list is not\r\n   * guaranteed to correspond to the nth entry in the input parameters list.\r\n   *\r\n   * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\r\n   * this method will immediately throw a FirebaseAuthError.\r\n   *\r\n   * @param identifiers The identifiers used to indicate which user records should be returned. Must\r\n   *     have <= 100 entries.\r\n   * @return {Promise<GetUsersResult>} A promise that resolves to the corresponding user records.\r\n   * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\r\n   *     identifiers are specified.\r\n   */\n\n\n  BaseAuth.prototype.getUsers = function (identifiers) {\n    if (!validator.isArray(identifiers)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n    }\n\n    return this.authRequestHandler.getAccountInfoByIdentifiers(identifiers).then(function (response) {\n      /**\r\n       * Checks if the specified identifier is within the list of\r\n       * UserRecords.\r\n       */\n      var isUserFound = function (id, userRecords) {\n        return !!userRecords.find(function (userRecord) {\n          if (identifier_1.isUidIdentifier(id)) {\n            return id.uid === userRecord.uid;\n          } else if (identifier_1.isEmailIdentifier(id)) {\n            return id.email === userRecord.email;\n          } else if (identifier_1.isPhoneIdentifier(id)) {\n            return id.phoneNumber === userRecord.phoneNumber;\n          } else if (identifier_1.isProviderIdentifier(id)) {\n            var matchingUserInfo = userRecord.providerData.find(function (userInfo) {\n              return id.providerId === userInfo.providerId;\n            });\n            return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n          } else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n          }\n        });\n      };\n\n      var users = response.users ? response.users.map(function (user) {\n        return new user_record_1.UserRecord(user);\n      }) : [];\n      var notFound = identifiers.filter(function (id) {\n        return !isUserFound(id, users);\n      });\n      return {\n        users: users,\n        notFound: notFound\n      };\n    });\n  };\n  /**\r\n   * Exports a batch of user accounts. Batch size is determined by the maxResults argument.\r\n   * Starting point of the batch is determined by the pageToken argument.\r\n   *\r\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\r\n   *     allowed limit.\r\n   * @param {string=} pageToken The next page token. If not specified, returns users starting\r\n   *     without any offset.\r\n   * @return {Promise<{users: UserRecord[], pageToken?: string}>} A promise that resolves with\r\n   *     the current batch of downloaded users and the next page token. For the last page, an\r\n   *     empty list of users and no page token are returned.\r\n   */\n\n\n  BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n    return this.authRequestHandler.downloadAccount(maxResults, pageToken).then(function (response) {\n      // List of users to return.\n      var users = []; // Convert each user response to a UserRecord.\n\n      response.users.forEach(function (userResponse) {\n        users.push(new user_record_1.UserRecord(userResponse));\n      }); // Return list of user records and the next page token if available.\n\n      var result = {\n        users: users,\n        pageToken: response.nextPageToken\n      }; // Delete result.pageToken if undefined.\n\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n\n      return result;\n    });\n  };\n  /**\r\n   * Creates a new user with the properties provided.\r\n   *\r\n   * @param {CreateRequest} properties The properties to set on the new user record to be created.\r\n   * @return {Promise<UserRecord>} A promise that resolves with the newly created user record.\r\n   */\n\n\n  BaseAuth.prototype.createUser = function (properties) {\n    var _this = this;\n\n    return this.authRequestHandler.createNewAccount(properties).then(function (uid) {\n      // Return the corresponding user record.\n      return _this.getUser(uid);\n    }).catch(function (error) {\n      if (error.code === 'auth/user-not-found') {\n        // Something must have happened after creating the user and then retrieving it.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n      }\n\n      throw error;\n    });\n  };\n  /**\r\n   * Deletes the user identified by the provided user id and returns a promise that is\r\n   * fulfilled when the user is found and successfully deleted.\r\n   *\r\n   * @param {string} uid The uid of the user to delete.\r\n   * @return {Promise<void>} A promise that resolves when the user is successfully deleted.\r\n   */\n\n\n  BaseAuth.prototype.deleteUser = function (uid) {\n    return this.authRequestHandler.deleteAccount(uid).then(function () {// Return nothing on success.\n    });\n  };\n\n  BaseAuth.prototype.deleteUsers = function (uids) {\n    if (!validator.isArray(uids)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n    }\n\n    return this.authRequestHandler.deleteAccounts(uids,\n    /*force=*/\n    true).then(function (batchDeleteAccountsResponse) {\n      var result = {\n        failureCount: 0,\n        successCount: uids.length,\n        errors: []\n      };\n\n      if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n        return result;\n      }\n\n      result.failureCount = batchDeleteAccountsResponse.errors.length;\n      result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n      result.errors = batchDeleteAccountsResponse.errors.map(function (batchDeleteErrorInfo) {\n        if (batchDeleteErrorInfo.index === undefined) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n        }\n\n        var errMsgToError = function (msg) {\n          // We unconditionally set force=true, so the 'NOT_DISABLED' error\n          // should not be possible.\n          var code = msg && msg.startsWith('NOT_DISABLED') ? error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n          return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n        };\n\n        return {\n          index: batchDeleteErrorInfo.index,\n          error: errMsgToError(batchDeleteErrorInfo.message)\n        };\n      });\n      return result;\n    });\n  };\n  /**\r\n   * Updates an existing user with the properties provided.\r\n   *\r\n   * @param {string} uid The uid identifier of the user to update.\r\n   * @param {UpdateRequest} properties The properties to update on the existing user.\r\n   * @return {Promise<UserRecord>} A promise that resolves with the modified user record.\r\n   */\n\n\n  BaseAuth.prototype.updateUser = function (uid, properties) {\n    var _this = this; // Although we don't really advertise it, we want to also handle linking of\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // adjust the properties parameter appropriately. This *does* imply that a\n    // conflict could arise, e.g. if the user provides a phoneNumber property,\n    // but also provides a providerToLink with a 'phone' provider id. In that\n    // case, we'll throw an error.\n\n\n    properties = deep_copy_1.deepCopy(properties);\n\n    if (properties === null || properties === void 0 ? void 0 : properties.providerToLink) {\n      if (properties.providerToLink.providerId === 'email') {\n        if (typeof properties.email !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \" + 'link to the email/password provider, only specify the UpdateRequest.email field.');\n        }\n\n        properties.email = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      } else if (properties.providerToLink.providerId === 'phone') {\n        if (typeof properties.phoneNumber !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \" + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\n        }\n\n        properties.phoneNumber = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      }\n    }\n\n    if (properties === null || properties === void 0 ? void 0 : properties.providersToUnlink) {\n      if (properties.providersToUnlink.indexOf('phone') !== -1) {\n        // If we've been told to unlink the phone provider both via setting\n        // phoneNumber to null *and* by setting providersToUnlink to include\n        // 'phone', then we'll reject that. Though it might also be reasonable\n        // to relax this restriction and just unlink it.\n        if (properties.phoneNumber === null) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \" + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\n        }\n      }\n    }\n\n    return this.authRequestHandler.updateExistingAccount(uid, properties).then(function (existingUid) {\n      // Return the corresponding user record.\n      return _this.getUser(existingUid);\n    });\n  };\n  /**\r\n   * Sets additional developer claims on an existing user identified by the provided UID.\r\n   *\r\n   * @param {string} uid The user to edit.\r\n   * @param {object} customUserClaims The developer claims to set.\r\n   * @return {Promise<void>} A promise that resolves when the operation completes\r\n   *     successfully.\r\n   */\n\n\n  BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(function () {// Return nothing on success.\n    });\n  };\n  /**\r\n   * Revokes all refresh tokens for the specified user identified by the provided UID.\r\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued before\r\n   * revocation will also be revoked on the Auth backend. Any request with an ID token\r\n   * generated before revocation will be rejected with a token expired error.\r\n   *\r\n   * @param {string} uid The user whose tokens are to be revoked.\r\n   * @return {Promise<void>} A promise that resolves when the operation completes\r\n   *     successfully.\r\n   */\n\n\n  BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n    return this.authRequestHandler.revokeRefreshTokens(uid).then(function () {// Return nothing on success.\n    });\n  };\n  /**\r\n   * Imports the list of users provided to Firebase Auth. This is useful when\r\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n   * At most, 1000 users are allowed to be imported one at a time.\r\n   * When importing a list of password users, UserImportOptions are required to be specified.\r\n   *\r\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\r\n   * @param {UserImportOptions=} options The user import options, required when the users provided\r\n   *     include password credentials.\r\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\r\n   *     with the result of the import. This includes the number of successful imports, the number\r\n   *     of failed uploads and their corresponding errors.\r\n   */\n\n\n  BaseAuth.prototype.importUsers = function (users, options) {\n    return this.authRequestHandler.uploadAccount(users, options);\n  };\n  /**\r\n   * Creates a new Firebase session cookie with the specified options that can be used for\r\n   * session management (set as a server side session cookie with custom cookie policy).\r\n   * The session cookie JWT will have the same payload claims as the provided ID token.\r\n   *\r\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\r\n   * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\r\n   *     custom session duration.\r\n   *\r\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\r\n   */\n\n\n  BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    // Return rejected promise if expiresIn is not available.\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n\n    return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n  };\n  /**\r\n   * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\r\n   * the promise if the token could not be verified. If checkRevoked is set to true,\r\n   * verifies if the session corresponding to the session cookie was revoked. If the corresponding\r\n   * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\r\n   * specified the check is not performed.\r\n   *\r\n   * @param {string} sessionCookie The session cookie to verify.\r\n   * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\r\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n   *     verification.\r\n   */\n\n\n  BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    var isEmulator = auth_api_request_1.useEmulator();\n    return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n      }\n\n      return decodedIdToken;\n    });\n  };\n  /**\r\n   * Generates the out of band email action link for password reset flows for the\r\n   * email specified using the action code settings provided.\r\n   * Returns a promise that resolves with the generated link.\r\n   *\r\n   * @param {string} email The email of the user whose password is to be reset.\r\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\r\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n   *     deep link, etc.\r\n   * @return {Promise<string>} A promise that resolves with the password reset link.\r\n   */\n\n\n  BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n  };\n  /**\r\n   * Generates the out of band email action link for email verification flows for the\r\n   * email specified using the action code settings provided.\r\n   * Returns a promise that resolves with the generated link.\r\n   *\r\n   * @param {string} email The email of the user to be verified.\r\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\r\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n   *     deep link, etc.\r\n   * @return {Promise<string>} A promise that resolves with the email verification link.\r\n   */\n\n\n  BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n  };\n  /**\r\n   * Generates the out of band email action link for email link sign-in flows for the\r\n   * email specified using the action code settings provided.\r\n   * Returns a promise that resolves with the generated link.\r\n   *\r\n   * @param {string} email The email of the user signing in.\r\n   * @param {ActionCodeSettings} actionCodeSettings The required action code setings which defines whether\r\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n   *     deep link, etc.\r\n   * @return {Promise<string>} A promise that resolves with the email sign-in link.\r\n   */\n\n\n  BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n  };\n  /**\r\n   * Returns the list of existing provider configuation matching the filter provided.\r\n   * At most, 100 provider configs are allowed to be imported at a time.\r\n   *\r\n   * @param {AuthProviderConfigFilter} options The provider config filter to apply.\r\n   * @return {Promise<ListProviderConfigResults>} A promise that resolves with the list of provider configs\r\n   *     meeting the filter requirements.\r\n   */\n\n\n  BaseAuth.prototype.listProviderConfigs = function (options) {\n    var processResponse = function (response, providerConfigs) {\n      // Return list of provider configuration and the next page token if available.\n      var result = {\n        providerConfigs: providerConfigs\n      }; // Delete result.pageToken if undefined.\n\n      if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n        result.pageToken = response.nextPageToken;\n      }\n\n      return result;\n    };\n\n    if (options && options.type === 'oidc') {\n      return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a OIDCConfig.\n\n        response.oauthIdpConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    } else if (options && options.type === 'saml') {\n      return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a SAMLConfig.\n\n        response.inboundSamlConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\n  };\n  /**\r\n   * Looks up an Auth provider configuration by ID.\r\n   * Returns a promise that resolves with the provider configuration corresponding to the provider ID specified.\r\n   *\r\n   * @param {string} providerId  The provider ID corresponding to the provider config to return.\r\n   * @return {Promise<AuthProviderConfig>}\r\n   */\n\n\n  BaseAuth.prototype.getProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getOAuthIdpConfig(providerId).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getInboundSamlConfig(providerId).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\r\n   * Deletes the provider configuration corresponding to the provider ID passed.\r\n   *\r\n   * @param {string} providerId The provider ID corresponding to the provider config to delete.\r\n   * @return {Promise<void>} A promise that resolves on completion.\r\n   */\n\n\n  BaseAuth.prototype.deleteProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\r\n   * Returns a promise that resolves with the updated AuthProviderConfig when the provider configuration corresponding\r\n   * to the provider ID specified is updated with the specified configuration.\r\n   *\r\n   * @param {string} providerId The provider ID corresponding to the provider config to update.\r\n   * @param {UpdateAuthProviderRequest} updatedConfig The updated configuration.\r\n   * @return {Promise<AuthProviderConfig>} A promise that resolves with the updated provider configuration.\r\n   */\n\n\n  BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\n    if (!validator.isNonNullObject(updatedConfig)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\r\n   * Returns a promise that resolves with the newly created AuthProviderConfig when the new provider configuration is\r\n   * created.\r\n   * @param {AuthProviderConfig} config The provider configuration to create.\r\n   * @return {Promise<AuthProviderConfig>} A promise that resolves with the created provider configuration.\r\n   */\n\n\n  BaseAuth.prototype.createProviderConfig = function (config) {\n    if (!validator.isNonNullObject(config)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createOAuthIdpConfig(config).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createInboundSamlConfig(config).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\r\n   * Verifies the decoded Firebase issued JWT is not revoked. Returns a promise that resolves\r\n   * with the decoded claims on success. Rejects the promise with revocation error if revoked.\r\n   *\r\n   * @param {DecodedIdToken} decodedIdToken The JWT's decoded claims.\r\n   * @param {ErrorInfo} revocationErrorInfo The revocation error info to throw on revocation\r\n   *     detection.\r\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n   *     verification.\r\n   */\n\n\n  BaseAuth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {\n    // Get tokens valid after time for the corresponding user.\n    return this.getUser(decodedIdToken.sub).then(function (user) {\n      // If no tokens valid after time available, token is not revoked.\n      if (user.tokensValidAfterTime) {\n        // Get the ID token authentication time and convert to milliseconds UTC.\n        var authTimeUtc = decodedIdToken.auth_time * 1000; // Get user tokens valid after time in milliseconds UTC.\n\n        var validSinceUtc = new Date(user.tokensValidAfterTime).getTime(); // Check if authentication time is older than valid since time.\n\n        if (authTimeUtc < validSinceUtc) {\n          throw new error_1.FirebaseAuthError(revocationErrorInfo);\n        }\n      } // All checks above passed. Return the decoded token.\n\n\n      return decodedIdToken;\n    });\n  };\n\n  return BaseAuth;\n}();\n\nexports.BaseAuth = BaseAuth;\n/**\r\n * The tenant aware Auth class.\r\n */\n\nvar TenantAwareAuth =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuth, _super);\n  /**\r\n   * The TenantAwareAuth class constructor.\r\n   *\r\n   * @param {object} app The app that created this tenant.\r\n   * @param tenantId The corresponding tenant ID.\r\n   * @constructor\r\n   */\n\n\n  function TenantAwareAuth(app, tenantId) {\n    var _this = _super.call(this, app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), createFirebaseTokenGenerator(app, tenantId)) || this;\n\n    utils.addReadonlyGetter(_this, 'tenantId', tenantId);\n    return _this;\n  }\n  /**\r\n   * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\r\n   * the promise if the token could not be verified. If checkRevoked is set to true,\r\n   * verifies if the session corresponding to the ID token was revoked. If the corresponding\r\n   * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\r\n   * the check is not applied.\r\n   *\r\n   * @param {string} idToken The JWT to verify.\r\n   * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\r\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n   *     verification.\r\n   */\n\n\n  TenantAwareAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return _super.prototype.verifyIdToken.call(this, idToken, checkRevoked).then(function (decodedClaims) {\n      // Validate tenant ID.\n      if (decodedClaims.firebase.tenant !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n\n      return decodedClaims;\n    });\n  };\n  /**\r\n   * Creates a new Firebase session cookie with the specified options that can be used for\r\n   * session management (set as a server side session cookie with custom cookie policy).\r\n   * The session cookie JWT will have the same payload claims as the provided ID token.\r\n   *\r\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\r\n   * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\r\n   *     custom session duration.\r\n   *\r\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\r\n   */\n\n\n  TenantAwareAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    var _this = this; // Validate arguments before processing.\n\n\n    if (!validator.isNonEmptyString(idToken)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\n    }\n\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    } // This will verify the ID token and then match the tenant ID before creating the session cookie.\n\n\n    return this.verifyIdToken(idToken).then(function () {\n      return _super.prototype.createSessionCookie.call(_this, idToken, sessionCookieOptions);\n    });\n  };\n  /**\r\n   * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\r\n   * the promise if the token could not be verified. If checkRevoked is set to true,\r\n   * verifies if the session corresponding to the session cookie was revoked. If the corresponding\r\n   * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\r\n   * specified the check is not performed.\r\n   *\r\n   * @param {string} sessionCookie The session cookie to verify.\r\n   * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\r\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n   *     verification.\r\n   */\n\n\n  TenantAwareAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return _super.prototype.verifySessionCookie.call(this, sessionCookie, checkRevoked).then(function (decodedClaims) {\n      if (decodedClaims.firebase.tenant !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n\n      return decodedClaims;\n    });\n  };\n\n  return TenantAwareAuth;\n}(BaseAuth);\n\nexports.TenantAwareAuth = TenantAwareAuth;\n/**\r\n * Auth service bound to the provided app.\r\n * An Auth instance can have multiple tenants.\r\n */\n\nvar Auth =\n/** @class */\nfunction (_super) {\n  __extends(Auth, _super);\n  /**\r\n   * @param {object} app The app for this Auth service.\r\n   * @constructor\r\n   */\n\n\n  function Auth(app) {\n    var _this = _super.call(this, app, new auth_api_request_1.AuthRequestHandler(app)) || this;\n\n    _this.app_ = app;\n    _this.tenantManager_ = new tenant_manager_1.TenantManager(app);\n    return _this;\n  }\n\n  Object.defineProperty(Auth.prototype, \"app\", {\n    /**\r\n     * Returns the app associated with this Auth instance.\r\n     *\r\n     * @return {FirebaseApp} The app associated with this Auth instance.\r\n     */\n    get: function () {\n      return this.app_;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** @return The current Auth instance's tenant manager. */\n\n  Auth.prototype.tenantManager = function () {\n    return this.tenantManager_;\n  };\n\n  return Auth;\n}(BaseAuth);\n\nexports.Auth = Auth;\n\nfunction createFirebaseTokenGenerator(app, tenantId) {\n  try {\n    var signer = auth_api_request_1.useEmulator() ? new token_generator_1.EmulatedSigner() : crypto_signer_1.cryptoSignerFromApp(app);\n    return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\n  } catch (err) {\n    throw token_generator_1.handleCryptoSignerError(err);\n  }\n}","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/firebase-admin/lib/auth/auth.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","Auth","TenantAwareAuth","BaseAuth","deep_copy_1","require","user_record_1","identifier_1","token_generator_1","auth_api_request_1","error_1","utils","validator","token_verifier_1","auth_config_1","tenant_manager_1","crypto_signer_1","app","authRequestHandler","tokenGenerator","createFirebaseTokenGenerator","sessionCookieVerifier","createSessionCookieVerifier","idTokenVerifier","createIdTokenVerifier","createCustomToken","uid","developerClaims","verifyIdToken","idToken","checkRevoked","_this","isEmulator","useEmulator","verifyJWT","then","decodedIdToken","verifyDecodedJWTNotRevoked","AuthClientErrorCode","ID_TOKEN_REVOKED","getUser","getAccountInfoByUid","response","UserRecord","users","getUserByEmail","email","getAccountInfoByEmail","getUserByPhoneNumber","phoneNumber","getAccountInfoByPhoneNumber","getUserByProviderUid","providerId","getAccountInfoByFederatedUid","getUsers","identifiers","isArray","FirebaseAuthError","INVALID_ARGUMENT","getAccountInfoByIdentifiers","isUserFound","id","userRecords","find","userRecord","isUidIdentifier","isEmailIdentifier","isPhoneIdentifier","isProviderIdentifier","matchingUserInfo","providerData","userInfo","providerUid","INTERNAL_ERROR","map","user","notFound","filter","listUsers","maxResults","pageToken","downloadAccount","forEach","userResponse","push","result","nextPageToken","createUser","properties","createNewAccount","catch","error","code","deleteUser","deleteAccount","deleteUsers","uids","deleteAccounts","batchDeleteAccountsResponse","failureCount","successCount","length","errors","isNonEmptyArray","batchDeleteErrorInfo","index","undefined","errMsgToError","msg","startsWith","USER_NOT_DISABLED","message","updateUser","deepCopy","providerToLink","providersToUnlink","indexOf","updateExistingAccount","existingUid","setCustomUserClaims","customUserClaims","revokeRefreshTokens","importUsers","options","uploadAccount","createSessionCookie","sessionCookieOptions","isNonNullObject","isNumber","expiresIn","Promise","reject","INVALID_SESSION_COOKIE_DURATION","verifySessionCookie","sessionCookie","SESSION_COOKIE_REVOKED","generatePasswordResetLink","actionCodeSettings","getEmailActionLink","generateEmailVerificationLink","generateSignInWithEmailLink","listProviderConfigs","processResponse","providerConfigs","call","type","listOAuthIdpConfigs","oauthIdpConfigs","configResponse","OIDCConfig","listInboundSamlConfigs","inboundSamlConfigs","SAMLConfig","getProviderConfig","isProviderId","getOAuthIdpConfig","getInboundSamlConfig","INVALID_PROVIDER_ID","deleteProviderConfig","deleteOAuthIdpConfig","deleteInboundSamlConfig","updateProviderConfig","updatedConfig","INVALID_CONFIG","updateOAuthIdpConfig","updateInboundSamlConfig","createProviderConfig","config","createOAuthIdpConfig","createInboundSamlConfig","revocationErrorInfo","sub","tokensValidAfterTime","authTimeUtc","auth_time","validSinceUtc","Date","getTime","_super","tenantId","TenantAwareAuthRequestHandler","addReadonlyGetter","decodedClaims","firebase","tenant","MISMATCHING_TENANT_ID","isNonEmptyString","INVALID_ID_TOKEN","AuthRequestHandler","app_","tenantManager_","TenantManager","get","enumerable","configurable","tenantManager","signer","EmulatedSigner","cryptoSignerFromApp","FirebaseTokenGenerator","err","handleCryptoSignerError"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaAN,MAAM,CAACU,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,IAAR,GAAeF,OAAO,CAACG,eAAR,GAA0BH,OAAO,CAACI,QAAR,GAAmB,KAAK,CAAjE;;AACA,IAAIC,WAAW,GAAGC,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,eAAD,CAA3B;;AACA,IAAIE,YAAY,GAAGF,OAAO,CAAC,cAAD,CAA1B;;AACA,IAAIG,iBAAiB,GAAGH,OAAO,CAAC,mBAAD,CAA/B;;AACA,IAAII,kBAAkB,GAAGJ,OAAO,CAAC,oBAAD,CAAhC;;AACA,IAAIK,OAAO,GAAGL,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIM,KAAK,GAAGN,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIO,SAAS,GAAGP,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIQ,gBAAgB,GAAGR,OAAO,CAAC,kBAAD,CAA9B;;AACA,IAAIS,aAAa,GAAGT,OAAO,CAAC,eAAD,CAA3B;;AACA,IAAIU,gBAAgB,GAAGV,OAAO,CAAC,kBAAD,CAA9B;;AACA,IAAIW,eAAe,GAAGX,OAAO,CAAC,wBAAD,CAA7B;AACA;AACA;AACA;;;AACA,IAAIF,QAAQ;AAAG;AAAe,YAAY;AACtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,WAASA,QAAT,CAAkBc,GAAlB,EAAuBC,kBAAvB,EAA2CC,cAA3C,EAA2D;AACvD,SAAKD,kBAAL,GAA0BA,kBAA1B;;AACA,QAAIC,cAAJ,EAAoB;AAChB,WAAKA,cAAL,GAAsBA,cAAtB;AACH,KAFD,MAGK;AACD,WAAKA,cAAL,GAAsBC,4BAA4B,CAACH,GAAD,CAAlD;AACH;;AACD,SAAKI,qBAAL,GAA6BR,gBAAgB,CAACS,2BAAjB,CAA6CL,GAA7C,CAA7B;AACA,SAAKM,eAAL,GAAuBV,gBAAgB,CAACW,qBAAjB,CAAuCP,GAAvC,CAAvB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACId,EAAAA,QAAQ,CAACP,SAAT,CAAmB6B,iBAAnB,GAAuC,UAAUC,GAAV,EAAeC,eAAf,EAAgC;AACnE,WAAO,KAAKR,cAAL,CAAoBM,iBAApB,CAAsCC,GAAtC,EAA2CC,eAA3C,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIxB,EAAAA,QAAQ,CAACP,SAAT,CAAmBgC,aAAnB,GAAmC,UAAUC,OAAV,EAAmBC,YAAnB,EAAiC;AAChE,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAID,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,MAAAA,YAAY,GAAG,KAAf;AAAuB;;AACtD,QAAIE,UAAU,GAAGvB,kBAAkB,CAACwB,WAAnB,EAAjB;AACA,WAAO,KAAKV,eAAL,CAAqBW,SAArB,CAA+BL,OAA/B,EAAwCG,UAAxC,EACFG,IADE,CACG,UAAUC,cAAV,EAA0B;AAChC;AACA,UAAIN,YAAY,IAAIE,UAApB,EAAgC;AAC5B,eAAOD,KAAK,CAACM,0BAAN,CAAiCD,cAAjC,EAAiD1B,OAAO,CAAC4B,mBAAR,CAA4BC,gBAA7E,CAAP;AACH;;AACD,aAAOH,cAAP;AACH,KAPM,CAAP;AAQH,GAZD;AAaA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIjC,EAAAA,QAAQ,CAACP,SAAT,CAAmB4C,OAAnB,GAA6B,UAAUd,GAAV,EAAe;AACxC,WAAO,KAAKR,kBAAL,CAAwBuB,mBAAxB,CAA4Cf,GAA5C,EACFS,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAIpC,aAAa,CAACqC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIzC,EAAAA,QAAQ,CAACP,SAAT,CAAmBiD,cAAnB,GAAoC,UAAUC,KAAV,EAAiB;AACjD,WAAO,KAAK5B,kBAAL,CAAwB6B,qBAAxB,CAA8CD,KAA9C,EACFX,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAIpC,aAAa,CAACqC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIzC,EAAAA,QAAQ,CAACP,SAAT,CAAmBoD,oBAAnB,GAA0C,UAAUC,WAAV,EAAuB;AAC7D,WAAO,KAAK/B,kBAAL,CAAwBgC,2BAAxB,CAAoDD,WAApD,EACFd,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAIpC,aAAa,CAACqC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIzC,EAAAA,QAAQ,CAACP,SAAT,CAAmBuD,oBAAnB,GAA0C,UAAUC,UAAV,EAAsB1B,GAAtB,EAA2B;AACjE;AACA;AACA;AACA,QAAI0B,UAAU,KAAK,OAAnB,EAA4B;AACxB,aAAO,KAAKJ,oBAAL,CAA0BtB,GAA1B,CAAP;AACH,KAFD,MAGK,IAAI0B,UAAU,KAAK,OAAnB,EAA4B;AAC7B,aAAO,KAAKP,cAAL,CAAoBnB,GAApB,CAAP;AACH;;AACD,WAAO,KAAKR,kBAAL,CAAwBmC,4BAAxB,CAAqDD,UAArD,EAAiE1B,GAAjE,EACFS,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,aAAO,IAAIpC,aAAa,CAACqC,UAAlB,CAA6BD,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA7B,CAAP;AACH,KAJM,CAAP;AAKH,GAfD;AAgBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIzC,EAAAA,QAAQ,CAACP,SAAT,CAAmB0D,QAAnB,GAA8B,UAAUC,WAAV,EAAuB;AACjD,QAAI,CAAC3C,SAAS,CAAC4C,OAAV,CAAkBD,WAAlB,CAAL,EAAqC;AACjC,YAAM,IAAI7C,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BoB,gBAA1D,EAA4E,0CAA5E,CAAN;AACH;;AACD,WAAO,KAAKxC,kBAAL,CACFyC,2BADE,CAC0BJ,WAD1B,EAEFpB,IAFE,CAEG,UAAUO,QAAV,EAAoB;AAC1B;AACZ;AACA;AACA;AACY,UAAIkB,WAAW,GAAI,UAAUC,EAAV,EAAcC,WAAd,EAA2B;AAC1C,eAAO,CAAC,CAACA,WAAW,CAACC,IAAZ,CAAiB,UAAUC,UAAV,EAAsB;AAC5C,cAAIzD,YAAY,CAAC0D,eAAb,CAA6BJ,EAA7B,CAAJ,EAAsC;AAClC,mBAAOA,EAAE,CAACnC,GAAH,KAAWsC,UAAU,CAACtC,GAA7B;AACH,WAFD,MAGK,IAAInB,YAAY,CAAC2D,iBAAb,CAA+BL,EAA/B,CAAJ,EAAwC;AACzC,mBAAOA,EAAE,CAACf,KAAH,KAAakB,UAAU,CAAClB,KAA/B;AACH,WAFI,MAGA,IAAIvC,YAAY,CAAC4D,iBAAb,CAA+BN,EAA/B,CAAJ,EAAwC;AACzC,mBAAOA,EAAE,CAACZ,WAAH,KAAmBe,UAAU,CAACf,WAArC;AACH,WAFI,MAGA,IAAI1C,YAAY,CAAC6D,oBAAb,CAAkCP,EAAlC,CAAJ,EAA2C;AAC5C,gBAAIQ,gBAAgB,GAAGL,UAAU,CAACM,YAAX,CAAwBP,IAAxB,CAA6B,UAAUQ,QAAV,EAAoB;AACpE,qBAAOV,EAAE,CAACT,UAAH,KAAkBmB,QAAQ,CAACnB,UAAlC;AACH,aAFsB,CAAvB;AAGA,mBAAO,CAAC,CAACiB,gBAAF,IAAsBR,EAAE,CAACW,WAAH,KAAmBH,gBAAgB,CAAC3C,GAAjE;AACH,WALI,MAMA;AACD,kBAAM,IAAIhB,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BmC,cAA1D,EAA0E,2BAA1E,CAAN;AACH;AACJ,SAnBQ,CAAT;AAoBH,OArBD;;AAsBA,UAAI7B,KAAK,GAAGF,QAAQ,CAACE,KAAT,GAAiBF,QAAQ,CAACE,KAAT,CAAe8B,GAAf,CAAmB,UAAUC,IAAV,EAAgB;AAAE,eAAO,IAAIrE,aAAa,CAACqC,UAAlB,CAA6BgC,IAA7B,CAAP;AAA4C,OAAjF,CAAjB,GAAsG,EAAlH;AACA,UAAIC,QAAQ,GAAGrB,WAAW,CAACsB,MAAZ,CAAmB,UAAUhB,EAAV,EAAc;AAAE,eAAO,CAACD,WAAW,CAACC,EAAD,EAAKjB,KAAL,CAAnB;AAAiC,OAApE,CAAf;AACA,aAAO;AAAEA,QAAAA,KAAK,EAAEA,KAAT;AAAgBgC,QAAAA,QAAQ,EAAEA;AAA1B,OAAP;AACH,KAhCM,CAAP;AAiCH,GArCD;AAsCA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIzE,EAAAA,QAAQ,CAACP,SAAT,CAAmBkF,SAAnB,GAA+B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AAC5D,WAAO,KAAK9D,kBAAL,CAAwB+D,eAAxB,CAAwCF,UAAxC,EAAoDC,SAApD,EACF7C,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,UAAIE,KAAK,GAAG,EAAZ,CAF0B,CAG1B;;AACAF,MAAAA,QAAQ,CAACE,KAAT,CAAesC,OAAf,CAAuB,UAAUC,YAAV,EAAwB;AAC3CvC,QAAAA,KAAK,CAACwC,IAAN,CAAW,IAAI9E,aAAa,CAACqC,UAAlB,CAA6BwC,YAA7B,CAAX;AACH,OAFD,EAJ0B,CAO1B;;AACA,UAAIE,MAAM,GAAG;AACTzC,QAAAA,KAAK,EAAEA,KADE;AAEToC,QAAAA,SAAS,EAAEtC,QAAQ,CAAC4C;AAFX,OAAb,CAR0B,CAY1B;;AACA,UAAI,OAAOD,MAAM,CAACL,SAAd,KAA4B,WAAhC,EAA6C;AACzC,eAAOK,MAAM,CAACL,SAAd;AACH;;AACD,aAAOK,MAAP;AACH,KAlBM,CAAP;AAmBH,GApBD;AAqBA;AACJ;AACA;AACA;AACA;AACA;;;AACIlF,EAAAA,QAAQ,CAACP,SAAT,CAAmB2F,UAAnB,GAAgC,UAAUC,UAAV,EAAsB;AAClD,QAAIzD,KAAK,GAAG,IAAZ;;AACA,WAAO,KAAKb,kBAAL,CAAwBuE,gBAAxB,CAAyCD,UAAzC,EACFrD,IADE,CACG,UAAUT,GAAV,EAAe;AACrB;AACA,aAAOK,KAAK,CAACS,OAAN,CAAcd,GAAd,CAAP;AACH,KAJM,EAKFgE,KALE,CAKI,UAAUC,KAAV,EAAiB;AACxB,UAAIA,KAAK,CAACC,IAAN,KAAe,qBAAnB,EAA0C;AACtC;AACA,cAAM,IAAIlF,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BmC,cAA1D,EAA0E,4CAA1E,CAAN;AACH;;AACD,YAAMkB,KAAN;AACH,KAXM,CAAP;AAYH,GAdD;AAeA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIxF,EAAAA,QAAQ,CAACP,SAAT,CAAmBiG,UAAnB,GAAgC,UAAUnE,GAAV,EAAe;AAC3C,WAAO,KAAKR,kBAAL,CAAwB4E,aAAxB,CAAsCpE,GAAtC,EACFS,IADE,CACG,YAAY,CAClB;AACH,KAHM,CAAP;AAIH,GALD;;AAMAhC,EAAAA,QAAQ,CAACP,SAAT,CAAmBmG,WAAnB,GAAiC,UAAUC,IAAV,EAAgB;AAC7C,QAAI,CAACpF,SAAS,CAAC4C,OAAV,CAAkBwC,IAAlB,CAAL,EAA8B;AAC1B,YAAM,IAAItF,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BoB,gBAA1D,EAA4E,mCAA5E,CAAN;AACH;;AACD,WAAO,KAAKxC,kBAAL,CAAwB+E,cAAxB,CAAuCD,IAAvC;AAA6C;AAAW,QAAxD,EACF7D,IADE,CACG,UAAU+D,2BAAV,EAAuC;AAC7C,UAAIb,MAAM,GAAG;AACTc,QAAAA,YAAY,EAAE,CADL;AAETC,QAAAA,YAAY,EAAEJ,IAAI,CAACK,MAFV;AAGTC,QAAAA,MAAM,EAAE;AAHC,OAAb;;AAKA,UAAI,CAAC1F,SAAS,CAAC2F,eAAV,CAA0BL,2BAA2B,CAACI,MAAtD,CAAL,EAAoE;AAChE,eAAOjB,MAAP;AACH;;AACDA,MAAAA,MAAM,CAACc,YAAP,GAAsBD,2BAA2B,CAACI,MAA5B,CAAmCD,MAAzD;AACAhB,MAAAA,MAAM,CAACe,YAAP,GAAsBJ,IAAI,CAACK,MAAL,GAAcH,2BAA2B,CAACI,MAA5B,CAAmCD,MAAvE;AACAhB,MAAAA,MAAM,CAACiB,MAAP,GAAgBJ,2BAA2B,CAACI,MAA5B,CAAmC5B,GAAnC,CAAuC,UAAU8B,oBAAV,EAAgC;AACnF,YAAIA,oBAAoB,CAACC,KAArB,KAA+BC,SAAnC,EAA8C;AAC1C,gBAAM,IAAIhG,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BmC,cAA1D,EAA0E,8CAA1E,CAAN;AACH;;AACD,YAAIkC,aAAa,GAAG,UAAUC,GAAV,EAAe;AAC/B;AACA;AACA,cAAIhB,IAAI,GAAGgB,GAAG,IAAIA,GAAG,CAACC,UAAJ,CAAe,cAAf,CAAP,GACPnG,OAAO,CAAC4B,mBAAR,CAA4BwE,iBADrB,GACyCpG,OAAO,CAAC4B,mBAAR,CAA4BmC,cADhF;AAEA,iBAAO,IAAI/D,OAAO,CAAC+C,iBAAZ,CAA8BmC,IAA9B,EAAoCY,oBAAoB,CAACO,OAAzD,CAAP;AACH,SAND;;AAOA,eAAO;AACHN,UAAAA,KAAK,EAAED,oBAAoB,CAACC,KADzB;AAEHd,UAAAA,KAAK,EAAEgB,aAAa,CAACH,oBAAoB,CAACO,OAAtB;AAFjB,SAAP;AAIH,OAfe,CAAhB;AAgBA,aAAO1B,MAAP;AACH,KA7BM,CAAP;AA8BH,GAlCD;AAmCA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIlF,EAAAA,QAAQ,CAACP,SAAT,CAAmBoH,UAAnB,GAAgC,UAAUtF,GAAV,EAAe8D,UAAf,EAA2B;AACvD,QAAIzD,KAAK,GAAG,IAAZ,CADuD,CAEvD;AACA;AACA;AACA;AACA;AACA;;;AACAyD,IAAAA,UAAU,GAAGpF,WAAW,CAAC6G,QAAZ,CAAqBzB,UAArB,CAAb;;AACA,QAAIA,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAAC0B,cAAvE,EAAuF;AACnF,UAAI1B,UAAU,CAAC0B,cAAX,CAA0B9D,UAA1B,KAAyC,OAA7C,EAAsD;AAClD,YAAI,OAAOoC,UAAU,CAAC1C,KAAlB,KAA4B,WAAhC,EAA6C;AACzC,gBAAM,IAAIpC,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BoB,gBAA1D,EAA4E,+FAC5E,kFADA,CAAN;AAEH;;AACD8B,QAAAA,UAAU,CAAC1C,KAAX,GAAmB0C,UAAU,CAAC0B,cAAX,CAA0BxF,GAA7C;AACA,eAAO8D,UAAU,CAAC0B,cAAlB;AACH,OAPD,MAQK,IAAI1B,UAAU,CAAC0B,cAAX,CAA0B9D,UAA1B,KAAyC,OAA7C,EAAsD;AACvD,YAAI,OAAOoC,UAAU,CAACvC,WAAlB,KAAkC,WAAtC,EAAmD;AAC/C,gBAAM,IAAIvC,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BoB,gBAA1D,EAA4E,qGAC5E,6EADA,CAAN;AAEH;;AACD8B,QAAAA,UAAU,CAACvC,WAAX,GAAyBuC,UAAU,CAAC0B,cAAX,CAA0BxF,GAAnD;AACA,eAAO8D,UAAU,CAAC0B,cAAlB;AACH;AACJ;;AACD,QAAI1B,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAAC2B,iBAAvE,EAA0F;AACtF,UAAI3B,UAAU,CAAC2B,iBAAX,CAA6BC,OAA7B,CAAqC,OAArC,MAAkD,CAAC,CAAvD,EAA0D;AACtD;AACA;AACA;AACA;AACA,YAAI5B,UAAU,CAACvC,WAAX,KAA2B,IAA/B,EAAqC;AACjC,gBAAM,IAAIvC,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BoB,gBAA1D,EAA4E,oGAC5E,sFADA,CAAN;AAEH;AACJ;AACJ;;AACD,WAAO,KAAKxC,kBAAL,CAAwBmG,qBAAxB,CAA8C3F,GAA9C,EAAmD8D,UAAnD,EACFrD,IADE,CACG,UAAUmF,WAAV,EAAuB;AAC7B;AACA,aAAOvF,KAAK,CAACS,OAAN,CAAc8E,WAAd,CAAP;AACH,KAJM,CAAP;AAKH,GA5CD;AA6CA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACInH,EAAAA,QAAQ,CAACP,SAAT,CAAmB2H,mBAAnB,GAAyC,UAAU7F,GAAV,EAAe8F,gBAAf,EAAiC;AACtE,WAAO,KAAKtG,kBAAL,CAAwBqG,mBAAxB,CAA4C7F,GAA5C,EAAiD8F,gBAAjD,EACFrF,IADE,CACG,YAAY,CAClB;AACH,KAHM,CAAP;AAIH,GALD;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIhC,EAAAA,QAAQ,CAACP,SAAT,CAAmB6H,mBAAnB,GAAyC,UAAU/F,GAAV,EAAe;AACpD,WAAO,KAAKR,kBAAL,CAAwBuG,mBAAxB,CAA4C/F,GAA5C,EACFS,IADE,CACG,YAAY,CAClB;AACH,KAHM,CAAP;AAIH,GALD;AAMA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIhC,EAAAA,QAAQ,CAACP,SAAT,CAAmB8H,WAAnB,GAAiC,UAAU9E,KAAV,EAAiB+E,OAAjB,EAA0B;AACvD,WAAO,KAAKzG,kBAAL,CAAwB0G,aAAxB,CAAsChF,KAAtC,EAA6C+E,OAA7C,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIxH,EAAAA,QAAQ,CAACP,SAAT,CAAmBiI,mBAAnB,GAAyC,UAAUhG,OAAV,EAAmBiG,oBAAnB,EAAyC;AAC9E;AACA,QAAI,CAAClH,SAAS,CAACmH,eAAV,CAA0BD,oBAA1B,CAAD,IACA,CAAClH,SAAS,CAACoH,QAAV,CAAmBF,oBAAoB,CAACG,SAAxC,CADL,EACyD;AACrD,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4B8F,+BAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAKlH,kBAAL,CAAwB2G,mBAAxB,CAA4ChG,OAA5C,EAAqDiG,oBAAoB,CAACG,SAA1E,CAAP;AACH,GAPD;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9H,EAAAA,QAAQ,CAACP,SAAT,CAAmByI,mBAAnB,GAAyC,UAAUC,aAAV,EAAyBxG,YAAzB,EAAuC;AAC5E,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAID,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,MAAAA,YAAY,GAAG,KAAf;AAAuB;;AACtD,QAAIE,UAAU,GAAGvB,kBAAkB,CAACwB,WAAnB,EAAjB;AACA,WAAO,KAAKZ,qBAAL,CAA2Ba,SAA3B,CAAqCoG,aAArC,EAAoDtG,UAApD,EACFG,IADE,CACG,UAAUC,cAAV,EAA0B;AAChC;AACA,UAAIN,YAAY,IAAIE,UAApB,EAAgC;AAC5B,eAAOD,KAAK,CAACM,0BAAN,CAAiCD,cAAjC,EAAiD1B,OAAO,CAAC4B,mBAAR,CAA4BiG,sBAA7E,CAAP;AACH;;AACD,aAAOnG,cAAP;AACH,KAPM,CAAP;AAQH,GAZD;AAaA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIjC,EAAAA,QAAQ,CAACP,SAAT,CAAmB4I,yBAAnB,GAA+C,UAAU1F,KAAV,EAAiB2F,kBAAjB,EAAqC;AAChF,WAAO,KAAKvH,kBAAL,CAAwBwH,kBAAxB,CAA2C,gBAA3C,EAA6D5F,KAA7D,EAAoE2F,kBAApE,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItI,EAAAA,QAAQ,CAACP,SAAT,CAAmB+I,6BAAnB,GAAmD,UAAU7F,KAAV,EAAiB2F,kBAAjB,EAAqC;AACpF,WAAO,KAAKvH,kBAAL,CAAwBwH,kBAAxB,CAA2C,cAA3C,EAA2D5F,KAA3D,EAAkE2F,kBAAlE,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItI,EAAAA,QAAQ,CAACP,SAAT,CAAmBgJ,2BAAnB,GAAiD,UAAU9F,KAAV,EAAiB2F,kBAAjB,EAAqC;AAClF,WAAO,KAAKvH,kBAAL,CAAwBwH,kBAAxB,CAA2C,cAA3C,EAA2D5F,KAA3D,EAAkE2F,kBAAlE,CAAP;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItI,EAAAA,QAAQ,CAACP,SAAT,CAAmBiJ,mBAAnB,GAAyC,UAAUlB,OAAV,EAAmB;AACxD,QAAImB,eAAe,GAAG,UAAUpG,QAAV,EAAoBqG,eAApB,EAAqC;AACvD;AACA,UAAI1D,MAAM,GAAG;AACT0D,QAAAA,eAAe,EAAEA;AADR,OAAb,CAFuD,CAKvD;;AACA,UAAI3J,MAAM,CAACQ,SAAP,CAAiBH,cAAjB,CAAgCuJ,IAAhC,CAAqCtG,QAArC,EAA+C,eAA/C,CAAJ,EAAqE;AACjE2C,QAAAA,MAAM,CAACL,SAAP,GAAmBtC,QAAQ,CAAC4C,aAA5B;AACH;;AACD,aAAOD,MAAP;AACH,KAVD;;AAWA,QAAIsC,OAAO,IAAIA,OAAO,CAACsB,IAAR,KAAiB,MAAhC,EAAwC;AACpC,aAAO,KAAK/H,kBAAL,CAAwBgI,mBAAxB,CAA4CvB,OAAO,CAAC5C,UAApD,EAAgE4C,OAAO,CAAC3C,SAAxE,EACF7C,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,YAAIqG,eAAe,GAAG,EAAtB,CAF0B,CAG1B;;AACArG,QAAAA,QAAQ,CAACyG,eAAT,CAAyBjE,OAAzB,CAAiC,UAAUkE,cAAV,EAA0B;AACvDL,UAAAA,eAAe,CAAC3D,IAAhB,CAAqB,IAAItE,aAAa,CAACuI,UAAlB,CAA6BD,cAA7B,CAArB;AACH,SAFD,EAJ0B,CAO1B;;AACA,eAAON,eAAe,CAACpG,QAAD,EAAWqG,eAAX,CAAtB;AACH,OAVM,CAAP;AAWH,KAZD,MAaK,IAAIpB,OAAO,IAAIA,OAAO,CAACsB,IAAR,KAAiB,MAAhC,EAAwC;AACzC,aAAO,KAAK/H,kBAAL,CAAwBoI,sBAAxB,CAA+C3B,OAAO,CAAC5C,UAAvD,EAAmE4C,OAAO,CAAC3C,SAA3E,EACF7C,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B;AACA,YAAIqG,eAAe,GAAG,EAAtB,CAF0B,CAG1B;;AACArG,QAAAA,QAAQ,CAAC6G,kBAAT,CAA4BrE,OAA5B,CAAoC,UAAUkE,cAAV,EAA0B;AAC1DL,UAAAA,eAAe,CAAC3D,IAAhB,CAAqB,IAAItE,aAAa,CAAC0I,UAAlB,CAA6BJ,cAA7B,CAArB;AACH,SAFD,EAJ0B,CAO1B;;AACA,eAAON,eAAe,CAACpG,QAAD,EAAWqG,eAAX,CAAtB;AACH,OAVM,CAAP;AAWH;;AACD,WAAOb,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BoB,gBAA1D,EAA4E,iEAA5E,CAAf,CAAP;AACH,GAvCD;AAwCA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIvD,EAAAA,QAAQ,CAACP,SAAT,CAAmB6J,iBAAnB,GAAuC,UAAUrG,UAAV,EAAsB;AACzD,QAAItC,aAAa,CAACuI,UAAd,CAAyBK,YAAzB,CAAsCtG,UAAtC,CAAJ,EAAuD;AACnD,aAAO,KAAKlC,kBAAL,CAAwByI,iBAAxB,CAA0CvG,UAA1C,EACFjB,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B,eAAO,IAAI5B,aAAa,CAACuI,UAAlB,CAA6B3G,QAA7B,CAAP;AACH,OAHM,CAAP;AAIH,KALD,MAMK,IAAI5B,aAAa,CAAC0I,UAAd,CAAyBE,YAAzB,CAAsCtG,UAAtC,CAAJ,EAAuD;AACxD,aAAO,KAAKlC,kBAAL,CAAwB0I,oBAAxB,CAA6CxG,UAA7C,EACFjB,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B,eAAO,IAAI5B,aAAa,CAAC0I,UAAlB,CAA6B9G,QAA7B,CAAP;AACH,OAHM,CAAP;AAIH;;AACD,WAAOwF,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BuH,mBAA1D,CAAf,CAAP;AACH,GAdD;AAeA;AACJ;AACA;AACA;AACA;AACA;;;AACI1J,EAAAA,QAAQ,CAACP,SAAT,CAAmBkK,oBAAnB,GAA0C,UAAU1G,UAAV,EAAsB;AAC5D,QAAItC,aAAa,CAACuI,UAAd,CAAyBK,YAAzB,CAAsCtG,UAAtC,CAAJ,EAAuD;AACnD,aAAO,KAAKlC,kBAAL,CAAwB6I,oBAAxB,CAA6C3G,UAA7C,CAAP;AACH,KAFD,MAGK,IAAItC,aAAa,CAAC0I,UAAd,CAAyBE,YAAzB,CAAsCtG,UAAtC,CAAJ,EAAuD;AACxD,aAAO,KAAKlC,kBAAL,CAAwB8I,uBAAxB,CAAgD5G,UAAhD,CAAP;AACH;;AACD,WAAO8E,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BuH,mBAA1D,CAAf,CAAP;AACH,GARD;AASA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI1J,EAAAA,QAAQ,CAACP,SAAT,CAAmBqK,oBAAnB,GAA0C,UAAU7G,UAAV,EAAsB8G,aAAtB,EAAqC;AAC3E,QAAI,CAACtJ,SAAS,CAACmH,eAAV,CAA0BmC,aAA1B,CAAL,EAA+C;AAC3C,aAAOhC,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4B6H,cAA1D,EAA0E,+DAA1E,CAAf,CAAP;AACH;;AACD,QAAIrJ,aAAa,CAACuI,UAAd,CAAyBK,YAAzB,CAAsCtG,UAAtC,CAAJ,EAAuD;AACnD,aAAO,KAAKlC,kBAAL,CAAwBkJ,oBAAxB,CAA6ChH,UAA7C,EAAyD8G,aAAzD,EACF/H,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B,eAAO,IAAI5B,aAAa,CAACuI,UAAlB,CAA6B3G,QAA7B,CAAP;AACH,OAHM,CAAP;AAIH,KALD,MAMK,IAAI5B,aAAa,CAAC0I,UAAd,CAAyBE,YAAzB,CAAsCtG,UAAtC,CAAJ,EAAuD;AACxD,aAAO,KAAKlC,kBAAL,CAAwBmJ,uBAAxB,CAAgDjH,UAAhD,EAA4D8G,aAA5D,EACF/H,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B,eAAO,IAAI5B,aAAa,CAAC0I,UAAlB,CAA6B9G,QAA7B,CAAP;AACH,OAHM,CAAP;AAIH;;AACD,WAAOwF,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BuH,mBAA1D,CAAf,CAAP;AACH,GAjBD;AAkBA;AACJ;AACA;AACA;AACA;AACA;;;AACI1J,EAAAA,QAAQ,CAACP,SAAT,CAAmB0K,oBAAnB,GAA0C,UAAUC,MAAV,EAAkB;AACxD,QAAI,CAAC3J,SAAS,CAACmH,eAAV,CAA0BwC,MAA1B,CAAL,EAAwC;AACpC,aAAOrC,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4B6H,cAA1D,EAA0E,wDAA1E,CAAf,CAAP;AACH;;AACD,QAAIrJ,aAAa,CAACuI,UAAd,CAAyBK,YAAzB,CAAsCa,MAAM,CAACnH,UAA7C,CAAJ,EAA8D;AAC1D,aAAO,KAAKlC,kBAAL,CAAwBsJ,oBAAxB,CAA6CD,MAA7C,EACFpI,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B,eAAO,IAAI5B,aAAa,CAACuI,UAAlB,CAA6B3G,QAA7B,CAAP;AACH,OAHM,CAAP;AAIH,KALD,MAMK,IAAI5B,aAAa,CAAC0I,UAAd,CAAyBE,YAAzB,CAAsCa,MAAM,CAACnH,UAA7C,CAAJ,EAA8D;AAC/D,aAAO,KAAKlC,kBAAL,CAAwBuJ,uBAAxB,CAAgDF,MAAhD,EACFpI,IADE,CACG,UAAUO,QAAV,EAAoB;AAC1B,eAAO,IAAI5B,aAAa,CAAC0I,UAAlB,CAA6B9G,QAA7B,CAAP;AACH,OAHM,CAAP;AAIH;;AACD,WAAOwF,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BuH,mBAA1D,CAAf,CAAP;AACH,GAjBD;AAkBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI1J,EAAAA,QAAQ,CAACP,SAAT,CAAmByC,0BAAnB,GAAgD,UAAUD,cAAV,EAA0BsI,mBAA1B,EAA+C;AAC3F;AACA,WAAO,KAAKlI,OAAL,CAAaJ,cAAc,CAACuI,GAA5B,EACFxI,IADE,CACG,UAAUwC,IAAV,EAAgB;AACtB;AACA,UAAIA,IAAI,CAACiG,oBAAT,EAA+B;AAC3B;AACA,YAAIC,WAAW,GAAGzI,cAAc,CAAC0I,SAAf,GAA2B,IAA7C,CAF2B,CAG3B;;AACA,YAAIC,aAAa,GAAG,IAAIC,IAAJ,CAASrG,IAAI,CAACiG,oBAAd,EAAoCK,OAApC,EAApB,CAJ2B,CAK3B;;AACA,YAAIJ,WAAW,GAAGE,aAAlB,EAAiC;AAC7B,gBAAM,IAAIrK,OAAO,CAAC+C,iBAAZ,CAA8BiH,mBAA9B,CAAN;AACH;AACJ,OAXqB,CAYtB;;;AACA,aAAOtI,cAAP;AACH,KAfM,CAAP;AAgBH,GAlBD;;AAmBA,SAAOjC,QAAP;AACH,CA1nB6B,EAA9B;;AA2nBAJ,OAAO,CAACI,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;;AACA,IAAID,eAAe;AAAG;AAAe,UAAUgL,MAAV,EAAkB;AACnDlM,EAAAA,SAAS,CAACkB,eAAD,EAAkBgL,MAAlB,CAAT;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI,WAAShL,eAAT,CAAyBe,GAAzB,EAA8BkK,QAA9B,EAAwC;AACpC,QAAIpJ,KAAK,GAAGmJ,MAAM,CAAClC,IAAP,CAAY,IAAZ,EAAkB/H,GAAlB,EAAuB,IAAIR,kBAAkB,CAAC2K,6BAAvB,CAAqDnK,GAArD,EAA0DkK,QAA1D,CAAvB,EAA4F/J,4BAA4B,CAACH,GAAD,EAAMkK,QAAN,CAAxH,KAA4I,IAAxJ;;AACAxK,IAAAA,KAAK,CAAC0K,iBAAN,CAAwBtJ,KAAxB,EAA+B,UAA/B,EAA2CoJ,QAA3C;AACA,WAAOpJ,KAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI7B,EAAAA,eAAe,CAACN,SAAhB,CAA0BgC,aAA1B,GAA0C,UAAUC,OAAV,EAAmBC,YAAnB,EAAiC;AACvE,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAID,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,MAAAA,YAAY,GAAG,KAAf;AAAuB;;AACtD,WAAOoJ,MAAM,CAACtL,SAAP,CAAiBgC,aAAjB,CAA+BoH,IAA/B,CAAoC,IAApC,EAA0CnH,OAA1C,EAAmDC,YAAnD,EACFK,IADE,CACG,UAAUmJ,aAAV,EAAyB;AAC/B;AACA,UAAIA,aAAa,CAACC,QAAd,CAAuBC,MAAvB,KAAkCzJ,KAAK,CAACoJ,QAA5C,EAAsD;AAClD,cAAM,IAAIzK,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BmJ,qBAA1D,CAAN;AACH;;AACD,aAAOH,aAAP;AACH,KAPM,CAAP;AAQH,GAXD;AAYA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIpL,EAAAA,eAAe,CAACN,SAAhB,CAA0BiI,mBAA1B,GAAgD,UAAUhG,OAAV,EAAmBiG,oBAAnB,EAAyC;AACrF,QAAI/F,KAAK,GAAG,IAAZ,CADqF,CAErF;;;AACA,QAAI,CAACnB,SAAS,CAAC8K,gBAAV,CAA2B7J,OAA3B,CAAL,EAA0C;AACtC,aAAOqG,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BqJ,gBAA1D,CAAf,CAAP;AACH;;AACD,QAAI,CAAC/K,SAAS,CAACmH,eAAV,CAA0BD,oBAA1B,CAAD,IACA,CAAClH,SAAS,CAACoH,QAAV,CAAmBF,oBAAoB,CAACG,SAAxC,CADL,EACyD;AACrD,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIzH,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4B8F,+BAA1D,CAAf,CAAP;AACH,KAToF,CAUrF;;;AACA,WAAO,KAAKxG,aAAL,CAAmBC,OAAnB,EACFM,IADE,CACG,YAAY;AAClB,aAAO+I,MAAM,CAACtL,SAAP,CAAiBiI,mBAAjB,CAAqCmB,IAArC,CAA0CjH,KAA1C,EAAiDF,OAAjD,EAA0DiG,oBAA1D,CAAP;AACH,KAHM,CAAP;AAIH,GAfD;AAgBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI5H,EAAAA,eAAe,CAACN,SAAhB,CAA0ByI,mBAA1B,GAAgD,UAAUC,aAAV,EAAyBxG,YAAzB,EAAuC;AACnF,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAID,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,MAAAA,YAAY,GAAG,KAAf;AAAuB;;AACtD,WAAOoJ,MAAM,CAACtL,SAAP,CAAiByI,mBAAjB,CAAqCW,IAArC,CAA0C,IAA1C,EAAgDV,aAAhD,EAA+DxG,YAA/D,EACFK,IADE,CACG,UAAUmJ,aAAV,EAAyB;AAC/B,UAAIA,aAAa,CAACC,QAAd,CAAuBC,MAAvB,KAAkCzJ,KAAK,CAACoJ,QAA5C,EAAsD;AAClD,cAAM,IAAIzK,OAAO,CAAC+C,iBAAZ,CAA8B/C,OAAO,CAAC4B,mBAAR,CAA4BmJ,qBAA1D,CAAN;AACH;;AACD,aAAOH,aAAP;AACH,KANM,CAAP;AAOH,GAVD;;AAWA,SAAOpL,eAAP;AACH,CAzFoC,CAyFnCC,QAzFmC,CAArC;;AA0FAJ,OAAO,CAACG,eAAR,GAA0BA,eAA1B;AACA;AACA;AACA;AACA;;AACA,IAAID,IAAI;AAAG;AAAe,UAAUiL,MAAV,EAAkB;AACxClM,EAAAA,SAAS,CAACiB,IAAD,EAAOiL,MAAP,CAAT;AACA;AACJ;AACA;AACA;;;AACI,WAASjL,IAAT,CAAcgB,GAAd,EAAmB;AACf,QAAIc,KAAK,GAAGmJ,MAAM,CAAClC,IAAP,CAAY,IAAZ,EAAkB/H,GAAlB,EAAuB,IAAIR,kBAAkB,CAACmL,kBAAvB,CAA0C3K,GAA1C,CAAvB,KAA0E,IAAtF;;AACAc,IAAAA,KAAK,CAAC8J,IAAN,GAAa5K,GAAb;AACAc,IAAAA,KAAK,CAAC+J,cAAN,GAAuB,IAAI/K,gBAAgB,CAACgL,aAArB,CAAmC9K,GAAnC,CAAvB;AACA,WAAOc,KAAP;AACH;;AACD3C,EAAAA,MAAM,CAACU,cAAP,CAAsBG,IAAI,CAACL,SAA3B,EAAsC,KAAtC,EAA6C;AACzC;AACR;AACA;AACA;AACA;AACQoM,IAAAA,GAAG,EAAE,YAAY;AACb,aAAO,KAAKH,IAAZ;AACH,KARwC;AASzCI,IAAAA,UAAU,EAAE,KAT6B;AAUzCC,IAAAA,YAAY,EAAE;AAV2B,GAA7C;AAYA;;AACAjM,EAAAA,IAAI,CAACL,SAAL,CAAeuM,aAAf,GAA+B,YAAY;AACvC,WAAO,KAAKL,cAAZ;AACH,GAFD;;AAGA,SAAO7L,IAAP;AACH,CA7ByB,CA6BxBE,QA7BwB,CAA1B;;AA8BAJ,OAAO,CAACE,IAAR,GAAeA,IAAf;;AACA,SAASmB,4BAAT,CAAsCH,GAAtC,EAA2CkK,QAA3C,EAAqD;AACjD,MAAI;AACA,QAAIiB,MAAM,GAAG3L,kBAAkB,CAACwB,WAAnB,KAAmC,IAAIzB,iBAAiB,CAAC6L,cAAtB,EAAnC,GAA4ErL,eAAe,CAACsL,mBAAhB,CAAoCrL,GAApC,CAAzF;AACA,WAAO,IAAIT,iBAAiB,CAAC+L,sBAAtB,CAA6CH,MAA7C,EAAqDjB,QAArD,CAAP;AACH,GAHD,CAIA,OAAOqB,GAAP,EAAY;AACR,UAAMhM,iBAAiB,CAACiM,uBAAlB,CAA0CD,GAA1C,CAAN;AACH;AACJ","sourcesContent":["/*! firebase-admin v9.10.0 */\r\n\"use strict\";\r\n/*!\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Auth = exports.TenantAwareAuth = exports.BaseAuth = void 0;\r\nvar deep_copy_1 = require(\"../utils/deep-copy\");\r\nvar user_record_1 = require(\"./user-record\");\r\nvar identifier_1 = require(\"./identifier\");\r\nvar token_generator_1 = require(\"./token-generator\");\r\nvar auth_api_request_1 = require(\"./auth-api-request\");\r\nvar error_1 = require(\"../utils/error\");\r\nvar utils = require(\"../utils/index\");\r\nvar validator = require(\"../utils/validator\");\r\nvar token_verifier_1 = require(\"./token-verifier\");\r\nvar auth_config_1 = require(\"./auth-config\");\r\nvar tenant_manager_1 = require(\"./tenant-manager\");\r\nvar crypto_signer_1 = require(\"../utils/crypto-signer\");\r\n/**\r\n * Base Auth class. Mainly used for user management APIs.\r\n */\r\nvar BaseAuth = /** @class */ (function () {\r\n    /**\r\n     * The BaseAuth class constructor.\r\n     *\r\n     * @param app The FirebaseApp to associate with this Auth instance.\r\n     * @param authRequestHandler The RPC request handler for this instance.\r\n     * @param tokenGenerator Optional token generator. If not specified, a\r\n     *     (non-tenant-aware) instance will be created. Use this paramter to\r\n     *     specify a tenant-aware tokenGenerator.\r\n     * @constructor\r\n     */\r\n    function BaseAuth(app, authRequestHandler, tokenGenerator) {\r\n        this.authRequestHandler = authRequestHandler;\r\n        if (tokenGenerator) {\r\n            this.tokenGenerator = tokenGenerator;\r\n        }\r\n        else {\r\n            this.tokenGenerator = createFirebaseTokenGenerator(app);\r\n        }\r\n        this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(app);\r\n        this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(app);\r\n    }\r\n    /**\r\n     * Creates a new custom token that can be sent back to a client to use with\r\n     * signInWithCustomToken().\r\n     *\r\n     * @param {string} uid The uid to use as the JWT subject.\r\n     * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\r\n     *\r\n     * @return {Promise<string>} A JWT for the provided payload.\r\n     */\r\n    BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\r\n        return this.tokenGenerator.createCustomToken(uid, developerClaims);\r\n    };\r\n    /**\r\n     * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\r\n     * the promise if the token could not be verified. If checkRevoked is set to true,\r\n     * verifies if the session corresponding to the ID token was revoked. If the corresponding\r\n     * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\r\n     * the check is not applied.\r\n     *\r\n     * @param {string} idToken The JWT to verify.\r\n     * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\r\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n     *     verification.\r\n     */\r\n    BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\r\n        var _this = this;\r\n        if (checkRevoked === void 0) { checkRevoked = false; }\r\n        var isEmulator = auth_api_request_1.useEmulator();\r\n        return this.idTokenVerifier.verifyJWT(idToken, isEmulator)\r\n            .then(function (decodedIdToken) {\r\n            // Whether to check if the token was revoked.\r\n            if (checkRevoked || isEmulator) {\r\n                return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\r\n            }\r\n            return decodedIdToken;\r\n        });\r\n    };\r\n    /**\r\n     * Looks up the user identified by the provided user id and returns a promise that is\r\n     * fulfilled with a user record for the given user if that user is found.\r\n     *\r\n     * @param {string} uid The uid of the user to look up.\r\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\r\n     */\r\n    BaseAuth.prototype.getUser = function (uid) {\r\n        return this.authRequestHandler.getAccountInfoByUid(uid)\r\n            .then(function (response) {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    };\r\n    /**\r\n     * Looks up the user identified by the provided email and returns a promise that is\r\n     * fulfilled with a user record for the given user if that user is found.\r\n     *\r\n     * @param {string} email The email of the user to look up.\r\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\r\n     */\r\n    BaseAuth.prototype.getUserByEmail = function (email) {\r\n        return this.authRequestHandler.getAccountInfoByEmail(email)\r\n            .then(function (response) {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    };\r\n    /**\r\n     * Looks up the user identified by the provided phone number and returns a promise that is\r\n     * fulfilled with a user record for the given user if that user is found.\r\n     *\r\n     * @param {string} phoneNumber The phone number of the user to look up.\r\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\r\n     */\r\n    BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\r\n        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)\r\n            .then(function (response) {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    };\r\n    /**\r\n     * Gets the user data for the user corresponding to a given provider id.\r\n     *\r\n     * See [Retrieve user data](/docs/auth/admin/manage-users#retrieve_user_data)\r\n     * for code samples and detailed documentation.\r\n     *\r\n     * @param providerId The provider ID, for example, \"google.com\" for the\r\n     *   Google provider.\r\n     * @param uid The user identifier for the given provider.\r\n     *\r\n     * @return A promise fulfilled with the user data corresponding to the\r\n     *   given provider id.\r\n     */\r\n    BaseAuth.prototype.getUserByProviderUid = function (providerId, uid) {\r\n        // Although we don't really advertise it, we want to also handle\r\n        // non-federated idps with this call. So if we detect one of them, we'll\r\n        // reroute this request appropriately.\r\n        if (providerId === 'phone') {\r\n            return this.getUserByPhoneNumber(uid);\r\n        }\r\n        else if (providerId === 'email') {\r\n            return this.getUserByEmail(uid);\r\n        }\r\n        return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid)\r\n            .then(function (response) {\r\n            // Returns the user record populated with server response.\r\n            return new user_record_1.UserRecord(response.users[0]);\r\n        });\r\n    };\r\n    /**\r\n     * Gets the user data corresponding to the specified identifiers.\r\n     *\r\n     * There are no ordering guarantees; in particular, the nth entry in the result list is not\r\n     * guaranteed to correspond to the nth entry in the input parameters list.\r\n     *\r\n     * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\r\n     * this method will immediately throw a FirebaseAuthError.\r\n     *\r\n     * @param identifiers The identifiers used to indicate which user records should be returned. Must\r\n     *     have <= 100 entries.\r\n     * @return {Promise<GetUsersResult>} A promise that resolves to the corresponding user records.\r\n     * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\r\n     *     identifiers are specified.\r\n     */\r\n    BaseAuth.prototype.getUsers = function (identifiers) {\r\n        if (!validator.isArray(identifiers)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\r\n        }\r\n        return this.authRequestHandler\r\n            .getAccountInfoByIdentifiers(identifiers)\r\n            .then(function (response) {\r\n            /**\r\n             * Checks if the specified identifier is within the list of\r\n             * UserRecords.\r\n             */\r\n            var isUserFound = (function (id, userRecords) {\r\n                return !!userRecords.find(function (userRecord) {\r\n                    if (identifier_1.isUidIdentifier(id)) {\r\n                        return id.uid === userRecord.uid;\r\n                    }\r\n                    else if (identifier_1.isEmailIdentifier(id)) {\r\n                        return id.email === userRecord.email;\r\n                    }\r\n                    else if (identifier_1.isPhoneIdentifier(id)) {\r\n                        return id.phoneNumber === userRecord.phoneNumber;\r\n                    }\r\n                    else if (identifier_1.isProviderIdentifier(id)) {\r\n                        var matchingUserInfo = userRecord.providerData.find(function (userInfo) {\r\n                            return id.providerId === userInfo.providerId;\r\n                        });\r\n                        return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\r\n                    }\r\n                    else {\r\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\r\n                    }\r\n                });\r\n            });\r\n            var users = response.users ? response.users.map(function (user) { return new user_record_1.UserRecord(user); }) : [];\r\n            var notFound = identifiers.filter(function (id) { return !isUserFound(id, users); });\r\n            return { users: users, notFound: notFound };\r\n        });\r\n    };\r\n    /**\r\n     * Exports a batch of user accounts. Batch size is determined by the maxResults argument.\r\n     * Starting point of the batch is determined by the pageToken argument.\r\n     *\r\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\r\n     *     allowed limit.\r\n     * @param {string=} pageToken The next page token. If not specified, returns users starting\r\n     *     without any offset.\r\n     * @return {Promise<{users: UserRecord[], pageToken?: string}>} A promise that resolves with\r\n     *     the current batch of downloaded users and the next page token. For the last page, an\r\n     *     empty list of users and no page token are returned.\r\n     */\r\n    BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\r\n        return this.authRequestHandler.downloadAccount(maxResults, pageToken)\r\n            .then(function (response) {\r\n            // List of users to return.\r\n            var users = [];\r\n            // Convert each user response to a UserRecord.\r\n            response.users.forEach(function (userResponse) {\r\n                users.push(new user_record_1.UserRecord(userResponse));\r\n            });\r\n            // Return list of user records and the next page token if available.\r\n            var result = {\r\n                users: users,\r\n                pageToken: response.nextPageToken,\r\n            };\r\n            // Delete result.pageToken if undefined.\r\n            if (typeof result.pageToken === 'undefined') {\r\n                delete result.pageToken;\r\n            }\r\n            return result;\r\n        });\r\n    };\r\n    /**\r\n     * Creates a new user with the properties provided.\r\n     *\r\n     * @param {CreateRequest} properties The properties to set on the new user record to be created.\r\n     * @return {Promise<UserRecord>} A promise that resolves with the newly created user record.\r\n     */\r\n    BaseAuth.prototype.createUser = function (properties) {\r\n        var _this = this;\r\n        return this.authRequestHandler.createNewAccount(properties)\r\n            .then(function (uid) {\r\n            // Return the corresponding user record.\r\n            return _this.getUser(uid);\r\n        })\r\n            .catch(function (error) {\r\n            if (error.code === 'auth/user-not-found') {\r\n                // Something must have happened after creating the user and then retrieving it.\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\r\n            }\r\n            throw error;\r\n        });\r\n    };\r\n    /**\r\n     * Deletes the user identified by the provided user id and returns a promise that is\r\n     * fulfilled when the user is found and successfully deleted.\r\n     *\r\n     * @param {string} uid The uid of the user to delete.\r\n     * @return {Promise<void>} A promise that resolves when the user is successfully deleted.\r\n     */\r\n    BaseAuth.prototype.deleteUser = function (uid) {\r\n        return this.authRequestHandler.deleteAccount(uid)\r\n            .then(function () {\r\n            // Return nothing on success.\r\n        });\r\n    };\r\n    BaseAuth.prototype.deleteUsers = function (uids) {\r\n        if (!validator.isArray(uids)) {\r\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\r\n        }\r\n        return this.authRequestHandler.deleteAccounts(uids, /*force=*/ true)\r\n            .then(function (batchDeleteAccountsResponse) {\r\n            var result = {\r\n                failureCount: 0,\r\n                successCount: uids.length,\r\n                errors: [],\r\n            };\r\n            if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\r\n                return result;\r\n            }\r\n            result.failureCount = batchDeleteAccountsResponse.errors.length;\r\n            result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\r\n            result.errors = batchDeleteAccountsResponse.errors.map(function (batchDeleteErrorInfo) {\r\n                if (batchDeleteErrorInfo.index === undefined) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\r\n                }\r\n                var errMsgToError = function (msg) {\r\n                    // We unconditionally set force=true, so the 'NOT_DISABLED' error\r\n                    // should not be possible.\r\n                    var code = msg && msg.startsWith('NOT_DISABLED') ?\r\n                        error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\r\n                    return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\r\n                };\r\n                return {\r\n                    index: batchDeleteErrorInfo.index,\r\n                    error: errMsgToError(batchDeleteErrorInfo.message),\r\n                };\r\n            });\r\n            return result;\r\n        });\r\n    };\r\n    /**\r\n     * Updates an existing user with the properties provided.\r\n     *\r\n     * @param {string} uid The uid identifier of the user to update.\r\n     * @param {UpdateRequest} properties The properties to update on the existing user.\r\n     * @return {Promise<UserRecord>} A promise that resolves with the modified user record.\r\n     */\r\n    BaseAuth.prototype.updateUser = function (uid, properties) {\r\n        var _this = this;\r\n        // Although we don't really advertise it, we want to also handle linking of\r\n        // non-federated idps with this call. So if we detect one of them, we'll\r\n        // adjust the properties parameter appropriately. This *does* imply that a\r\n        // conflict could arise, e.g. if the user provides a phoneNumber property,\r\n        // but also provides a providerToLink with a 'phone' provider id. In that\r\n        // case, we'll throw an error.\r\n        properties = deep_copy_1.deepCopy(properties);\r\n        if (properties === null || properties === void 0 ? void 0 : properties.providerToLink) {\r\n            if (properties.providerToLink.providerId === 'email') {\r\n                if (typeof properties.email !== 'undefined') {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \"\r\n                        + 'link to the email/password provider, only specify the UpdateRequest.email field.');\r\n                }\r\n                properties.email = properties.providerToLink.uid;\r\n                delete properties.providerToLink;\r\n            }\r\n            else if (properties.providerToLink.providerId === 'phone') {\r\n                if (typeof properties.phoneNumber !== 'undefined') {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \"\r\n                        + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\r\n                }\r\n                properties.phoneNumber = properties.providerToLink.uid;\r\n                delete properties.providerToLink;\r\n            }\r\n        }\r\n        if (properties === null || properties === void 0 ? void 0 : properties.providersToUnlink) {\r\n            if (properties.providersToUnlink.indexOf('phone') !== -1) {\r\n                // If we've been told to unlink the phone provider both via setting\r\n                // phoneNumber to null *and* by setting providersToUnlink to include\r\n                // 'phone', then we'll reject that. Though it might also be reasonable\r\n                // to relax this restriction and just unlink it.\r\n                if (properties.phoneNumber === null) {\r\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \"\r\n                        + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\r\n                }\r\n            }\r\n        }\r\n        return this.authRequestHandler.updateExistingAccount(uid, properties)\r\n            .then(function (existingUid) {\r\n            // Return the corresponding user record.\r\n            return _this.getUser(existingUid);\r\n        });\r\n    };\r\n    /**\r\n     * Sets additional developer claims on an existing user identified by the provided UID.\r\n     *\r\n     * @param {string} uid The user to edit.\r\n     * @param {object} customUserClaims The developer claims to set.\r\n     * @return {Promise<void>} A promise that resolves when the operation completes\r\n     *     successfully.\r\n     */\r\n    BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\r\n        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)\r\n            .then(function () {\r\n            // Return nothing on success.\r\n        });\r\n    };\r\n    /**\r\n     * Revokes all refresh tokens for the specified user identified by the provided UID.\r\n     * In addition to revoking all refresh tokens for a user, all ID tokens issued before\r\n     * revocation will also be revoked on the Auth backend. Any request with an ID token\r\n     * generated before revocation will be rejected with a token expired error.\r\n     *\r\n     * @param {string} uid The user whose tokens are to be revoked.\r\n     * @return {Promise<void>} A promise that resolves when the operation completes\r\n     *     successfully.\r\n     */\r\n    BaseAuth.prototype.revokeRefreshTokens = function (uid) {\r\n        return this.authRequestHandler.revokeRefreshTokens(uid)\r\n            .then(function () {\r\n            // Return nothing on success.\r\n        });\r\n    };\r\n    /**\r\n     * Imports the list of users provided to Firebase Auth. This is useful when\r\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\r\n     * At most, 1000 users are allowed to be imported one at a time.\r\n     * When importing a list of password users, UserImportOptions are required to be specified.\r\n     *\r\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\r\n     * @param {UserImportOptions=} options The user import options, required when the users provided\r\n     *     include password credentials.\r\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\r\n     *     with the result of the import. This includes the number of successful imports, the number\r\n     *     of failed uploads and their corresponding errors.\r\n     */\r\n    BaseAuth.prototype.importUsers = function (users, options) {\r\n        return this.authRequestHandler.uploadAccount(users, options);\r\n    };\r\n    /**\r\n     * Creates a new Firebase session cookie with the specified options that can be used for\r\n     * session management (set as a server side session cookie with custom cookie policy).\r\n     * The session cookie JWT will have the same payload claims as the provided ID token.\r\n     *\r\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\r\n     * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\r\n     *     custom session duration.\r\n     *\r\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\r\n     */\r\n    BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\r\n        // Return rejected promise if expiresIn is not available.\r\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\r\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\r\n        }\r\n        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\r\n    };\r\n    /**\r\n     * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\r\n     * the promise if the token could not be verified. If checkRevoked is set to true,\r\n     * verifies if the session corresponding to the session cookie was revoked. If the corresponding\r\n     * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\r\n     * specified the check is not performed.\r\n     *\r\n     * @param {string} sessionCookie The session cookie to verify.\r\n     * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\r\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n     *     verification.\r\n     */\r\n    BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\r\n        var _this = this;\r\n        if (checkRevoked === void 0) { checkRevoked = false; }\r\n        var isEmulator = auth_api_request_1.useEmulator();\r\n        return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator)\r\n            .then(function (decodedIdToken) {\r\n            // Whether to check if the token was revoked.\r\n            if (checkRevoked || isEmulator) {\r\n                return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\r\n            }\r\n            return decodedIdToken;\r\n        });\r\n    };\r\n    /**\r\n     * Generates the out of band email action link for password reset flows for the\r\n     * email specified using the action code settings provided.\r\n     * Returns a promise that resolves with the generated link.\r\n     *\r\n     * @param {string} email The email of the user whose password is to be reset.\r\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\r\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n     *     deep link, etc.\r\n     * @return {Promise<string>} A promise that resolves with the password reset link.\r\n     */\r\n    BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\r\n        return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\r\n    };\r\n    /**\r\n     * Generates the out of band email action link for email verification flows for the\r\n     * email specified using the action code settings provided.\r\n     * Returns a promise that resolves with the generated link.\r\n     *\r\n     * @param {string} email The email of the user to be verified.\r\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\r\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n     *     deep link, etc.\r\n     * @return {Promise<string>} A promise that resolves with the email verification link.\r\n     */\r\n    BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\r\n        return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\r\n    };\r\n    /**\r\n     * Generates the out of band email action link for email link sign-in flows for the\r\n     * email specified using the action code settings provided.\r\n     * Returns a promise that resolves with the generated link.\r\n     *\r\n     * @param {string} email The email of the user signing in.\r\n     * @param {ActionCodeSettings} actionCodeSettings The required action code setings which defines whether\r\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\r\n     *     deep link, etc.\r\n     * @return {Promise<string>} A promise that resolves with the email sign-in link.\r\n     */\r\n    BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\r\n        return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\r\n    };\r\n    /**\r\n     * Returns the list of existing provider configuation matching the filter provided.\r\n     * At most, 100 provider configs are allowed to be imported at a time.\r\n     *\r\n     * @param {AuthProviderConfigFilter} options The provider config filter to apply.\r\n     * @return {Promise<ListProviderConfigResults>} A promise that resolves with the list of provider configs\r\n     *     meeting the filter requirements.\r\n     */\r\n    BaseAuth.prototype.listProviderConfigs = function (options) {\r\n        var processResponse = function (response, providerConfigs) {\r\n            // Return list of provider configuration and the next page token if available.\r\n            var result = {\r\n                providerConfigs: providerConfigs,\r\n            };\r\n            // Delete result.pageToken if undefined.\r\n            if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\r\n                result.pageToken = response.nextPageToken;\r\n            }\r\n            return result;\r\n        };\r\n        if (options && options.type === 'oidc') {\r\n            return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken)\r\n                .then(function (response) {\r\n                // List of provider configurations to return.\r\n                var providerConfigs = [];\r\n                // Convert each provider config response to a OIDCConfig.\r\n                response.oauthIdpConfigs.forEach(function (configResponse) {\r\n                    providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\r\n                });\r\n                // Return list of provider configuration and the next page token if available.\r\n                return processResponse(response, providerConfigs);\r\n            });\r\n        }\r\n        else if (options && options.type === 'saml') {\r\n            return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken)\r\n                .then(function (response) {\r\n                // List of provider configurations to return.\r\n                var providerConfigs = [];\r\n                // Convert each provider config response to a SAMLConfig.\r\n                response.inboundSamlConfigs.forEach(function (configResponse) {\r\n                    providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\r\n                });\r\n                // Return list of provider configuration and the next page token if available.\r\n                return processResponse(response, providerConfigs);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\r\n    };\r\n    /**\r\n     * Looks up an Auth provider configuration by ID.\r\n     * Returns a promise that resolves with the provider configuration corresponding to the provider ID specified.\r\n     *\r\n     * @param {string} providerId  The provider ID corresponding to the provider config to return.\r\n     * @return {Promise<AuthProviderConfig>}\r\n     */\r\n    BaseAuth.prototype.getProviderConfig = function (providerId) {\r\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.getOAuthIdpConfig(providerId)\r\n                .then(function (response) {\r\n                return new auth_config_1.OIDCConfig(response);\r\n            });\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.getInboundSamlConfig(providerId)\r\n                .then(function (response) {\r\n                return new auth_config_1.SAMLConfig(response);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    };\r\n    /**\r\n     * Deletes the provider configuration corresponding to the provider ID passed.\r\n     *\r\n     * @param {string} providerId The provider ID corresponding to the provider config to delete.\r\n     * @return {Promise<void>} A promise that resolves on completion.\r\n     */\r\n    BaseAuth.prototype.deleteProviderConfig = function (providerId) {\r\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.deleteInboundSamlConfig(providerId);\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    };\r\n    /**\r\n     * Returns a promise that resolves with the updated AuthProviderConfig when the provider configuration corresponding\r\n     * to the provider ID specified is updated with the specified configuration.\r\n     *\r\n     * @param {string} providerId The provider ID corresponding to the provider config to update.\r\n     * @param {UpdateAuthProviderRequest} updatedConfig The updated configuration.\r\n     * @return {Promise<AuthProviderConfig>} A promise that resolves with the updated provider configuration.\r\n     */\r\n    BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\r\n        if (!validator.isNonNullObject(updatedConfig)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\r\n        }\r\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig)\r\n                .then(function (response) {\r\n                return new auth_config_1.OIDCConfig(response);\r\n            });\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\r\n            return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig)\r\n                .then(function (response) {\r\n                return new auth_config_1.SAMLConfig(response);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    };\r\n    /**\r\n     * Returns a promise that resolves with the newly created AuthProviderConfig when the new provider configuration is\r\n     * created.\r\n     * @param {AuthProviderConfig} config The provider configuration to create.\r\n     * @return {Promise<AuthProviderConfig>} A promise that resolves with the created provider configuration.\r\n     */\r\n    BaseAuth.prototype.createProviderConfig = function (config) {\r\n        if (!validator.isNonNullObject(config)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\r\n        }\r\n        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\r\n            return this.authRequestHandler.createOAuthIdpConfig(config)\r\n                .then(function (response) {\r\n                return new auth_config_1.OIDCConfig(response);\r\n            });\r\n        }\r\n        else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\r\n            return this.authRequestHandler.createInboundSamlConfig(config)\r\n                .then(function (response) {\r\n                return new auth_config_1.SAMLConfig(response);\r\n            });\r\n        }\r\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\r\n    };\r\n    /**\r\n     * Verifies the decoded Firebase issued JWT is not revoked. Returns a promise that resolves\r\n     * with the decoded claims on success. Rejects the promise with revocation error if revoked.\r\n     *\r\n     * @param {DecodedIdToken} decodedIdToken The JWT's decoded claims.\r\n     * @param {ErrorInfo} revocationErrorInfo The revocation error info to throw on revocation\r\n     *     detection.\r\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n     *     verification.\r\n     */\r\n    BaseAuth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {\r\n        // Get tokens valid after time for the corresponding user.\r\n        return this.getUser(decodedIdToken.sub)\r\n            .then(function (user) {\r\n            // If no tokens valid after time available, token is not revoked.\r\n            if (user.tokensValidAfterTime) {\r\n                // Get the ID token authentication time and convert to milliseconds UTC.\r\n                var authTimeUtc = decodedIdToken.auth_time * 1000;\r\n                // Get user tokens valid after time in milliseconds UTC.\r\n                var validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\r\n                // Check if authentication time is older than valid since time.\r\n                if (authTimeUtc < validSinceUtc) {\r\n                    throw new error_1.FirebaseAuthError(revocationErrorInfo);\r\n                }\r\n            }\r\n            // All checks above passed. Return the decoded token.\r\n            return decodedIdToken;\r\n        });\r\n    };\r\n    return BaseAuth;\r\n}());\r\nexports.BaseAuth = BaseAuth;\r\n/**\r\n * The tenant aware Auth class.\r\n */\r\nvar TenantAwareAuth = /** @class */ (function (_super) {\r\n    __extends(TenantAwareAuth, _super);\r\n    /**\r\n     * The TenantAwareAuth class constructor.\r\n     *\r\n     * @param {object} app The app that created this tenant.\r\n     * @param tenantId The corresponding tenant ID.\r\n     * @constructor\r\n     */\r\n    function TenantAwareAuth(app, tenantId) {\r\n        var _this = _super.call(this, app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), createFirebaseTokenGenerator(app, tenantId)) || this;\r\n        utils.addReadonlyGetter(_this, 'tenantId', tenantId);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\r\n     * the promise if the token could not be verified. If checkRevoked is set to true,\r\n     * verifies if the session corresponding to the ID token was revoked. If the corresponding\r\n     * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\r\n     * the check is not applied.\r\n     *\r\n     * @param {string} idToken The JWT to verify.\r\n     * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\r\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n     *     verification.\r\n     */\r\n    TenantAwareAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\r\n        var _this = this;\r\n        if (checkRevoked === void 0) { checkRevoked = false; }\r\n        return _super.prototype.verifyIdToken.call(this, idToken, checkRevoked)\r\n            .then(function (decodedClaims) {\r\n            // Validate tenant ID.\r\n            if (decodedClaims.firebase.tenant !== _this.tenantId) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\r\n            }\r\n            return decodedClaims;\r\n        });\r\n    };\r\n    /**\r\n     * Creates a new Firebase session cookie with the specified options that can be used for\r\n     * session management (set as a server side session cookie with custom cookie policy).\r\n     * The session cookie JWT will have the same payload claims as the provided ID token.\r\n     *\r\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\r\n     * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\r\n     *     custom session duration.\r\n     *\r\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\r\n     */\r\n    TenantAwareAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\r\n        var _this = this;\r\n        // Validate arguments before processing.\r\n        if (!validator.isNonEmptyString(idToken)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\r\n        }\r\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\r\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\r\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\r\n        }\r\n        // This will verify the ID token and then match the tenant ID before creating the session cookie.\r\n        return this.verifyIdToken(idToken)\r\n            .then(function () {\r\n            return _super.prototype.createSessionCookie.call(_this, idToken, sessionCookieOptions);\r\n        });\r\n    };\r\n    /**\r\n     * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\r\n     * the promise if the token could not be verified. If checkRevoked is set to true,\r\n     * verifies if the session corresponding to the session cookie was revoked. If the corresponding\r\n     * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\r\n     * specified the check is not performed.\r\n     *\r\n     * @param {string} sessionCookie The session cookie to verify.\r\n     * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\r\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\r\n     *     verification.\r\n     */\r\n    TenantAwareAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\r\n        var _this = this;\r\n        if (checkRevoked === void 0) { checkRevoked = false; }\r\n        return _super.prototype.verifySessionCookie.call(this, sessionCookie, checkRevoked)\r\n            .then(function (decodedClaims) {\r\n            if (decodedClaims.firebase.tenant !== _this.tenantId) {\r\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\r\n            }\r\n            return decodedClaims;\r\n        });\r\n    };\r\n    return TenantAwareAuth;\r\n}(BaseAuth));\r\nexports.TenantAwareAuth = TenantAwareAuth;\r\n/**\r\n * Auth service bound to the provided app.\r\n * An Auth instance can have multiple tenants.\r\n */\r\nvar Auth = /** @class */ (function (_super) {\r\n    __extends(Auth, _super);\r\n    /**\r\n     * @param {object} app The app for this Auth service.\r\n     * @constructor\r\n     */\r\n    function Auth(app) {\r\n        var _this = _super.call(this, app, new auth_api_request_1.AuthRequestHandler(app)) || this;\r\n        _this.app_ = app;\r\n        _this.tenantManager_ = new tenant_manager_1.TenantManager(app);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Auth.prototype, \"app\", {\r\n        /**\r\n         * Returns the app associated with this Auth instance.\r\n         *\r\n         * @return {FirebaseApp} The app associated with this Auth instance.\r\n         */\r\n        get: function () {\r\n            return this.app_;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @return The current Auth instance's tenant manager. */\r\n    Auth.prototype.tenantManager = function () {\r\n        return this.tenantManager_;\r\n    };\r\n    return Auth;\r\n}(BaseAuth));\r\nexports.Auth = Auth;\r\nfunction createFirebaseTokenGenerator(app, tenantId) {\r\n    try {\r\n        var signer = auth_api_request_1.useEmulator() ? new token_generator_1.EmulatedSigner() : crypto_signer_1.cryptoSignerFromApp(app);\r\n        return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\r\n    }\r\n    catch (err) {\r\n        throw token_generator_1.handleCryptoSignerError(err);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}