{"ast":null,"code":"\"use strict\";\n/*!\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst document_1 = require(\"./document\");\n\nconst util_1 = require(\"./util\");\n\nconst logger_1 = require(\"./logger\");\n/**\r\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\r\n * failure and returns ordered results.\r\n *\r\n * @private\r\n */\n\n\nclass DocumentReader {\n  /**\r\n   * Creates a new DocumentReader that fetches the provided documents (via\r\n   * `get()`).\r\n   *\r\n   * @param firestore The Firestore instance to use.\r\n   * @param allDocuments The documents to get.\r\n   */\n  constructor(firestore, allDocuments) {\n    this.firestore = firestore;\n    this.allDocuments = allDocuments;\n    this.outstandingDocuments = new Set();\n    this.retrievedDocuments = new Map();\n\n    for (const docRef of this.allDocuments) {\n      this.outstandingDocuments.add(docRef.formattedName);\n    }\n  }\n  /**\r\n   * Invokes the BatchGetDocuments RPC and returns the results.\r\n   *\r\n   * @param requestTag A unique client-assigned identifier for this request.\r\n   */\n\n\n  async get(requestTag) {\n    await this.fetchDocuments(requestTag); // BatchGetDocuments doesn't preserve document order. We use the request\n    // order to sort the resulting documents.\n\n    const orderedDocuments = [];\n\n    for (const docRef of this.allDocuments) {\n      const document = this.retrievedDocuments.get(docRef.formattedName);\n\n      if (document !== undefined) {\n        // Recreate the DocumentSnapshot with the DocumentReference\n        // containing the original converter.\n        const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n        finalDoc.fieldsProto = document._fieldsProto;\n        finalDoc.readTime = document.readTime;\n        finalDoc.createTime = document.createTime;\n        finalDoc.updateTime = document.updateTime;\n        orderedDocuments.push(finalDoc.build());\n      } else {\n        throw new Error(`Did not receive document for \"${docRef.path}\".`);\n      }\n    }\n\n    return orderedDocuments;\n  }\n\n  async fetchDocuments(requestTag) {\n    if (!this.outstandingDocuments.size) {\n      return;\n    }\n\n    const request = {\n      database: this.firestore.formattedName,\n      transaction: this.transactionId,\n      documents: Array.from(this.outstandingDocuments)\n    };\n\n    if (this.fieldMask) {\n      const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n      request.mask = {\n        fieldPaths\n      };\n    }\n\n    let resultCount = 0;\n\n    try {\n      const stream = await this.firestore.requestStream('batchGetDocuments', request, requestTag);\n      stream.resume();\n\n      for await (const response of stream) {\n        let snapshot;\n\n        if (response.found) {\n          logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n          snapshot = this.firestore.snapshot_(response.found, response.readTime);\n        } else {\n          logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n          snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n        }\n\n        const path = snapshot.ref.formattedName;\n        this.outstandingDocuments.delete(path);\n        this.retrievedDocuments.set(path, snapshot);\n        ++resultCount;\n      }\n    } catch (error) {\n      const shouldRetry = // Transactional reads are retried via the transaction runner.\n      !this.transactionId && // Only retry if we made progress.\n      resultCount > 0 && // Don't retry permanent errors.\n      error.code !== undefined && !util_1.isPermanentRpcError(error, 'batchGetDocuments');\n      logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n\n      if (shouldRetry) {\n        return this.fetchDocuments(requestTag);\n      } else {\n        throw error;\n      }\n    } finally {\n      logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n    }\n  }\n\n}\n\nexports.DocumentReader = DocumentReader;","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/@google-cloud/firestore/build/src/document-reader.js"],"names":["Object","defineProperty","exports","value","document_1","require","util_1","logger_1","DocumentReader","constructor","firestore","allDocuments","outstandingDocuments","Set","retrievedDocuments","Map","docRef","add","formattedName","get","requestTag","fetchDocuments","orderedDocuments","document","undefined","finalDoc","DocumentSnapshotBuilder","fieldsProto","_fieldsProto","readTime","createTime","updateTime","push","build","Error","path","size","request","database","transaction","transactionId","documents","Array","from","fieldMask","fieldPaths","map","fieldPath","mask","resultCount","stream","requestStream","resume","response","snapshot","found","logger","name","snapshot_","missing","ref","delete","set","error","shouldRetry","code","isPermanentRpcError"],"mappings":"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","sourcesContent":["\"use strict\";\r\n/*!\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst document_1 = require(\"./document\");\r\nconst util_1 = require(\"./util\");\r\nconst logger_1 = require(\"./logger\");\r\n/**\r\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\r\n * failure and returns ordered results.\r\n *\r\n * @private\r\n */\r\nclass DocumentReader {\r\n    /**\r\n     * Creates a new DocumentReader that fetches the provided documents (via\r\n     * `get()`).\r\n     *\r\n     * @param firestore The Firestore instance to use.\r\n     * @param allDocuments The documents to get.\r\n     */\r\n    constructor(firestore, allDocuments) {\r\n        this.firestore = firestore;\r\n        this.allDocuments = allDocuments;\r\n        this.outstandingDocuments = new Set();\r\n        this.retrievedDocuments = new Map();\r\n        for (const docRef of this.allDocuments) {\r\n            this.outstandingDocuments.add(docRef.formattedName);\r\n        }\r\n    }\r\n    /**\r\n     * Invokes the BatchGetDocuments RPC and returns the results.\r\n     *\r\n     * @param requestTag A unique client-assigned identifier for this request.\r\n     */\r\n    async get(requestTag) {\r\n        await this.fetchDocuments(requestTag);\r\n        // BatchGetDocuments doesn't preserve document order. We use the request\r\n        // order to sort the resulting documents.\r\n        const orderedDocuments = [];\r\n        for (const docRef of this.allDocuments) {\r\n            const document = this.retrievedDocuments.get(docRef.formattedName);\r\n            if (document !== undefined) {\r\n                // Recreate the DocumentSnapshot with the DocumentReference\r\n                // containing the original converter.\r\n                const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\r\n                finalDoc.fieldsProto = document._fieldsProto;\r\n                finalDoc.readTime = document.readTime;\r\n                finalDoc.createTime = document.createTime;\r\n                finalDoc.updateTime = document.updateTime;\r\n                orderedDocuments.push(finalDoc.build());\r\n            }\r\n            else {\r\n                throw new Error(`Did not receive document for \"${docRef.path}\".`);\r\n            }\r\n        }\r\n        return orderedDocuments;\r\n    }\r\n    async fetchDocuments(requestTag) {\r\n        if (!this.outstandingDocuments.size) {\r\n            return;\r\n        }\r\n        const request = {\r\n            database: this.firestore.formattedName,\r\n            transaction: this.transactionId,\r\n            documents: Array.from(this.outstandingDocuments),\r\n        };\r\n        if (this.fieldMask) {\r\n            const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\r\n            request.mask = { fieldPaths };\r\n        }\r\n        let resultCount = 0;\r\n        try {\r\n            const stream = await this.firestore.requestStream('batchGetDocuments', request, requestTag);\r\n            stream.resume();\r\n            for await (const response of stream) {\r\n                let snapshot;\r\n                if (response.found) {\r\n                    logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\r\n                    snapshot = this.firestore.snapshot_(response.found, response.readTime);\r\n                }\r\n                else {\r\n                    logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\r\n                    snapshot = this.firestore.snapshot_(response.missing, response.readTime);\r\n                }\r\n                const path = snapshot.ref.formattedName;\r\n                this.outstandingDocuments.delete(path);\r\n                this.retrievedDocuments.set(path, snapshot);\r\n                ++resultCount;\r\n            }\r\n        }\r\n        catch (error) {\r\n            const shouldRetry = \r\n            // Transactional reads are retried via the transaction runner.\r\n            !this.transactionId &&\r\n                // Only retry if we made progress.\r\n                resultCount > 0 &&\r\n                // Don't retry permanent errors.\r\n                error.code !== undefined &&\r\n                !util_1.isPermanentRpcError(error, 'batchGetDocuments');\r\n            logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\r\n            if (shouldRetry) {\r\n                return this.fetchDocuments(requestTag);\r\n            }\r\n            else {\r\n                throw error;\r\n            }\r\n        }\r\n        finally {\r\n            logger_1.logger('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\r\n        }\r\n    }\r\n}\r\nexports.DocumentReader = DocumentReader;\r\n//# sourceMappingURL=document-reader.js.map"]},"metadata":{},"sourceType":"script"}