{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst backoff_1 = require(\"./backoff\");\n\nconst rate_limiter_1 = require(\"./rate-limiter\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst util_1 = require(\"./util\");\n\nconst write_batch_1 = require(\"./write-batch\");\n\nconst validate_1 = require(\"./validate\");\n\nconst logger_1 = require(\"./logger\");\n/*!\r\n * The maximum number of writes that can be in a single batch.\r\n */\n\n\nconst MAX_BATCH_SIZE = 20;\n/*!\r\n * The starting maximum number of operations per second as allowed by the\r\n * 500/50/5 rule.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\n\nexports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;\n/*!\r\n * The maximum number of operations per second as allowed by the 500/50/5 rule.\r\n * By default the rate limiter will not exceed this value.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\n\nexports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;\n/*!\r\n * The default jitter to apply to the exponential backoff used in retries. For\r\n * example, a factor of 0.3 means a 30% jitter is applied.\r\n */\n\nexports.DEFAULT_JITTER_FACTOR = 0.3;\n/*!\r\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\r\n */\n\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\r\n * How often the operations per second capacity should increase in milliseconds\r\n * as specified by the 500/50/5 rule.\r\n */\n\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\r\n * The default maximum number of pending operations that can be enqueued onto a\r\n * BulkWriter instance. An operation is considered pending if BulkWriter has\r\n * sent it via RPC and is awaiting the result. BulkWriter buffers additional\r\n * writes after this many pending operations in order to avoiding going OOM.\r\n */\n\nconst DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;\n/**\r\n * Represents a single write for BulkWriter, encapsulating operation dispatch\r\n * and error handling.\r\n * @private\r\n */\n\nclass BulkWriterOperation {\n  /**\r\n   * @param ref The document reference being written to.\r\n   * @param type The type of operation that created this write.\r\n   * @param sendFn A callback to invoke when the operation should be sent.\r\n   * @param errorFn The user provided global error callback.\r\n   * @param successFn The user provided global success callback.\r\n   */\n  constructor(ref, type, sendFn, errorFn, successFn) {\n    this.ref = ref;\n    this.type = type;\n    this.sendFn = sendFn;\n    this.errorFn = errorFn;\n    this.successFn = successFn;\n    this.deferred = new util_1.Deferred();\n    this.failedAttempts = 0;\n    this._backoffDuration = 0;\n    /** Whether flush() was called when this was the last enqueued operation. */\n\n    this._flushed = false;\n  }\n\n  get promise() {\n    return this.deferred.promise;\n  }\n\n  get backoffDuration() {\n    return this._backoffDuration;\n  }\n\n  markFlushed() {\n    this._flushed = true;\n  }\n\n  get flushed() {\n    return this._flushed;\n  }\n\n  onError(error) {\n    ++this.failedAttempts;\n\n    try {\n      const bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);\n      const shouldRetry = this.errorFn(bulkWriterError);\n      logger_1.logger('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);\n\n      if (shouldRetry) {\n        this.lastStatus = error.code;\n        this.updateBackoffDuration();\n        this.sendFn(this);\n      } else {\n        this.deferred.reject(bulkWriterError);\n      }\n    } catch (userCallbackError) {\n      this.deferred.reject(userCallbackError);\n    }\n  }\n\n  updateBackoffDuration() {\n    if (this.lastStatus === 8\n    /* RESOURCE_EXHAUSTED */\n    ) {\n        this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;\n      } else if (this._backoffDuration === 0) {\n      this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n    } else {\n      this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;\n    }\n  }\n\n  onSuccess(result) {\n    try {\n      this.successFn(this.ref, result);\n      this.deferred.resolve(result);\n    } catch (userCallbackError) {\n      this.deferred.reject(userCallbackError);\n    }\n  }\n\n}\n/**\r\n * Used to represent a batch on the BatchQueue.\r\n *\r\n * @private\r\n */\n\n\nclass BulkCommitBatch extends write_batch_1.WriteBatch {\n  constructor() {\n    super(...arguments); // The set of document reference paths present in the WriteBatch.\n\n    this.docPaths = new Set(); // An array of pending write operations. Only contains writes that have not\n    // been resolved.\n\n    this.pendingOps = [];\n  }\n\n  has(documentRef) {\n    return this.docPaths.has(documentRef.path);\n  }\n\n  async bulkCommit(options = {}) {\n    var _a;\n\n    const tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : util_1.requestTag(); // Capture the error stack to preserve stack tracing across async calls.\n\n    const stack = Error().stack;\n    let response;\n\n    try {\n      logger_1.logger('BulkCommitBatch.bulkCommit', tag, `Sending next batch with ${this._opCount} writes`);\n      const retryCodes = util_1.getRetryCodes('batchWrite');\n      response = await this._commit({\n        retryCodes,\n        methodName: 'batchWrite',\n        requestTag: tag\n      });\n    } catch (err) {\n      // Map the failure to each individual write's result.\n      const ops = Array.from({\n        length: this.pendingOps.length\n      });\n      response = {\n        writeResults: ops.map(() => {\n          return {};\n        }),\n        status: ops.map(() => err)\n      };\n    }\n\n    for (let i = 0; i < (response.writeResults || []).length; ++i) {\n      // Since delete operations currently do not have write times, use a\n      // sentinel Timestamp value.\n      // TODO(b/158502664): Use actual delete timestamp.\n      const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n      const status = (response.status || [])[i];\n\n      if (status.code === 0\n      /* OK */\n      ) {\n          const updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);\n          this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));\n        } else {\n        const error = new (require('google-gax').GoogleError)(status.message || undefined);\n        error.code = status.code;\n        this.pendingOps[i].onError(util_1.wrapError(error, stack));\n      }\n    }\n  }\n  /**\r\n   * Helper to update data structures associated with the operation and returns\r\n   * the result.\r\n   */\n\n\n  processLastOperation(op) {\n    assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');\n    this.docPaths.add(op.ref.path);\n    this.pendingOps.push(op);\n  }\n\n}\n/**\r\n * Used to represent a buffered BulkWriterOperation.\r\n *\r\n * @private\r\n */\n\n\nclass BufferedOperation {\n  constructor(operation, sendFn) {\n    this.operation = operation;\n    this.sendFn = sendFn;\n  }\n\n}\n/**\r\n * The error thrown when a BulkWriter operation fails.\r\n *\r\n * @class BulkWriterError\r\n */\n\n\nclass BulkWriterError extends Error {\n  /** @hideconstructor */\n  constructor(\n  /** The status code of the error. */\n  code,\n  /** The error message of the error. */\n  message,\n  /** The document reference the operation was performed on. */\n  documentRef,\n  /** The type of operation performed. */\n  operationType,\n  /** How many times this operation has been attempted unsuccessfully. */\n  failedAttempts) {\n    super(message);\n    this.code = code;\n    this.message = message;\n    this.documentRef = documentRef;\n    this.operationType = operationType;\n    this.failedAttempts = failedAttempts;\n  }\n\n}\n\nexports.BulkWriterError = BulkWriterError;\n/**\r\n * A Firestore BulkWriter that can be used to perform a large number of writes\r\n * in parallel.\r\n *\r\n * @class BulkWriter\r\n */\n\nclass BulkWriter {\n  /** @hideconstructor */\n  constructor(firestore, options) {\n    var _a, _b;\n\n    this.firestore = firestore;\n    /**\r\n     * The maximum number of writes that can be in a single batch.\r\n     * Visible for testing.\r\n     * @private\r\n     */\n\n    this._maxBatchSize = MAX_BATCH_SIZE;\n    /**\r\n     * The batch that is currently used to schedule operations. Once this batch\r\n     * reaches maximum capacity, a new batch is created.\r\n     * @private\r\n     */\n\n    this._bulkCommitBatch = new BulkCommitBatch(this.firestore);\n    /**\r\n     * A pointer to the tail of all active BulkWriter operations. This pointer\r\n     * is advanced every time a new write is enqueued.\r\n     * @private\r\n     */\n\n    this._lastOp = Promise.resolve();\n    /**\r\n     * Whether this BulkWriter instance has started to close. Afterwards, no\r\n     * new operations can be enqueued, except for retry operations scheduled by\r\n     * the error handler.\r\n     * @private\r\n     */\n\n    this._closing = false;\n    /**\r\n     * The number of pending operations enqueued on this BulkWriter instance.\r\n     * An operation is considered pending if BulkWriter has sent it via RPC and\r\n     * is awaiting the result.\r\n     * @private\r\n     */\n\n    this._pendingOpsCount = 0;\n    /**\r\n     * An array containing buffered BulkWriter operations after the maximum number\r\n     * of pending operations has been enqueued.\r\n     * @private\r\n     */\n\n    this._bufferedOperations = [];\n    /**\r\n     * The maximum number of pending operations that can be enqueued onto this\r\n     * BulkWriter instance. Once the this number of writes have been enqueued,\r\n     * subsequent writes are buffered.\r\n     * @private\r\n     */\n\n    this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;\n    /**\r\n     * The user-provided callback to be run every time a BulkWriter operation\r\n     * successfully completes.\r\n     * @private\r\n     */\n\n    this._successFn = () => {};\n    /**\r\n     * The user-provided callback to be run every time a BulkWriter operation\r\n     * fails.\r\n     * @private\r\n     */\n\n\n    this._errorFn = error => {\n      const isRetryableDeleteError = error.operationType === 'delete' && error.code === 13\n      /* INTERNAL */\n      ;\n      const retryCodes = util_1.getRetryCodes('batchWrite');\n      return (retryCodes.includes(error.code) || isRetryableDeleteError) && error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS;\n    };\n\n    this.firestore._incrementBulkWritersCount();\n\n    validateBulkWriterOptions(options);\n\n    if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n      this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    } else {\n      let startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;\n      let maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;\n\n      if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n        if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n          maxRate = options.throttling.maxOpsPerSecond;\n        }\n\n        if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n          startingRate = options.throttling.initialOpsPerSecond;\n        } // The initial validation step ensures that the maxOpsPerSecond is\n        // greater than initialOpsPerSecond. If this inequality is true, that\n        // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n        // than the default starting rate.\n\n\n        if (maxRate < startingRate) {\n          startingRate = maxRate;\n        } // Ensure that the batch size is not larger than the number of allowed\n        // operations per second.\n\n\n        if (startingRate < this._maxBatchSize) {\n          this._maxBatchSize = startingRate;\n        }\n      }\n\n      this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n    }\n  } // Visible for testing.\n\n\n  _getBufferedOperationsCount() {\n    return this._bufferedOperations.length;\n  } // Visible for testing.\n\n\n  _setMaxPendingOpCount(newMax) {\n    this._maxPendingOpCount = newMax;\n  }\n  /**\r\n   * Create a document with the provided data. This single operation will fail\r\n   * if a document exists at its location.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * created.\r\n   * @param {T} data The object to serialize as the document.\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the write. If the write fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.collection('col').doc();\r\n   *\r\n   * bulkWriter\r\n   *  .create(documentRef, {foo: 'bar'})\r\n   *  .then(result => {\r\n   *    console.log('Successfully executed write at: ', result);\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Write failed with: ', err);\r\n   *  });\r\n   * });\r\n   */\n\n\n  create(documentRef, data) {\n    this._verifyNotClosed();\n\n    const op = this._enqueue(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\r\n   * Delete a document from the database.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * deleted.\r\n   * @param {Precondition=} precondition A precondition to enforce for this\r\n   * delete.\r\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n   * document was last updated at lastUpdateTime. Fails the batch if the\r\n   * document doesn't exist or was last updated at a different time.\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the delete. If the delete fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * bulkWriter\r\n   *  .delete(documentRef)\r\n   *  .then(result => {\r\n   *    console.log('Successfully deleted document');\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Delete failed with: ', err);\r\n   *  });\r\n   * });\r\n   */\n\n\n  delete(documentRef, precondition) {\n    this._verifyNotClosed();\n\n    const op = this._enqueue(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\r\n   * Write to the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document does not\r\n   * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\r\n   * the provided data can be merged into the existing document.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * set.\r\n   * @param {T} data The object to serialize as the document.\r\n   * @param {SetOptions=} options An object to configure the set behavior.\r\n   * @param {boolean=} options.merge - If true, set() merges the values\r\n   * specified in its data argument. Fields omitted from this set() call remain\r\n   * untouched.\r\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\r\n   * only replaces the specified field paths. Any field path that is not\r\n   * specified is ignored and remains untouched.\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the write. If the write fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   *\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.collection('col').doc();\r\n   *\r\n   * bulkWriter\r\n   *  .set(documentRef, {foo: 'bar'})\r\n   *  .then(result => {\r\n   *    console.log('Successfully executed write at: ', result);\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Write failed with: ', err);\r\n   *  });\r\n   * });\r\n   */\n\n\n  set(documentRef, data, options) {\n    this._verifyNotClosed();\n\n    const op = this._enqueue(documentRef, 'set', bulkCommitBatch => bulkCommitBatch.set(documentRef, data, options));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\r\n   * Update fields of the document referred to by the provided\r\n   * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\r\n   * exist, the update fails and the entire batch will be rejected.\r\n   *\r\n   * The update() method accepts either an object with field paths encoded as\r\n   * keys and field values encoded as values, or a variable number of arguments\r\n   * that alternate between field paths and field values. Nested fields can be\r\n   * updated by providing dot-separated field path strings or by providing\r\n   * FieldPath objects.\r\n   *\r\n   *\r\n   * A Precondition restricting this update can be specified as the last\r\n   * argument.\r\n   *\r\n   * @param {DocumentReference} documentRef A reference to the document to be\r\n   * updated.\r\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\r\n   * fields and values with which to update the document or the path of the\r\n   * first field to update.\r\n   * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\r\n   * alternating list of field paths and values to update or a Precondition to\r\n   * restrict this update\r\n   * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n   * the write. If the write fails, the promise is rejected with a\r\n   * [BulkWriterError]{@link BulkWriterError}.\r\n   *\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   * let documentRef = firestore.doc('col/doc');\r\n   *\r\n   * bulkWriter\r\n   *  .update(documentRef, {foo: 'bar'})\r\n   *  .then(result => {\r\n   *    console.log('Successfully executed write at: ', result);\r\n   *  })\r\n   *  .catch(err => {\r\n   *    console.log('Write failed with: ', err);\r\n   *  });\r\n   * });\r\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    this._verifyNotClosed();\n\n    const op = this._enqueue(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));\n\n    util_1.silencePromise(op);\n    return op;\n  }\n  /**\r\n   * Callback function set by {@link BulkWriter#onWriteResult} that is run\r\n   * every time a {@link BulkWriter} operation successfully completes.\r\n   *\r\n   * @callback BulkWriter~successCallback\r\n   * @param {DocumentReference} documentRef The document reference the\r\n   * operation was performed on\r\n   * @param {WriteResult} result The server write time of the operation.\r\n   */\n\n  /**\r\n   * Attaches a listener that is run every time a BulkWriter operation\r\n   * successfully completes.\r\n   *\r\n   * @param {BulkWriter~successCallback} successCallback A callback to be\r\n   * called every time a BulkWriter operation successfully completes.\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter\r\n   *   .onWriteResult((documentRef, result) => {\r\n   *     console.log(\r\n   *       'Successfully executed write on document: ',\r\n   *       documentRef,\r\n   *       ' at: ',\r\n   *       result\r\n   *     );\r\n   *   });\r\n   */\n\n\n  onWriteResult(successCallback) {\n    this._successFn = successCallback;\n  }\n  /**\r\n   * Callback function set by {@link BulkWriter#onWriteError} that is run when\r\n   * a write fails in order to determine whether {@link BulkWriter} should\r\n   * retry the operation.\r\n   *\r\n   * @callback BulkWriter~shouldRetryCallback\r\n   * @param {BulkWriterError} error The error object with information about the\r\n   * operation and error.\r\n   * @returns {boolean} Whether or not to retry the failed operation. Returning\r\n   * `true` retries the operation. Returning `false` will stop the retry loop.\r\n   */\n\n  /**\r\n   * Attaches an error handler listener that is run every time a BulkWriter\r\n   * operation fails.\r\n   *\r\n   * BulkWriter has a default error handler that retries UNAVAILABLE and\r\n   * ABORTED errors up to a maximum of 10 failed attempts. When an error\r\n   * handler is specified, the default error handler will be overwritten.\r\n   *\r\n   * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to\r\n   * be called every time a BulkWriter operation fails. Returning `true` will\r\n   * retry the operation. Returning `false` will stop the retry loop.\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter\r\n   *   .onWriteError((error) => {\r\n   *     if (\r\n   *       error.code === GrpcStatus.UNAVAILABLE &&\r\n   *       error.failedAttempts < MAX_RETRY_ATTEMPTS\r\n   *     ) {\r\n   *       return true;\r\n   *     } else {\r\n   *       console.log('Failed write at document: ', error.documentRef);\r\n   *       return false;\r\n   *     }\r\n   *   });\r\n   */\n\n\n  onWriteError(shouldRetryCallback) {\n    this._errorFn = shouldRetryCallback;\n  }\n  /**\r\n   * Commits all writes that have been enqueued up to this point in parallel.\r\n   *\r\n   * Returns a Promise that resolves when all currently queued operations have\r\n   * been committed. The Promise will never be rejected since the results for\r\n   * each individual operation are conveyed via their individual Promises.\r\n   *\r\n   * The Promise resolves immediately if there are no pending writes. Otherwise,\r\n   * the Promise waits for all previously issued writes, but it does not wait\r\n   * for writes that were added after the method is called. If you want to wait\r\n   * for additional writes, call `flush()` again.\r\n   *\r\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n   * up to this point have been committed.\r\n   *\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter.create(documentRef, {foo: 'bar'});\r\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n   * bulkWriter.delete(documentRef3);\r\n   * await flush().then(() => {\r\n   *   console.log('Executed all writes');\r\n   * });\r\n   */\n\n\n  flush() {\n    this._verifyNotClosed();\n\n    this._scheduleCurrentBatch(\n    /* flush= */\n    true); // Mark the most recent operation as flushed to ensure that the batch\n    // containing it will be sent once it's popped from the buffer.\n\n\n    if (this._bufferedOperations.length > 0) {\n      this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();\n    }\n\n    return this._lastOp;\n  }\n  /**\r\n   * Commits all enqueued writes and marks the BulkWriter instance as closed.\r\n   *\r\n   * After calling `close()`, calling any method will throw an error. Any\r\n   * retries scheduled as part of an `onWriteError()` handler will be run\r\n   * before the `close()` promise resolves.\r\n   *\r\n   * Returns a Promise that resolves when there are no more pending writes. The\r\n   * Promise will never be rejected. Calling this method will send all requests.\r\n   * The promise resolves immediately if there are no pending writes.\r\n   *\r\n   * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n   * up to this point have been committed.\r\n   *\r\n   * @example\r\n   * let bulkWriter = firestore.bulkWriter();\r\n   *\r\n   * bulkWriter.create(documentRef, {foo: 'bar'});\r\n   * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n   * bulkWriter.delete(documentRef3);\r\n   * await close().then(() => {\r\n   *   console.log('Executed all writes');\r\n   * });\r\n   */\n\n\n  close() {\n    this._verifyNotClosed();\n\n    this.firestore._decrementBulkWritersCount();\n\n    const flushPromise = this.flush();\n    this._closing = true;\n    return flushPromise;\n  }\n  /**\r\n   * Throws an error if the BulkWriter instance has been closed.\r\n   * @private\r\n   */\n\n\n  _verifyNotClosed() {\n    if (this._closing) {\n      throw new Error('BulkWriter has already been closed.');\n    }\n  }\n  /**\r\n   * Sends the current batch and resets `this._bulkCommitBatch`.\r\n   *\r\n   * @param flush If provided, keeps re-sending operations until no more\r\n   * operations are enqueued. This allows retries to resolve as part of a\r\n   * `flush()` or `close()` call.\r\n   * @private\r\n   */\n\n\n  _scheduleCurrentBatch(flush = false) {\n    if (this._bulkCommitBatch._opCount === 0) return;\n    const pendingBatch = this._bulkCommitBatch;\n    this._bulkCommitBatch = new BulkCommitBatch(this.firestore); // Use the write with the longest backoff duration when determining backoff.\n\n    const highestBackoffDuration = pendingBatch.pendingOps.reduce((prev, cur) => prev.backoffDuration > cur.backoffDuration ? prev : cur).backoffDuration;\n\n    const backoffMsWithJitter = BulkWriter._applyJitter(highestBackoffDuration);\n\n    const delayedExecution = new util_1.Deferred();\n\n    if (backoffMsWithJitter > 0) {\n      backoff_1.delayExecution(() => delayedExecution.resolve(), backoffMsWithJitter);\n    } else {\n      delayedExecution.resolve();\n    }\n\n    delayedExecution.promise.then(() => this._sendBatch(pendingBatch, flush));\n  }\n  /**\r\n   * Sends the provided batch once the rate limiter does not require any delay.\r\n   * @private\r\n   */\n\n\n  async _sendBatch(batch, flush = false) {\n    const tag = util_1.requestTag(); // Send the batch if it is does not require any delay, or schedule another\n    // attempt after the appropriate timeout.\n\n    const underRateLimit = this._rateLimiter.tryMakeRequest(batch._opCount);\n\n    if (underRateLimit) {\n      await batch.bulkCommit({\n        requestTag: tag\n      });\n      if (flush) this._scheduleCurrentBatch(flush);\n    } else {\n      const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\n\n      logger_1.logger('BulkWriter._sendBatch', tag, `Backing off for ${delayMs} seconds`);\n      backoff_1.delayExecution(() => this._sendBatch(batch, flush), delayMs);\n    }\n  }\n  /**\r\n   * Adds a 30% jitter to the provided backoff.\r\n   *\r\n   * @private\r\n   */\n\n\n  static _applyJitter(backoffMs) {\n    if (backoffMs === 0) return 0; // Random value in [-0.3, 0.3].\n\n    const jitter = exports.DEFAULT_JITTER_FACTOR * (Math.random() * 2 - 1);\n    return Math.min(backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS, backoffMs + jitter * backoffMs);\n  }\n  /**\r\n   * Schedules and runs the provided operation on the next available batch.\r\n   * @private\r\n   */\n\n\n  _enqueue(ref, type, enqueueOnBatchCallback) {\n    const bulkWriterOp = new BulkWriterOperation(ref, type, this._sendFn.bind(this, enqueueOnBatchCallback), this._errorFn.bind(this), this._successFn.bind(this)); // Advance the `_lastOp` pointer. This ensures that `_lastOp` only resolves\n    // when both the previous and the current write resolves.\n\n    this._lastOp = this._lastOp.then(() => util_1.silencePromise(bulkWriterOp.promise)); // Schedule the operation if the BulkWriter has fewer than the maximum\n    // number of allowed pending operations, or add the operation to the\n    // buffer.\n\n    if (this._pendingOpsCount < this._maxPendingOpCount) {\n      this._pendingOpsCount++;\n\n      this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n    } else {\n      this._bufferedOperations.push(new BufferedOperation(bulkWriterOp, () => {\n        this._pendingOpsCount++;\n\n        this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n      }));\n    } // Chain the BulkWriter operation promise with the buffer processing logic\n    // in order to ensure that it runs and that subsequent operations are\n    // enqueued before the next batch is scheduled in `_sendBatch()`.\n\n\n    return bulkWriterOp.promise.then(res => {\n      this._pendingOpsCount--;\n\n      this._processBufferedOps();\n\n      return res;\n    }).catch(err => {\n      this._pendingOpsCount--;\n\n      this._processBufferedOps();\n\n      throw err;\n    });\n  }\n  /**\r\n   * Manages the pending operation counter and schedules the next BulkWriter\r\n   * operation if we're under the maximum limit.\r\n   * @private\r\n   */\n\n\n  _processBufferedOps() {\n    if (this._pendingOpsCount < this._maxPendingOpCount && this._bufferedOperations.length > 0) {\n      const nextOp = this._bufferedOperations.shift();\n\n      nextOp.sendFn();\n    }\n  }\n  /**\r\n   * Schedules the provided operations on current BulkCommitBatch.\r\n   * Sends the BulkCommitBatch if it reaches maximum capacity.\r\n   *\r\n   * @private\r\n   */\n\n\n  _sendFn(enqueueOnBatchCallback, op) {\n    if (this._bulkCommitBatch.has(op.ref)) {\n      // Create a new batch since the backend doesn't support batches with two\n      // writes to the same document.\n      this._scheduleCurrentBatch();\n    }\n\n    enqueueOnBatchCallback(this._bulkCommitBatch);\n\n    this._bulkCommitBatch.processLastOperation(op);\n\n    if (this._bulkCommitBatch._opCount === this._maxBatchSize) {\n      this._scheduleCurrentBatch();\n    } else if (op.flushed) {\n      // If flush() was called before this operation was enqueued into a batch,\n      // we still need to schedule it.\n      this._scheduleCurrentBatch(\n      /* flush= */\n      true);\n    }\n  }\n\n}\n\nexports.BulkWriter = BulkWriter;\n/**\r\n * Validates the use of 'value' as BulkWriterOptions.\r\n *\r\n * @private\r\n * @param value The BulkWriterOptions object to validate.\r\n * @throws if the input is not a valid BulkWriterOptions object.\r\n */\n\nfunction validateBulkWriterOptions(value) {\n  if (validate_1.validateOptional(value, {\n    optional: true\n  })) {\n    return;\n  }\n\n  const argName = 'options';\n\n  if (!util_1.isObject(value)) {\n    throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} Input is not an object.`);\n  }\n\n  const options = value;\n\n  if (options.throttling === undefined || typeof options.throttling === 'boolean') {\n    return;\n  }\n\n  if (options.throttling.initialOpsPerSecond !== undefined) {\n    validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n      minValue: 1\n    });\n  }\n\n  if (options.throttling.maxOpsPerSecond !== undefined) {\n    validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n      minValue: 1\n    });\n\n    if (options.throttling.initialOpsPerSecond !== undefined && options.throttling.initialOpsPerSecond > options.throttling.maxOpsPerSecond) {\n      throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/@google-cloud/firestore/build/src/bulk-writer.js"],"names":["Object","defineProperty","exports","value","assert","require","backoff_1","rate_limiter_1","timestamp_1","util_1","write_batch_1","validate_1","logger_1","MAX_BATCH_SIZE","DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT","DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT","DEFAULT_JITTER_FACTOR","RATE_LIMITER_MULTIPLIER","RATE_LIMITER_MULTIPLIER_MILLIS","DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT","BulkWriterOperation","constructor","ref","type","sendFn","errorFn","successFn","deferred","Deferred","failedAttempts","_backoffDuration","_flushed","promise","backoffDuration","markFlushed","flushed","onError","error","bulkWriterError","BulkWriterError","code","message","shouldRetry","logger","path","lastStatus","updateBackoffDuration","reject","userCallbackError","DEFAULT_BACKOFF_MAX_DELAY_MS","DEFAULT_BACKOFF_INITIAL_DELAY_MS","DEFAULT_BACKOFF_FACTOR","onSuccess","result","resolve","BulkCommitBatch","WriteBatch","arguments","docPaths","Set","pendingOps","has","documentRef","bulkCommit","options","_a","tag","requestTag","stack","Error","response","_opCount","retryCodes","getRetryCodes","_commit","methodName","err","ops","Array","from","length","writeResults","map","status","i","DELETE_TIMESTAMP_SENTINEL","Timestamp","fromMillis","updateTime","fromProto","WriteResult","GoogleError","undefined","wrapError","processLastOperation","op","add","push","BufferedOperation","operation","operationType","BulkWriter","firestore","_b","_maxBatchSize","_bulkCommitBatch","_lastOp","Promise","_closing","_pendingOpsCount","_bufferedOperations","_maxPendingOpCount","_successFn","_errorFn","isRetryableDeleteError","includes","MAX_RETRY_ATTEMPTS","_incrementBulkWritersCount","validateBulkWriterOptions","throttling","_rateLimiter","RateLimiter","Number","POSITIVE_INFINITY","startingRate","maxRate","maxOpsPerSecond","initialOpsPerSecond","_getBufferedOperationsCount","_setMaxPendingOpCount","newMax","create","data","_verifyNotClosed","_enqueue","bulkCommitBatch","silencePromise","delete","precondition","set","update","dataOrField","preconditionOrValues","onWriteResult","successCallback","onWriteError","shouldRetryCallback","flush","_scheduleCurrentBatch","close","_decrementBulkWritersCount","flushPromise","pendingBatch","highestBackoffDuration","reduce","prev","cur","backoffMsWithJitter","_applyJitter","delayedExecution","delayExecution","then","_sendBatch","batch","underRateLimit","tryMakeRequest","delayMs","getNextRequestDelayMs","backoffMs","jitter","Math","random","min","enqueueOnBatchCallback","bulkWriterOp","_sendFn","bind","res","_processBufferedOps","catch","nextOp","shift","validateOptional","optional","argName","isObject","invalidArgumentMessage","validateInteger","minValue"],"mappings":"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ACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI6C,EAAAA,MAAM,CAAC9E,WAAD,EAAc+E,WAAd,EAA2B,GAAGC,oBAA9B,EAAoD;AACtD,SAAKT,gBAAL;;AACA,UAAMtC,EAAE,GAAG,KAAKuC,QAAL,CAAcxE,WAAd,EAA2B,QAA3B,EAAqCyE,eAAe,IAAIA,eAAe,CAACK,MAAhB,CAAuB9E,WAAvB,EAAoC+E,WAApC,EAAiD,GAAGC,oBAApD,CAAxD,CAAX;;AACArI,IAAAA,MAAM,CAAC+H,cAAP,CAAsBzC,EAAtB;AACA,WAAOA,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIgD,EAAAA,aAAa,CAACC,eAAD,EAAkB;AAC3B,SAAKhC,UAAL,GAAkBgC,eAAlB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,YAAY,CAACC,mBAAD,EAAsB;AAC9B,SAAKjC,QAAL,GAAgBiC,mBAAhB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,KAAK,GAAG;AACJ,SAAKd,gBAAL;;AACA,SAAKe,qBAAL;AAA2B;AAAa,QAAxC,EAF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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assert = require(\"assert\");\r\nconst backoff_1 = require(\"./backoff\");\r\nconst rate_limiter_1 = require(\"./rate-limiter\");\r\nconst timestamp_1 = require(\"./timestamp\");\r\nconst util_1 = require(\"./util\");\r\nconst write_batch_1 = require(\"./write-batch\");\r\nconst validate_1 = require(\"./validate\");\r\nconst logger_1 = require(\"./logger\");\r\n/*!\r\n * The maximum number of writes that can be in a single batch.\r\n */\r\nconst MAX_BATCH_SIZE = 20;\r\n/*!\r\n * The starting maximum number of operations per second as allowed by the\r\n * 500/50/5 rule.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\r\nexports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;\r\n/*!\r\n * The maximum number of operations per second as allowed by the 500/50/5 rule.\r\n * By default the rate limiter will not exceed this value.\r\n *\r\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\r\n */\r\nexports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;\r\n/*!\r\n * The default jitter to apply to the exponential backoff used in retries. For\r\n * example, a factor of 0.3 means a 30% jitter is applied.\r\n */\r\nexports.DEFAULT_JITTER_FACTOR = 0.3;\r\n/*!\r\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\r\n */\r\nconst RATE_LIMITER_MULTIPLIER = 1.5;\r\n/*!\r\n * How often the operations per second capacity should increase in milliseconds\r\n * as specified by the 500/50/5 rule.\r\n */\r\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\r\n/*!\r\n * The default maximum number of pending operations that can be enqueued onto a\r\n * BulkWriter instance. An operation is considered pending if BulkWriter has\r\n * sent it via RPC and is awaiting the result. BulkWriter buffers additional\r\n * writes after this many pending operations in order to avoiding going OOM.\r\n */\r\nconst DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;\r\n/**\r\n * Represents a single write for BulkWriter, encapsulating operation dispatch\r\n * and error handling.\r\n * @private\r\n */\r\nclass BulkWriterOperation {\r\n    /**\r\n     * @param ref The document reference being written to.\r\n     * @param type The type of operation that created this write.\r\n     * @param sendFn A callback to invoke when the operation should be sent.\r\n     * @param errorFn The user provided global error callback.\r\n     * @param successFn The user provided global success callback.\r\n     */\r\n    constructor(ref, type, sendFn, errorFn, successFn) {\r\n        this.ref = ref;\r\n        this.type = type;\r\n        this.sendFn = sendFn;\r\n        this.errorFn = errorFn;\r\n        this.successFn = successFn;\r\n        this.deferred = new util_1.Deferred();\r\n        this.failedAttempts = 0;\r\n        this._backoffDuration = 0;\r\n        /** Whether flush() was called when this was the last enqueued operation. */\r\n        this._flushed = false;\r\n    }\r\n    get promise() {\r\n        return this.deferred.promise;\r\n    }\r\n    get backoffDuration() {\r\n        return this._backoffDuration;\r\n    }\r\n    markFlushed() {\r\n        this._flushed = true;\r\n    }\r\n    get flushed() {\r\n        return this._flushed;\r\n    }\r\n    onError(error) {\r\n        ++this.failedAttempts;\r\n        try {\r\n            const bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);\r\n            const shouldRetry = this.errorFn(bulkWriterError);\r\n            logger_1.logger('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);\r\n            if (shouldRetry) {\r\n                this.lastStatus = error.code;\r\n                this.updateBackoffDuration();\r\n                this.sendFn(this);\r\n            }\r\n            else {\r\n                this.deferred.reject(bulkWriterError);\r\n            }\r\n        }\r\n        catch (userCallbackError) {\r\n            this.deferred.reject(userCallbackError);\r\n        }\r\n    }\r\n    updateBackoffDuration() {\r\n        if (this.lastStatus === 8 /* RESOURCE_EXHAUSTED */) {\r\n            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;\r\n        }\r\n        else if (this._backoffDuration === 0) {\r\n            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\r\n        }\r\n        else {\r\n            this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;\r\n        }\r\n    }\r\n    onSuccess(result) {\r\n        try {\r\n            this.successFn(this.ref, result);\r\n            this.deferred.resolve(result);\r\n        }\r\n        catch (userCallbackError) {\r\n            this.deferred.reject(userCallbackError);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Used to represent a batch on the BatchQueue.\r\n *\r\n * @private\r\n */\r\nclass BulkCommitBatch extends write_batch_1.WriteBatch {\r\n    constructor() {\r\n        super(...arguments);\r\n        // The set of document reference paths present in the WriteBatch.\r\n        this.docPaths = new Set();\r\n        // An array of pending write operations. Only contains writes that have not\r\n        // been resolved.\r\n        this.pendingOps = [];\r\n    }\r\n    has(documentRef) {\r\n        return this.docPaths.has(documentRef.path);\r\n    }\r\n    async bulkCommit(options = {}) {\r\n        var _a;\r\n        const tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : util_1.requestTag();\r\n        // Capture the error stack to preserve stack tracing across async calls.\r\n        const stack = Error().stack;\r\n        let response;\r\n        try {\r\n            logger_1.logger('BulkCommitBatch.bulkCommit', tag, `Sending next batch with ${this._opCount} writes`);\r\n            const retryCodes = util_1.getRetryCodes('batchWrite');\r\n            response = await this._commit({ retryCodes, methodName: 'batchWrite', requestTag: tag });\r\n        }\r\n        catch (err) {\r\n            // Map the failure to each individual write's result.\r\n            const ops = Array.from({ length: this.pendingOps.length });\r\n            response = {\r\n                writeResults: ops.map(() => {\r\n                    return {};\r\n                }),\r\n                status: ops.map(() => err),\r\n            };\r\n        }\r\n        for (let i = 0; i < (response.writeResults || []).length; ++i) {\r\n            // Since delete operations currently do not have write times, use a\r\n            // sentinel Timestamp value.\r\n            // TODO(b/158502664): Use actual delete timestamp.\r\n            const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\r\n            const status = (response.status || [])[i];\r\n            if (status.code === 0 /* OK */) {\r\n                const updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);\r\n                this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));\r\n            }\r\n            else {\r\n                const error = new (require('google-gax').GoogleError)(status.message || undefined);\r\n                error.code = status.code;\r\n                this.pendingOps[i].onError(util_1.wrapError(error, stack));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Helper to update data structures associated with the operation and returns\r\n     * the result.\r\n     */\r\n    processLastOperation(op) {\r\n        assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');\r\n        this.docPaths.add(op.ref.path);\r\n        this.pendingOps.push(op);\r\n    }\r\n}\r\n/**\r\n * Used to represent a buffered BulkWriterOperation.\r\n *\r\n * @private\r\n */\r\nclass BufferedOperation {\r\n    constructor(operation, sendFn) {\r\n        this.operation = operation;\r\n        this.sendFn = sendFn;\r\n    }\r\n}\r\n/**\r\n * The error thrown when a BulkWriter operation fails.\r\n *\r\n * @class BulkWriterError\r\n */\r\nclass BulkWriterError extends Error {\r\n    /** @hideconstructor */\r\n    constructor(\r\n    /** The status code of the error. */\r\n    code, \r\n    /** The error message of the error. */\r\n    message, \r\n    /** The document reference the operation was performed on. */\r\n    documentRef, \r\n    /** The type of operation performed. */\r\n    operationType, \r\n    /** How many times this operation has been attempted unsuccessfully. */\r\n    failedAttempts) {\r\n        super(message);\r\n        this.code = code;\r\n        this.message = message;\r\n        this.documentRef = documentRef;\r\n        this.operationType = operationType;\r\n        this.failedAttempts = failedAttempts;\r\n    }\r\n}\r\nexports.BulkWriterError = BulkWriterError;\r\n/**\r\n * A Firestore BulkWriter that can be used to perform a large number of writes\r\n * in parallel.\r\n *\r\n * @class BulkWriter\r\n */\r\nclass BulkWriter {\r\n    /** @hideconstructor */\r\n    constructor(firestore, options) {\r\n        var _a, _b;\r\n        this.firestore = firestore;\r\n        /**\r\n         * The maximum number of writes that can be in a single batch.\r\n         * Visible for testing.\r\n         * @private\r\n         */\r\n        this._maxBatchSize = MAX_BATCH_SIZE;\r\n        /**\r\n         * The batch that is currently used to schedule operations. Once this batch\r\n         * reaches maximum capacity, a new batch is created.\r\n         * @private\r\n         */\r\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore);\r\n        /**\r\n         * A pointer to the tail of all active BulkWriter operations. This pointer\r\n         * is advanced every time a new write is enqueued.\r\n         * @private\r\n         */\r\n        this._lastOp = Promise.resolve();\r\n        /**\r\n         * Whether this BulkWriter instance has started to close. Afterwards, no\r\n         * new operations can be enqueued, except for retry operations scheduled by\r\n         * the error handler.\r\n         * @private\r\n         */\r\n        this._closing = false;\r\n        /**\r\n         * The number of pending operations enqueued on this BulkWriter instance.\r\n         * An operation is considered pending if BulkWriter has sent it via RPC and\r\n         * is awaiting the result.\r\n         * @private\r\n         */\r\n        this._pendingOpsCount = 0;\r\n        /**\r\n         * An array containing buffered BulkWriter operations after the maximum number\r\n         * of pending operations has been enqueued.\r\n         * @private\r\n         */\r\n        this._bufferedOperations = [];\r\n        /**\r\n         * The maximum number of pending operations that can be enqueued onto this\r\n         * BulkWriter instance. Once the this number of writes have been enqueued,\r\n         * subsequent writes are buffered.\r\n         * @private\r\n         */\r\n        this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;\r\n        /**\r\n         * The user-provided callback to be run every time a BulkWriter operation\r\n         * successfully completes.\r\n         * @private\r\n         */\r\n        this._successFn = () => { };\r\n        /**\r\n         * The user-provided callback to be run every time a BulkWriter operation\r\n         * fails.\r\n         * @private\r\n         */\r\n        this._errorFn = error => {\r\n            const isRetryableDeleteError = error.operationType === 'delete' &&\r\n                error.code === 13 /* INTERNAL */;\r\n            const retryCodes = util_1.getRetryCodes('batchWrite');\r\n            return ((retryCodes.includes(error.code) || isRetryableDeleteError) &&\r\n                error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS);\r\n        };\r\n        this.firestore._incrementBulkWritersCount();\r\n        validateBulkWriterOptions(options);\r\n        if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\r\n            this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\r\n        }\r\n        else {\r\n            let startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;\r\n            let maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;\r\n            if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\r\n                if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\r\n                    maxRate = options.throttling.maxOpsPerSecond;\r\n                }\r\n                if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\r\n                    startingRate = options.throttling.initialOpsPerSecond;\r\n                }\r\n                // The initial validation step ensures that the maxOpsPerSecond is\r\n                // greater than initialOpsPerSecond. If this inequality is true, that\r\n                // means initialOpsPerSecond was not set and maxOpsPerSecond is less\r\n                // than the default starting rate.\r\n                if (maxRate < startingRate) {\r\n                    startingRate = maxRate;\r\n                }\r\n                // Ensure that the batch size is not larger than the number of allowed\r\n                // operations per second.\r\n                if (startingRate < this._maxBatchSize) {\r\n                    this._maxBatchSize = startingRate;\r\n                }\r\n            }\r\n            this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\r\n        }\r\n    }\r\n    // Visible for testing.\r\n    _getBufferedOperationsCount() {\r\n        return this._bufferedOperations.length;\r\n    }\r\n    // Visible for testing.\r\n    _setMaxPendingOpCount(newMax) {\r\n        this._maxPendingOpCount = newMax;\r\n    }\r\n    /**\r\n     * Create a document with the provided data. This single operation will fail\r\n     * if a document exists at its location.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * created.\r\n     * @param {T} data The object to serialize as the document.\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the write. If the write fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.collection('col').doc();\r\n     *\r\n     * bulkWriter\r\n     *  .create(documentRef, {foo: 'bar'})\r\n     *  .then(result => {\r\n     *    console.log('Successfully executed write at: ', result);\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Write failed with: ', err);\r\n     *  });\r\n     * });\r\n     */\r\n    create(documentRef, data) {\r\n        this._verifyNotClosed();\r\n        const op = this._enqueue(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));\r\n        util_1.silencePromise(op);\r\n        return op;\r\n    }\r\n    /**\r\n     * Delete a document from the database.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * deleted.\r\n     * @param {Precondition=} precondition A precondition to enforce for this\r\n     * delete.\r\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\r\n     * document was last updated at lastUpdateTime. Fails the batch if the\r\n     * document doesn't exist or was last updated at a different time.\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the delete. If the delete fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * bulkWriter\r\n     *  .delete(documentRef)\r\n     *  .then(result => {\r\n     *    console.log('Successfully deleted document');\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Delete failed with: ', err);\r\n     *  });\r\n     * });\r\n     */\r\n    delete(documentRef, precondition) {\r\n        this._verifyNotClosed();\r\n        const op = this._enqueue(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));\r\n        util_1.silencePromise(op);\r\n        return op;\r\n    }\r\n    /**\r\n     * Write to the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document does not\r\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\r\n     * the provided data can be merged into the existing document.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * set.\r\n     * @param {T} data The object to serialize as the document.\r\n     * @param {SetOptions=} options An object to configure the set behavior.\r\n     * @param {boolean=} options.merge - If true, set() merges the values\r\n     * specified in its data argument. Fields omitted from this set() call remain\r\n     * untouched.\r\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\r\n     * only replaces the specified field paths. Any field path that is not\r\n     * specified is ignored and remains untouched.\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the write. If the write fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     *\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.collection('col').doc();\r\n     *\r\n     * bulkWriter\r\n     *  .set(documentRef, {foo: 'bar'})\r\n     *  .then(result => {\r\n     *    console.log('Successfully executed write at: ', result);\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Write failed with: ', err);\r\n     *  });\r\n     * });\r\n     */\r\n    set(documentRef, data, options) {\r\n        this._verifyNotClosed();\r\n        const op = this._enqueue(documentRef, 'set', bulkCommitBatch => bulkCommitBatch.set(documentRef, data, options));\r\n        util_1.silencePromise(op);\r\n        return op;\r\n    }\r\n    /**\r\n     * Update fields of the document referred to by the provided\r\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\r\n     * exist, the update fails and the entire batch will be rejected.\r\n     *\r\n     * The update() method accepts either an object with field paths encoded as\r\n     * keys and field values encoded as values, or a variable number of arguments\r\n     * that alternate between field paths and field values. Nested fields can be\r\n     * updated by providing dot-separated field path strings or by providing\r\n     * FieldPath objects.\r\n     *\r\n     *\r\n     * A Precondition restricting this update can be specified as the last\r\n     * argument.\r\n     *\r\n     * @param {DocumentReference} documentRef A reference to the document to be\r\n     * updated.\r\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\r\n     * fields and values with which to update the document or the path of the\r\n     * first field to update.\r\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\r\n     * alternating list of field paths and values to update or a Precondition to\r\n     * restrict this update\r\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\r\n     * the write. If the write fails, the promise is rejected with a\r\n     * [BulkWriterError]{@link BulkWriterError}.\r\n     *\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     * let documentRef = firestore.doc('col/doc');\r\n     *\r\n     * bulkWriter\r\n     *  .update(documentRef, {foo: 'bar'})\r\n     *  .then(result => {\r\n     *    console.log('Successfully executed write at: ', result);\r\n     *  })\r\n     *  .catch(err => {\r\n     *    console.log('Write failed with: ', err);\r\n     *  });\r\n     * });\r\n     */\r\n    update(documentRef, dataOrField, ...preconditionOrValues) {\r\n        this._verifyNotClosed();\r\n        const op = this._enqueue(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));\r\n        util_1.silencePromise(op);\r\n        return op;\r\n    }\r\n    /**\r\n     * Callback function set by {@link BulkWriter#onWriteResult} that is run\r\n     * every time a {@link BulkWriter} operation successfully completes.\r\n     *\r\n     * @callback BulkWriter~successCallback\r\n     * @param {DocumentReference} documentRef The document reference the\r\n     * operation was performed on\r\n     * @param {WriteResult} result The server write time of the operation.\r\n     */\r\n    /**\r\n     * Attaches a listener that is run every time a BulkWriter operation\r\n     * successfully completes.\r\n     *\r\n     * @param {BulkWriter~successCallback} successCallback A callback to be\r\n     * called every time a BulkWriter operation successfully completes.\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter\r\n     *   .onWriteResult((documentRef, result) => {\r\n     *     console.log(\r\n     *       'Successfully executed write on document: ',\r\n     *       documentRef,\r\n     *       ' at: ',\r\n     *       result\r\n     *     );\r\n     *   });\r\n     */\r\n    onWriteResult(successCallback) {\r\n        this._successFn = successCallback;\r\n    }\r\n    /**\r\n     * Callback function set by {@link BulkWriter#onWriteError} that is run when\r\n     * a write fails in order to determine whether {@link BulkWriter} should\r\n     * retry the operation.\r\n     *\r\n     * @callback BulkWriter~shouldRetryCallback\r\n     * @param {BulkWriterError} error The error object with information about the\r\n     * operation and error.\r\n     * @returns {boolean} Whether or not to retry the failed operation. Returning\r\n     * `true` retries the operation. Returning `false` will stop the retry loop.\r\n     */\r\n    /**\r\n     * Attaches an error handler listener that is run every time a BulkWriter\r\n     * operation fails.\r\n     *\r\n     * BulkWriter has a default error handler that retries UNAVAILABLE and\r\n     * ABORTED errors up to a maximum of 10 failed attempts. When an error\r\n     * handler is specified, the default error handler will be overwritten.\r\n     *\r\n     * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to\r\n     * be called every time a BulkWriter operation fails. Returning `true` will\r\n     * retry the operation. Returning `false` will stop the retry loop.\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter\r\n     *   .onWriteError((error) => {\r\n     *     if (\r\n     *       error.code === GrpcStatus.UNAVAILABLE &&\r\n     *       error.failedAttempts < MAX_RETRY_ATTEMPTS\r\n     *     ) {\r\n     *       return true;\r\n     *     } else {\r\n     *       console.log('Failed write at document: ', error.documentRef);\r\n     *       return false;\r\n     *     }\r\n     *   });\r\n     */\r\n    onWriteError(shouldRetryCallback) {\r\n        this._errorFn = shouldRetryCallback;\r\n    }\r\n    /**\r\n     * Commits all writes that have been enqueued up to this point in parallel.\r\n     *\r\n     * Returns a Promise that resolves when all currently queued operations have\r\n     * been committed. The Promise will never be rejected since the results for\r\n     * each individual operation are conveyed via their individual Promises.\r\n     *\r\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\r\n     * the Promise waits for all previously issued writes, but it does not wait\r\n     * for writes that were added after the method is called. If you want to wait\r\n     * for additional writes, call `flush()` again.\r\n     *\r\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n     * up to this point have been committed.\r\n     *\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter.create(documentRef, {foo: 'bar'});\r\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n     * bulkWriter.delete(documentRef3);\r\n     * await flush().then(() => {\r\n     *   console.log('Executed all writes');\r\n     * });\r\n     */\r\n    flush() {\r\n        this._verifyNotClosed();\r\n        this._scheduleCurrentBatch(/* flush= */ true);\r\n        // Mark the most recent operation as flushed to ensure that the batch\r\n        // containing it will be sent once it's popped from the buffer.\r\n        if (this._bufferedOperations.length > 0) {\r\n            this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();\r\n        }\r\n        return this._lastOp;\r\n    }\r\n    /**\r\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\r\n     *\r\n     * After calling `close()`, calling any method will throw an error. Any\r\n     * retries scheduled as part of an `onWriteError()` handler will be run\r\n     * before the `close()` promise resolves.\r\n     *\r\n     * Returns a Promise that resolves when there are no more pending writes. The\r\n     * Promise will never be rejected. Calling this method will send all requests.\r\n     * The promise resolves immediately if there are no pending writes.\r\n     *\r\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\r\n     * up to this point have been committed.\r\n     *\r\n     * @example\r\n     * let bulkWriter = firestore.bulkWriter();\r\n     *\r\n     * bulkWriter.create(documentRef, {foo: 'bar'});\r\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\r\n     * bulkWriter.delete(documentRef3);\r\n     * await close().then(() => {\r\n     *   console.log('Executed all writes');\r\n     * });\r\n     */\r\n    close() {\r\n        this._verifyNotClosed();\r\n        this.firestore._decrementBulkWritersCount();\r\n        const flushPromise = this.flush();\r\n        this._closing = true;\r\n        return flushPromise;\r\n    }\r\n    /**\r\n     * Throws an error if the BulkWriter instance has been closed.\r\n     * @private\r\n     */\r\n    _verifyNotClosed() {\r\n        if (this._closing) {\r\n            throw new Error('BulkWriter has already been closed.');\r\n        }\r\n    }\r\n    /**\r\n     * Sends the current batch and resets `this._bulkCommitBatch`.\r\n     *\r\n     * @param flush If provided, keeps re-sending operations until no more\r\n     * operations are enqueued. This allows retries to resolve as part of a\r\n     * `flush()` or `close()` call.\r\n     * @private\r\n     */\r\n    _scheduleCurrentBatch(flush = false) {\r\n        if (this._bulkCommitBatch._opCount === 0)\r\n            return;\r\n        const pendingBatch = this._bulkCommitBatch;\r\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore);\r\n        // Use the write with the longest backoff duration when determining backoff.\r\n        const highestBackoffDuration = pendingBatch.pendingOps.reduce((prev, cur) => prev.backoffDuration > cur.backoffDuration ? prev : cur).backoffDuration;\r\n        const backoffMsWithJitter = BulkWriter._applyJitter(highestBackoffDuration);\r\n        const delayedExecution = new util_1.Deferred();\r\n        if (backoffMsWithJitter > 0) {\r\n            backoff_1.delayExecution(() => delayedExecution.resolve(), backoffMsWithJitter);\r\n        }\r\n        else {\r\n            delayedExecution.resolve();\r\n        }\r\n        delayedExecution.promise.then(() => this._sendBatch(pendingBatch, flush));\r\n    }\r\n    /**\r\n     * Sends the provided batch once the rate limiter does not require any delay.\r\n     * @private\r\n     */\r\n    async _sendBatch(batch, flush = false) {\r\n        const tag = util_1.requestTag();\r\n        // Send the batch if it is does not require any delay, or schedule another\r\n        // attempt after the appropriate timeout.\r\n        const underRateLimit = this._rateLimiter.tryMakeRequest(batch._opCount);\r\n        if (underRateLimit) {\r\n            await batch.bulkCommit({ requestTag: tag });\r\n            if (flush)\r\n                this._scheduleCurrentBatch(flush);\r\n        }\r\n        else {\r\n            const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\r\n            logger_1.logger('BulkWriter._sendBatch', tag, `Backing off for ${delayMs} seconds`);\r\n            backoff_1.delayExecution(() => this._sendBatch(batch, flush), delayMs);\r\n        }\r\n    }\r\n    /**\r\n     * Adds a 30% jitter to the provided backoff.\r\n     *\r\n     * @private\r\n     */\r\n    static _applyJitter(backoffMs) {\r\n        if (backoffMs === 0)\r\n            return 0;\r\n        // Random value in [-0.3, 0.3].\r\n        const jitter = exports.DEFAULT_JITTER_FACTOR * (Math.random() * 2 - 1);\r\n        return Math.min(backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS, backoffMs + jitter * backoffMs);\r\n    }\r\n    /**\r\n     * Schedules and runs the provided operation on the next available batch.\r\n     * @private\r\n     */\r\n    _enqueue(ref, type, enqueueOnBatchCallback) {\r\n        const bulkWriterOp = new BulkWriterOperation(ref, type, this._sendFn.bind(this, enqueueOnBatchCallback), this._errorFn.bind(this), this._successFn.bind(this));\r\n        // Advance the `_lastOp` pointer. This ensures that `_lastOp` only resolves\r\n        // when both the previous and the current write resolves.\r\n        this._lastOp = this._lastOp.then(() => util_1.silencePromise(bulkWriterOp.promise));\r\n        // Schedule the operation if the BulkWriter has fewer than the maximum\r\n        // number of allowed pending operations, or add the operation to the\r\n        // buffer.\r\n        if (this._pendingOpsCount < this._maxPendingOpCount) {\r\n            this._pendingOpsCount++;\r\n            this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\r\n        }\r\n        else {\r\n            this._bufferedOperations.push(new BufferedOperation(bulkWriterOp, () => {\r\n                this._pendingOpsCount++;\r\n                this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\r\n            }));\r\n        }\r\n        // Chain the BulkWriter operation promise with the buffer processing logic\r\n        // in order to ensure that it runs and that subsequent operations are\r\n        // enqueued before the next batch is scheduled in `_sendBatch()`.\r\n        return bulkWriterOp.promise\r\n            .then(res => {\r\n            this._pendingOpsCount--;\r\n            this._processBufferedOps();\r\n            return res;\r\n        })\r\n            .catch(err => {\r\n            this._pendingOpsCount--;\r\n            this._processBufferedOps();\r\n            throw err;\r\n        });\r\n    }\r\n    /**\r\n     * Manages the pending operation counter and schedules the next BulkWriter\r\n     * operation if we're under the maximum limit.\r\n     * @private\r\n     */\r\n    _processBufferedOps() {\r\n        if (this._pendingOpsCount < this._maxPendingOpCount &&\r\n            this._bufferedOperations.length > 0) {\r\n            const nextOp = this._bufferedOperations.shift();\r\n            nextOp.sendFn();\r\n        }\r\n    }\r\n    /**\r\n     * Schedules the provided operations on current BulkCommitBatch.\r\n     * Sends the BulkCommitBatch if it reaches maximum capacity.\r\n     *\r\n     * @private\r\n     */\r\n    _sendFn(enqueueOnBatchCallback, op) {\r\n        if (this._bulkCommitBatch.has(op.ref)) {\r\n            // Create a new batch since the backend doesn't support batches with two\r\n            // writes to the same document.\r\n            this._scheduleCurrentBatch();\r\n        }\r\n        enqueueOnBatchCallback(this._bulkCommitBatch);\r\n        this._bulkCommitBatch.processLastOperation(op);\r\n        if (this._bulkCommitBatch._opCount === this._maxBatchSize) {\r\n            this._scheduleCurrentBatch();\r\n        }\r\n        else if (op.flushed) {\r\n            // If flush() was called before this operation was enqueued into a batch,\r\n            // we still need to schedule it.\r\n            this._scheduleCurrentBatch(/* flush= */ true);\r\n        }\r\n    }\r\n}\r\nexports.BulkWriter = BulkWriter;\r\n/**\r\n * Validates the use of 'value' as BulkWriterOptions.\r\n *\r\n * @private\r\n * @param value The BulkWriterOptions object to validate.\r\n * @throws if the input is not a valid BulkWriterOptions object.\r\n */\r\nfunction validateBulkWriterOptions(value) {\r\n    if (validate_1.validateOptional(value, { optional: true })) {\r\n        return;\r\n    }\r\n    const argName = 'options';\r\n    if (!util_1.isObject(value)) {\r\n        throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} Input is not an object.`);\r\n    }\r\n    const options = value;\r\n    if (options.throttling === undefined ||\r\n        typeof options.throttling === 'boolean') {\r\n        return;\r\n    }\r\n    if (options.throttling.initialOpsPerSecond !== undefined) {\r\n        validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\r\n            minValue: 1,\r\n        });\r\n    }\r\n    if (options.throttling.maxOpsPerSecond !== undefined) {\r\n        validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\r\n            minValue: 1,\r\n        });\r\n        if (options.throttling.initialOpsPerSecond !== undefined &&\r\n            options.throttling.initialOpsPerSecond >\r\n                options.throttling.maxOpsPerSecond) {\r\n            throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=bulk-writer.js.map"]},"metadata":{},"sourceType":"script"}