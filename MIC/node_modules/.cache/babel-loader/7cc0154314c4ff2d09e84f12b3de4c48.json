{"ast":null,"code":"const {\n  inherits\n} = require('util');\n\nconst {\n  Reporter\n} = require('../base/reporter');\n\nfunction DecoderBuffer(base, options) {\n  Reporter.call(this, options);\n\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer');\n    return;\n  }\n\n  this.base = base;\n  this.offset = 0;\n  this.length = base.length;\n}\n\ninherits(DecoderBuffer, Reporter);\n\nDecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {\n  if (data instanceof DecoderBuffer) {\n    return true;\n  } // Or accept compatible API\n\n\n  const isCompatible = typeof data === 'object' && Buffer.isBuffer(data.base) && data.constructor.name === 'DecoderBuffer' && typeof data.offset === 'number' && typeof data.length === 'number' && typeof data.save === 'function' && typeof data.restore === 'function' && typeof data.isEmpty === 'function' && typeof data.readUInt8 === 'function' && typeof data.skip === 'function' && typeof data.raw === 'function';\n  return isCompatible;\n};\n\nDecoderBuffer.prototype.save = function save() {\n  return {\n    offset: this.offset,\n    reporter: Reporter.prototype.save.call(this)\n  };\n};\n\nDecoderBuffer.prototype.restore = function restore(save) {\n  // Return skipped data\n  const res = new DecoderBuffer(this.base);\n  res.offset = save.offset;\n  res.length = this.offset;\n  this.offset = save.offset;\n  Reporter.prototype.restore.call(this, save.reporter);\n  return res;\n};\n\nDecoderBuffer.prototype.isEmpty = function isEmpty() {\n  return this.offset === this.length;\n};\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\n  if (this.offset + 1 <= this.length) {\n    return this.base.readUInt8(this.offset++, true);\n  } else {\n    return this.error(fail || 'DecoderBuffer overrun');\n  }\n};\n\nDecoderBuffer.prototype.skip = function skip(bytes, fail) {\n  if (!(this.offset + bytes <= this.length)) {\n    return this.error(fail || 'DecoderBuffer overrun');\n  }\n\n  const res = new DecoderBuffer(this.base); // Share reporter state\n\n  res._reporterState = this._reporterState;\n  res.offset = this.offset;\n  res.length = this.offset + bytes;\n  this.offset += bytes;\n  return res;\n};\n\nDecoderBuffer.prototype.raw = function raw(save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length);\n};\n\nfunction EncoderBuffer(value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0;\n    this.value = value.map(function (item) {\n      if (!EncoderBuffer.isEncoderBuffer(item)) {\n        item = new EncoderBuffer(item, reporter);\n      }\n\n      this.length += item.length;\n      return item;\n    }, this);\n  } else if (typeof value === 'number') {\n    if (!(value >= 0 && value <= 0xff)) {\n      return reporter.error('non-byte EncoderBuffer value');\n    }\n\n    this.value = value;\n    this.length = 1;\n  } else if (typeof value === 'string') {\n    this.value = value;\n    this.length = Buffer.byteLength(value);\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value;\n    this.length = value.length;\n  } else {\n    return reporter.error(`Unsupported type: ${typeof value}`);\n  }\n}\n\nEncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {\n  if (data instanceof EncoderBuffer) {\n    return true;\n  } // Or accept compatible API\n\n\n  const isCompatible = typeof data === 'object' && data.constructor.name === 'EncoderBuffer' && typeof data.length === 'number' && typeof data.join === 'function';\n  return isCompatible;\n};\n\nEncoderBuffer.prototype.join = function join(out, offset) {\n  if (!out) {\n    out = Buffer.alloc(this.length);\n  }\n\n  if (!offset) {\n    offset = 0;\n  }\n\n  if (this.length === 0) {\n    return out;\n  }\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function (item) {\n      item.join(out, offset);\n      offset += item.length;\n    });\n  } else {\n    if (typeof this.value === 'number') {\n      out[offset] = this.value;\n    } else if (typeof this.value === 'string') {\n      out.write(this.value, offset);\n    } else if (Buffer.isBuffer(this.value)) {\n      this.value.copy(out, offset);\n    }\n\n    offset += this.length;\n  }\n\n  return out;\n};\n\nmodule.exports = {\n  DecoderBuffer,\n  EncoderBuffer\n};","map":{"version":3,"sources":["C:/Users/ethan/OneDrive/Desktop/Files/Coding/Websites/MathIsCool/MIC/node_modules/@panva/asn1.js/lib/asn1/base/buffer.js"],"names":["inherits","require","Reporter","DecoderBuffer","base","options","call","Buffer","isBuffer","error","offset","length","isDecoderBuffer","data","isCompatible","constructor","name","save","restore","isEmpty","readUInt8","skip","raw","prototype","reporter","res","fail","bytes","_reporterState","slice","EncoderBuffer","value","Array","isArray","map","item","isEncoderBuffer","byteLength","join","out","alloc","forEach","write","copy","module","exports"],"mappings":"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","sourcesContent":["const { inherits } = require('util')\r\n\r\nconst { Reporter } = require('../base/reporter')\r\n\r\nfunction DecoderBuffer (base, options) {\r\n  Reporter.call(this, options)\r\n  if (!Buffer.isBuffer(base)) {\r\n    this.error('Input not Buffer')\r\n    return\r\n  }\r\n\r\n  this.base = base\r\n  this.offset = 0\r\n  this.length = base.length\r\n}\r\ninherits(DecoderBuffer, Reporter)\r\n\r\nDecoderBuffer.isDecoderBuffer = function isDecoderBuffer (data) {\r\n  if (data instanceof DecoderBuffer) {\r\n    return true\r\n  }\r\n\r\n  // Or accept compatible API\r\n  const isCompatible = typeof data === 'object' &&\r\n    Buffer.isBuffer(data.base) &&\r\n    data.constructor.name === 'DecoderBuffer' &&\r\n    typeof data.offset === 'number' &&\r\n    typeof data.length === 'number' &&\r\n    typeof data.save === 'function' &&\r\n    typeof data.restore === 'function' &&\r\n    typeof data.isEmpty === 'function' &&\r\n    typeof data.readUInt8 === 'function' &&\r\n    typeof data.skip === 'function' &&\r\n    typeof data.raw === 'function'\r\n\r\n  return isCompatible\r\n}\r\n\r\nDecoderBuffer.prototype.save = function save () {\r\n  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) }\r\n}\r\n\r\nDecoderBuffer.prototype.restore = function restore (save) {\r\n  // Return skipped data\r\n  const res = new DecoderBuffer(this.base)\r\n  res.offset = save.offset\r\n  res.length = this.offset\r\n\r\n  this.offset = save.offset\r\n  Reporter.prototype.restore.call(this, save.reporter)\r\n\r\n  return res\r\n}\r\n\r\nDecoderBuffer.prototype.isEmpty = function isEmpty () {\r\n  return this.offset === this.length\r\n}\r\n\r\nDecoderBuffer.prototype.readUInt8 = function readUInt8 (fail) {\r\n  if (this.offset + 1 <= this.length) { return this.base.readUInt8(this.offset++, true) } else { return this.error(fail || 'DecoderBuffer overrun') }\r\n}\r\n\r\nDecoderBuffer.prototype.skip = function skip (bytes, fail) {\r\n  if (!(this.offset + bytes <= this.length)) { return this.error(fail || 'DecoderBuffer overrun') }\r\n\r\n  const res = new DecoderBuffer(this.base)\r\n\r\n  // Share reporter state\r\n  res._reporterState = this._reporterState\r\n\r\n  res.offset = this.offset\r\n  res.length = this.offset + bytes\r\n  this.offset += bytes\r\n  return res\r\n}\r\n\r\nDecoderBuffer.prototype.raw = function raw (save) {\r\n  return this.base.slice(save ? save.offset : this.offset, this.length)\r\n}\r\n\r\nfunction EncoderBuffer (value, reporter) {\r\n  if (Array.isArray(value)) {\r\n    this.length = 0\r\n    this.value = value.map(function (item) {\r\n      if (!EncoderBuffer.isEncoderBuffer(item)) { item = new EncoderBuffer(item, reporter) }\r\n      this.length += item.length\r\n      return item\r\n    }, this)\r\n  } else if (typeof value === 'number') {\r\n    if (!(value >= 0 && value <= 0xff)) { return reporter.error('non-byte EncoderBuffer value') }\r\n    this.value = value\r\n    this.length = 1\r\n  } else if (typeof value === 'string') {\r\n    this.value = value\r\n    this.length = Buffer.byteLength(value)\r\n  } else if (Buffer.isBuffer(value)) {\r\n    this.value = value\r\n    this.length = value.length\r\n  } else {\r\n    return reporter.error(`Unsupported type: ${typeof value}`)\r\n  }\r\n}\r\n\r\nEncoderBuffer.isEncoderBuffer = function isEncoderBuffer (data) {\r\n  if (data instanceof EncoderBuffer) {\r\n    return true\r\n  }\r\n\r\n  // Or accept compatible API\r\n  const isCompatible = typeof data === 'object' &&\r\n    data.constructor.name === 'EncoderBuffer' &&\r\n    typeof data.length === 'number' &&\r\n    typeof data.join === 'function'\r\n\r\n  return isCompatible\r\n}\r\n\r\nEncoderBuffer.prototype.join = function join (out, offset) {\r\n  if (!out) { out = Buffer.alloc(this.length) }\r\n  if (!offset) { offset = 0 }\r\n\r\n  if (this.length === 0) { return out }\r\n\r\n  if (Array.isArray(this.value)) {\r\n    this.value.forEach(function (item) {\r\n      item.join(out, offset)\r\n      offset += item.length\r\n    })\r\n  } else {\r\n    if (typeof this.value === 'number') { out[offset] = this.value } else if (typeof this.value === 'string') { out.write(this.value, offset) } else if (Buffer.isBuffer(this.value)) { this.value.copy(out, offset) }\r\n    offset += this.length\r\n  }\r\n\r\n  return out\r\n}\r\n\r\nmodule.exports = {\r\n  DecoderBuffer,\r\n  EncoderBuffer\r\n}\r\n"]},"metadata":{},"sourceType":"script"}